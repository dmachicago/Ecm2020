' ***********************************************************************
' Assembly         : EcmArchiver
' Author           : wdale
' Created          : 12-15-2020
'
' Last Modified By : wdale
' Last Modified On : 12-15-2020
' ***********************************************************************
' <copyright file="clsDbARCH.vb" company="ECM Library">
'     Copyright © ECM Library 2011, all rights reserved
' </copyright>
' <summary></summary>
' ***********************************************************************
#Const RemoteOcr = 0

Imports System.Data.SqlClient
Imports System.Globalization
Imports System.IO
Imports ECMEncryption
Imports Ionic.Zip
Imports Microsoft.Win32

''' <summary>
''' Class clsDatabaseARCH.
''' Implements the <see cref="System.IDisposable" />
''' </summary>
''' <seealso cref="System.IDisposable" />
Public Class clsDatabaseARCH : Implements IDisposable

    ''' <summary>
    ''' The curr domain
    ''' </summary>
    Dim currDomain As AppDomain = AppDomain.CurrentDomain

    ' Inherits System.Web.UI.Page

    ''' <summary>
    ''' The iso
    ''' </summary>
    Dim ISO As New clsIsolatedStorage
    ''' <summary>
    ''' The reg
    ''' </summary>
    Dim REG As New clsRegistry

    'Dim ProxyArchive As New SVCCLCArchive.Service1Client
    'Dim ProxyFS As New SVCFS.Service1Client

    ''' <summary>
    ''' The tc
    ''' </summary>
    Dim TC As New clsTimeCalcs
    ''' <summary>
    ''' The comp
    ''' </summary>
    Dim COMP As New clsCompression

    ''' <summary>
    ''' The b use command process for inventory
    ''' </summary>
    Dim bUseCommandProcessForInventory As Integer = CInt(System.Configuration.ConfigurationManager.AppSettings("UseCommandProcessForInventory"))
    ''' <summary>
    ''' The ddebug
    ''' </summary>
    Public ddebug As Boolean = False
    ''' <summary>
    ''' The ix v1
    ''' </summary>
    Dim IXV1 As Integer = 0
    ''' <summary>
    ''' The cf
    ''' </summary>
    Dim CF As New clsFile
    ''' <summary>
    ''' The enc
    ''' </summary>
    Dim ENC As New ECMEncrypt
    ''' <summary>
    ''' The log
    ''' </summary>
    Dim LOG As New clsLogging
    ''' <summary>
    ''' The utility
    ''' </summary>
    Dim UTIL As New clsUtility
    ''' <summary>
    ''' The dma
    ''' </summary>
    Dim DMA As New clsDma

    ''' <summary>
    ''' The kgen
    ''' </summary>
    Dim KGEN As New clsKeyGen

    '** Public ConnectionStringID As String = "XOMR1.1ConnectionString"
    '** Do not forget that this is a global access var to thte DBARCH
    '** and MUST be changed to run on different platforms.
    ''' <summary>
    ''' The connection string identifier
    ''' </summary>
    Public ConnectionStringID As String = ""

    ''' <summary>
    ''' The server name
    ''' </summary>
    Public ServerName As String = ""
    ''' <summary>
    ''' The TGT unique identifier
    ''' </summary>
    Public TgtGuid As String = ""

    ''' <summary>
    ''' The sl machine network
    ''' </summary>
    Public slMachineNetwork As New Dictionary(Of String, String)
    ''' <summary>
    ''' The sl container unique identifier
    ''' </summary>
    Public slContainerGuid As New Dictionary(Of String, Guid)
    ''' <summary>
    ''' The sl projects
    ''' </summary>
    Public slProjects As New SortedList
    ''' <summary>
    ''' The sl project teams
    ''' </summary>
    Public slProjectTeams As New SortedList
    ''' <summary>
    ''' The sl metric periods
    ''' </summary>
    Public slMetricPeriods As New SortedList
    ''' <summary>
    ''' The sl excel col names
    ''' </summary>
    Public slExcelColNames As New SortedList
    ''' <summary>
    ''' The sl growth platform
    ''' </summary>
    Public slGrowthPlatform As New SortedList
    ''' <summary>
    ''' The sl operating group
    ''' </summary>
    Public slOperatingGroup As New SortedList
    ''' <summary>
    ''' The sl operating unit
    ''' </summary>
    Public slOperatingUnit As New SortedList
    ''' <summary>
    ''' The sl geography
    ''' </summary>
    Public slGeography As New SortedList
    ''' <summary>
    ''' The sl geographic unit
    ''' </summary>
    Public slGeographicUnit As New SortedList
    ''' <summary>
    ''' The sl client service group
    ''' </summary>
    Public slClientServiceGroup As New SortedList
    ''' <summary>
    ''' The sl delivery center
    ''' </summary>
    Public slDeliveryCenter As New SortedList
    ''' <summary>
    ''' The sl type of work
    ''' </summary>
    Public slTypeOfWork As New SortedList
    ''' <summary>
    ''' The sl project team type of work
    ''' </summary>
    Public slProjectTeamTypeOfWork As New SortedList
    ''' <summary>
    ''' The sl submission status
    ''' </summary>
    Public slSubmissionStatus As New SortedList
    ''' <summary>
    ''' The sl submitted by
    ''' </summary>
    Public slSubmittedBy As New SortedList
    ''' <summary>
    ''' The el
    ''' </summary>
    Public EL As New ArrayList

    ''' <summary>
    ''' The table cols
    ''' </summary>
    Public TblCols(4, 0) As String

    ' Dim owner As IWin32Window
    ''' <summary>
    ''' The g connection string
    ''' </summary>
    Dim gConnStr As String = ""

    ''' <summary>
    ''' The dbdir
    ''' </summary>
    Dim DBDIR As String = "C:\Program Files\Microsoft SQL Server\MSSQL.1\MSSQL\Data\org_db.mdf"
    ''' <summary>
    ''' The dq
    ''' </summary>
    Dim DQ As String = Chr(34)

    'Private gCurrUserGuidID = ""
    ''' <summary>
    ''' The curr user pw
    ''' </summary>
    Private CurrUserPW As String = ""

    ''' <summary>
    ''' The g connection
    ''' </summary>
    Dim gConn As SqlConnection = Nothing
    ''' <summary>
    ''' The g command
    ''' </summary>
    Dim gCmd As SqlCommand = Nothing
    ''' <summary>
    ''' The overwrite once
    ''' </summary>
    Dim OverwriteOnce As Boolean = False
    ''' <summary>
    ''' The overwrite always
    ''' </summary>
    Dim OverwriteAlways As Boolean = False

    ''' <summary>
    ''' The gateway identifier
    ''' </summary>
    Private _GatewayID As String = ""

    ''' <summary>
    ''' Initializes a new instance of the <see cref="clsDatabaseARCH"/> class.
    ''' </summary>
    Sub New()
        'Dim sDebug  = System.Configuration.ConfigurationManager.AppSettings("debug_clsDatabase")
        'Dim sDebug As String = getUserParm("debug_ClsDatabase")

        AddHandler currDomain.UnhandledException, AddressOf MYExnHandler
        AddHandler Application.ThreadException, AddressOf MYThreadHandler



    End Sub

    ''' <summary>
    ''' Gets the data set.
    ''' </summary>
    ''' <param name="MySql">My SQL.</param>
    ''' <returns>DataSet.</returns>
    Public Function getDataSet(MySql As String) As DataSet

        Dim ds As New DataSet
        Dim adapter As New SqlDataAdapter
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)

        Try
            CONN.Open()
            Using CONN
                Dim command As New SqlCommand(MySql, CONN)
                Using command
                    adapter.SelectCommand = command
                    adapter.Fill(ds)
                    adapter.Dispose()
                End Using
            End Using

            'For i = 0 To ds.Tables(0).Rows.Count - 1
            '    MsgBox(ds.Tables(0).Rows(i).Item(0) & "  --  " & ds.Tables(0).Rows(i).Item(1))
            'Next

        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getDataSet 01: " + ex.Message + Environment.NewLine + MySql)
        End Try

        Return ds

    End Function

    ''' <summary>
    ''' Gets the users allowed file ext.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function getUsersAllowedFileExt(UserID As String) As List(Of String)

        Dim L As New List(Of String)
        Dim S As String = "Select distinct lower(ExtCode) from IncludedFiles where UserID = '" + UserID + "'"
        Dim ext As String = ""

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Using CONN
            Dim command As New SqlCommand(S, CONN)
            Using command
                Using RSD As SqlDataReader = command.ExecuteReader()
                    If RSD.HasRows Then
                        Do While RSD.Read()
                            ext = RSD.GetValue(0).ToString.ToLower
                            If Not L.Contains(ext) Then
                                L.Add(ext)
                            End If
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return L

    End Function

    ''' <summary>
    ''' Gets the existing files.
    ''' </summary>
    ''' <param name="TgtDir">The TGT dir.</param>
    ''' <param name="ScanSubDir">The scan sub dir.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function getExistingFiles(TgtDir As String, ScanSubDir As String, MachineID As String, UserID As String) As List(Of String)

        Dim L As New List(Of String)
        Dim S As String = ""
        Dim fqn As String = ""
        Dim hash As String = ""

        If ScanSubDir.ToUpper.Equals("Y") Then
            S = "Select distinct FQN from DataSource where FileDirectory like '" + TgtDir + "%' and UserID = '" + UserID + "' "
        Else
            S = "Select distinct FQN from DataSource where FileDirectory = '" + TgtDir + "'  and UserID = '" + UserID + "' "
        End If

        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Using CONN
                Dim command As New SqlCommand(S, CONN)
                Using command
                    Using RSD As SqlDataReader = command.ExecuteReader()
                        If RSD.HasRows Then
                            Do While RSD.Read()
                                fqn = RSD.GetValue(0).ToString.ToLower
                                L.Add(fqn)
                            Loop
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            MessageBox.Show("getExisting Files ERROR: " + ex.Message)
            LOG.WriteToArchiveLog("getExisting Files ERROR: " + ex.Message)
        End Try



        Return L

    End Function

    ''' <summary>
    ''' Gets the DSFQN.
    ''' </summary>
    ''' <param name="TOPN">The topn.</param>
    ''' <param name="PASSEDfqn">The passe DFQN.</param>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Public Function getDSFQN(TOPN As String, PASSEDfqn As String) As Dictionary(Of String, String)

        Dim L As New Dictionary(Of String, String)
        Dim S As String = "Select top " + TOPN + " FqnHASH, FQN from DataSourceFQN"
        Dim fqn As String = ""
        Dim hash As String = ""

        If PASSEDfqn.Length > 0 Then
            S = "Select FqnHASH, FQN from DataSourceFQN where fqn = '" + PASSEDfqn + "' "
        End If

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Using CONN
            Dim command As New SqlCommand(S, CONN)
            Using command
                Using RSD As SqlDataReader = command.ExecuteReader()
                    If RSD.HasRows Then
                        Do While RSD.Read()
                            hash = RSD.GetValue(0).ToString.ToLower
                            fqn = RSD.GetValue(1).ToString.ToLower
                            L.Add(hash, fqn)
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return L

    End Function

    ''' <summary>
    ''' Sets the DSFQN.
    ''' </summary>
    Public Sub setDSFQN()

        Dim FM = New frmMessageBar()

        FM.Show()
        FM.ResetText()
        FM.Text = "Long Running Process - Validating Long File names"
        FM.lblmsg.Text = ""
        FM.Refresh()
        Application.DoEvents()

        Dim ListOfDirs As New Dictionary(Of String, String)
        Dim S As String = "Select distinct upper(FQN) from DataSource where FqnHASH is null or ltrim(rtrim(FqnHASH)) = '' "
        Dim fqn As String = ""
        Dim hash As String = ""

        FM.lblmsg.Text = "Finding Long File names, standby"
        FM.Refresh()
        Application.DoEvents()

        Dim iTotal As Integer = getCount("Select count(*) from DataSource WHERE FqnHASH is null or ltrim(rtrim(FqnHASH)) = '' ")

        If iTotal.Equals(0) Then
            FM.Close()
            FM.Dispose()
            MessageBox.Show("No files found to be missing their Hash Codes, returning...")
            Return
        End If

        FM.lblmsg.Text = "Total files to process: " + iTotal.ToString
        FM.Refresh()
        Application.DoEvents()


        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()

        Dim cmdSql As SqlCommand = New SqlCommand("…")
        cmdSql.Parameters.Add(New SqlParameter("@sId", SqlDbType.VarChar, 10))

        FM.lblmsg.Text = "Building Long File names' HASH, standby"
        FM.Refresh()
        Application.DoEvents()


        Dim icnt As Integer = 0
        Try
            Using CONN
                FM.lblmsg.Text = "Calculating HASH:"
                Dim command As New SqlCommand(S, CONN)
                command.CommandType = CommandType.Text

                Using command
                    Using RSD As SqlDataReader = command.ExecuteReader()
                        If RSD.HasRows Then
                            Do While RSD.Read()
                                icnt += 1
                                FM.lblCnt.Text = icnt.ToString
                                FM.Refresh()
                                Application.DoEvents()
                                fqn = RSD.GetValue(0).ToString.ToUpper
                                If File.Exists(fqn) Then
                                    hash = ENC.SHA512SqlServerHash(fqn)
                                    If Not ListOfDirs.Keys.Contains(hash) Then
                                        ListOfDirs.Add(hash, fqn)
                                    End If
                                Else
                                    LOG.WriteToArchiveLog("MISSING FILE: " + fqn)
                                End If
                            Loop
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            Console.WriteLine("ERROR setDSFQN 120A: " + ex.Message)
            LOG.WriteToArchiveLog("ERROR setDSFQN 120A: " + ex.Message)
        End Try

        iTotal = ListOfDirs.Count

        Dim CON As New SqlConnection(CS)
        CON.Open()
        Using CON
            Dim CMD As SqlCommand = New SqlCommand("", CON)
            Using CMD
                FM.Text = "UPDATING ALL LONG NAMES - Long Running Process"
                CMD.Parameters.Add(New SqlParameter("@fqn", SqlDbType.VarChar, 8000))
                CMD.Parameters.Add(New SqlParameter("@FqnHASH", SqlDbType.VarChar, 150))

                iTotal = ListOfDirs.Count
                icnt = 0

                For Each hash In ListOfDirs.Keys
                    icnt += 1
                    FM.lblmsg.Text = icnt.ToString + " of " + iTotal.ToString
                    FM.Refresh()
                    Application.DoEvents()

                    fqn = ListOfDirs(hash)
                    If fqn.Contains("'") Then
                        Console.WriteLine(fqn)
                        'fqn = fqn.Replace("'", "''")
                    End If
                    Try
                        CMD.Parameters("@fqn").Value = fqn
                        CMD.Parameters("@FqnHASH").Value = hash

                        S = "update DataSource set FqnHASH = @FqnHASH where fqn = @fqn ; "
                        CMD.CommandText = S
                        CMD.ExecuteNonQuery()

                        S = "If not exists (Select 1 from DataSourceFQN where FqnHASH = @FqnHASH )
                              INSERT INTO DataSourceFQN (FqnHASH, fqn) values (@FqnHASH, @fqn);"

                        CMD.CommandText = S
                        CMD.ExecuteNonQuery()
                    Catch ex As Exception
                        LOG.WriteToArchiveLog("ERROR setDSFQN: " + ex.Message)
                        Console.WriteLine(ex.Message)
                    End Try
                Next
            End Using
        End Using
        FM.Close()
        FM.Dispose()
    End Sub

    ''' <summary>
    ''' Validates the file hash.
    ''' </summary>
    Public Sub validateFileHash()

        frmMessageBar.Show()
        frmMessageBar.ResetText()
        frmMessageBar.Text = "Long Running Process - Validating File Hashes"
        frmMessageBar.lblmsg.Text = ""
        frmMessageBar.Refresh()
        Application.DoEvents()

        Dim SS As String = "ExecuteSql(delete from DataSource where FQN is null or ltrim(rtrim(FQN)) = '';"

        Dim ListToUpdateFromFileHash As New Dictionary(Of String, String)
        Dim ListToUpdateFromSourceImage As New Dictionary(Of String, String)
        Dim S As String = "select SourceGuid, FQN from DataSource DS where HashFile is null or ltrim(rtrim(HashFile)) = '' ;"
        Dim FQN As String = ""
        Dim hash As String = ""
        Dim SourceGuid As String = ""

        frmMessageBar.lblmsg.Text = "Finding Long File names, standby"
        frmMessageBar.Refresh()
        Application.DoEvents()

        Dim iTotal As Integer = getCount("Select count(*) from DataSource WHERE FqnHASH IS NULL")

        frmMessageBar.lblmsg.Text = "Total files to process: " + iTotal.ToString
        frmMessageBar.Refresh()
        Application.DoEvents()


        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()

        bSuccess = ExecuteSql(SS, CS, False)

        Dim cmdSql As SqlCommand = New SqlCommand("…")
        cmdSql.Parameters.Add(New SqlParameter("@sId", SqlDbType.VarChar, 10))

        frmMessageBar.lblmsg.Text = "Validating files in Repositoty"
        frmMessageBar.Refresh()
        Application.DoEvents()


        Dim icnt As Integer = 0
        Try
            Using CONN
                Dim command As New SqlCommand(S, CONN)
                command.CommandType = CommandType.Text

                Using command
                    Using RSD As SqlDataReader = command.ExecuteReader()
                        If RSD.HasRows Then
                            Do While RSD.Read()
                                icnt += 1
                                frmMessageBar.lblCnt.Text = icnt.ToString
                                frmMessageBar.Refresh()
                                Application.DoEvents()
                                SourceGuid = RSD.GetValue(0).ToString
                                FQN = RSD.GetValue(1).ToString
                                If Not File.Exists(FQN) Then
                                    If Not ListToUpdateFromSourceImage.Keys.Contains(SourceGuid) Then
                                        ListToUpdateFromSourceImage.Add(SourceGuid, FQN)
                                        LOG.WriteToArchiveLog(">> HASHED BINARY: " + FQN)
                                    End If
                                Else
                                    hash = ENC.GenerateSHA512HashFromFile(FQN)
                                    If Not ListToUpdateFromFileHash.Keys.Contains(SourceGuid) Then
                                        ListToUpdateFromFileHash.Add(SourceGuid, hash)
                                    End If
                                    LOG.WriteToArchiveLog("** HASHED FILE: " + FQN)
                                End If
                            Loop
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            Console.WriteLine("ERROR validateFileHash 220A: " + ex.Message)
            LOG.WriteToArchiveLog("ERROR validateFileHash 220A: " + ex.Message)
        End Try

        iTotal = ListToUpdateFromSourceImage.Count

        Dim CON As New SqlConnection(CS)
        CON.Open()
        Using CON
            Dim CMD As SqlCommand = New SqlCommand("", CON)
            'CMD.Parameters.Add(New SqlParameter("@SourceGuid", SqlDbType.NVarChar, 50))
            Using CMD
                frmMessageBar.Text = "UPDATING HASH from SourceImage"
                'CMD.Parameters.Add(New SqlParameter("@SourceGuid", SqlDbType.NVarChar, 50))

                iTotal = ListToUpdateFromSourceImage.Count
                icnt = 0

                For Each SourceGuid In ListToUpdateFromSourceImage.Keys
                    icnt += 1
                    frmMessageBar.lblmsg.Text = icnt.ToString + " of " + iTotal.ToString
                    frmMessageBar.Refresh()
                    Application.DoEvents()
                    Try
                        'CMD.Parameters("@SourceGuid").Value = SourceGuid
                        S = "Update DataSource set SourceImageOrigin = 'SRCIMG', HashFile = UPPER(convert(char(128), HASHBYTES('sha2_512', cast(SourceImage as nvarchar(max))),1)) where SourceGuid = '" + SourceGuid + "'  ;"
                        CMD.CommandText = S
                        CMD.ExecuteNonQuery()
                        Application.DoEvents()
                    Catch ex As Exception
                        LOG.WriteToArchiveLog("ERROR validateFileHash 221X: " + ex.Message)
                        Console.WriteLine(ex.Message)
                    End Try
                Next
            End Using
        End Using

        Dim HashFile As String = ""
        Dim CONX As New SqlConnection(CS)
        CONX.Open()
        Using CONX
            Dim CMD As SqlCommand = New SqlCommand("", CONX)
            Using CMD
                frmMessageBar.Text = "UPDATING HASH from FILE"
                'CMD.Parameters.Add(New SqlParameter("@SourceGuid", SqlDbType.NVarChar, 50))
                'CMD.Parameters.Add(New SqlParameter("@HashFile", SqlDbType.NVarChar, 50))

                iTotal = ListToUpdateFromFileHash.Count
                icnt = 0

                For Each SourceGuid In ListToUpdateFromFileHash.Keys
                    icnt += 1
                    HashFile = ListToUpdateFromFileHash(SourceGuid)
                    frmMessageBar.lblmsg.Text = icnt.ToString + " of " + iTotal.ToString
                    frmMessageBar.Refresh()
                    Application.DoEvents()

                    Try
                        'CMD.Parameters("@SourceGuid").Value = SourceGuid
                        'CMD.Parameters("@HashFile").Value = HashFile
                        'S = "Update DataSource set SourceImageOrigin = 'FILE', HashFile = @HashFile where SourceGuid = @SourceGuid ;"
                        S = "Update DataSource set SourceImageOrigin = 'FILE', HashFile = '" + HashFile + "' where SourceGuid = '" + SourceGuid + "' ;"
                        CMD.CommandText = S
                        CMD.ExecuteNonQuery()
                        Application.DoEvents()
                    Catch ex As Exception
                        LOG.WriteToArchiveLog("ERROR validateFileHash 221X: " + ex.Message)
                        Console.WriteLine(ex.Message)
                    End Try
                Next
            End Using
        End Using

        frmMessageBar.Close()

    End Sub


    ''' <summary>
    ''' Gets the SQL server hash.
    ''' </summary>
    ''' <param name="str">The string.</param>
    ''' <param name="ReturnHEX">if set to <c>true</c> [return hexadecimal].</param>
    ''' <returns>System.String.</returns>
    Public Function getSqlServerHASH(str As String, Optional ReturnHEX As Boolean = False) As String

        'If IsNothing(ReturnHEX) Then
        '    ReturnHEX = False
        'End If
        Dim S As String = ""

        str = str.Replace(" ''", "'")
        str = str.Replace("'", "''")

        Dim L As New Dictionary(Of String, String)
        If ReturnHEX.Equals(True) Then
            S = "SELECT convert(char(128), HASHBYTES('sha2_512', '" + str.ToUpper + "'), 1) as XHASH; "
        Else
            S = "SELECT convert(char(128), HASHBYTES('sha2_512', '" + str.ToUpper + "'), 2) as XHASH; "
        End If

        Dim hash As String = ""
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)

        CONN.Open()
        Try
            Using CONN
                Dim command As New SqlCommand(S, CONN)
                Using command
                    Using RSD As SqlDataReader = command.ExecuteReader()
                        If RSD.HasRows Then
                            RSD.Read()
                            hash = RSD.GetValue(0).ToString
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: getSqlServerHASH <" + str + ">")
            Return ""
        End Try


        Return hash

    End Function


    ''' <summary>
    ''' Gets or sets the global gateway ID.
    ''' </summary>
    ''' <value>The gateway identifier.</value>
    Public Property GatewayID() As String
        Get
            Return _GatewayID
        End Get
        Private Set(ByVal value As String)
            _GatewayID = value
        End Set
    End Property

    ''' <summary>
    ''' Sets the ocr processing parms.
    ''' </summary>
    ''' <param name="SourceGuid">The source GUID.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="FileName">Name of the file.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SetOcrProcessingParms(SourceGuid As String, SourceTypeCode As String, FileName As String) As Boolean

        FileName = UTIL.RemoveSingleQuotes(FileName)

        Dim b As Boolean = False
        Dim S As String = ""
        If SourceTypeCode.ToUpper.Equals("A") Then
            S = "Update EmailAttachment set RequireOcr = 1 where EmailGuid = '" + SourceGuid + "' and AttachmentName = '" + FileName + "' "
        ElseIf SourceTypeCode.ToUpper.Equals("C") Then
            S = "Update DataSource set RequireOcr = 1 where SourceGuid = '" + SourceGuid + "'"
        Else
            Return False
        End If

        b = ExecuteSqlNewConn(90101, S)

        'WDM CHECK THIS
        'If b Then
        '    ProxyArchive.consoleOcrSingleFile(gGateWayID, SourceGuid, SourceTypeCode)
        'End If

        Return b
    End Function

    ''' <summary>
    ''' Cks the col data.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="ColName">Name of the col.</param>
    ''' <param name="tData">The t data.</param>
    ''' <returns>System.String.</returns>
    Function CkColData(ByVal TblName As String, ByVal ColName As String, ByVal tData As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim xData As String = ""
        Dim K As Integer
        Dim CurrLen As Integer = tData.Length
        Dim MaxLen As Integer = 0
        Dim table_name As String = ""
        Dim column_name As String = ""
        Dim data_type As String = ""
        Dim character_maximum_length As Integer = 0
        Dim B As Boolean = False

        For K = 1 To UBound(TblCols, 2)
            table_name = UCase(TblCols(0, K))
            column_name = UCase(TblCols(1, K))
            data_type = TblCols(2, K)
            character_maximum_length = CInt(TblCols(3, K))
            If table_name.Equals(UCase(TblName)) Then
                If column_name.Equals(UCase(ColName)) Then
                    B = True
                    xData = tData
                    Exit For
                End If
            End If
        Next
        If B Then
            If character_maximum_length < CurrLen Then
                'tData  = Mid(tData, 1, MaxLen)
                xData = Mid(tData, 1, character_maximum_length)
                ''Session("ErrMsgs") = 'Session("ErrMsgs") + "<br>" + "" + ColName + " > " + Str(character_maximum_length) + " characters - truncated."
            Else
                xData = tData
            End If
        End If
        Return xData
    End Function

    ''' <summary>
    ''' LoadColInfo reads table_name, column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS.
    ''' </summary>
    Sub LoadColInfo()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " select table_name, column_name, data_type, character_maximum_length  "
        S = S + " from INFORMATION_SCHEMA.COLUMNS "
        'S = S + " where table_name = 'Project' "
        S = S + " order by table_name, column_name"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim table_name As String = ""
        Dim column_name As String = ""
        Dim data_type As String = ""
        Dim character_maximum_length As String = ""

        If UBound(TblCols, 2) > 2 Then
            Return
        End If

        ReDim TblCols(4, 0)

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                table_name = RSData.GetValue(0).ToString
                column_name = RSData.GetValue(1).ToString
                data_type = RSData.GetValue(2).ToString
                character_maximum_length = RSData.GetValue(3).ToString
                II = UBound(TblCols, 2) + 1
                ReDim Preserve TblCols(4, II)
                TblCols(0, II) = table_name
                TblCols(1, II) = column_name
                TblCols(2, II) = data_type
                TblCols(3, II) = character_maximum_length
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Sets the email CRC hash.
    ''' </summary>
    ''' <param name="isadmin">if set to <c>true</c> [isadmin].</param>
    Sub setEmailCrcHash(isadmin As Boolean)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If Not isadmin Then
            MessageBox.Show("Sorry, administrative authority needed for this function, please contact your corporate admin - returning.")
            Return
        End If

        Dim ListOfEmailIdentifiers As New Dictionary(Of String, String)

        Dim S As String = ""
        S = S + " select EmailGuid, CreationTime, SenderEmailAddress, Subject "
        S = S + " from Email "

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0

        Dim EmailGuid As String = ""
        Dim CreationTime As Date
        Dim SenderEmailAddress As String = ""
        Dim Subject As String = ""

        If UBound(TblCols, 2) > 2 Then
            Return
        End If
        II = 0
        ReDim TblCols(4, 0)
        Dim Msg As String = ""
        Dim RSData As SqlDataReader = Nothing

        frmMain.PB1.Value = 0
        frmMain.PB1.Maximum = 15000

        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                frmMain.SB.Text = II.ToString
                frmMain.SB.Refresh()
                Application.DoEvents()
                Msg = ""
                Try
                    EmailGuid = RSData.GetValue(0).ToString
                    CreationTime = RSData.GetDateTime(1)
                    SenderEmailAddress = RSData.GetValue(2).ToString()
                    Subject = RSData.GetValue(3).ToString()

                    Dim EmailIdentifier As String = UTIL.genEmailIdentifier(CreationTime, SenderEmailAddress, Subject)
                    ListOfEmailIdentifiers.Add(EmailGuid, EmailIdentifier)
                Catch ex As Exception
                    Console.WriteLine(ex.Message)
                End Try
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        frmMain.PB1.Value = 0
        frmMain.PB1.Maximum = ListOfEmailIdentifiers.Count + 2
        II = 0
        Dim ListOfGuids As New List(Of String)
        Dim MySql As String = ""
        Dim sVal As String = ""
        For Each sGuid As String In ListOfEmailIdentifiers.Keys
            Application.DoEvents()
            sVal = ListOfEmailIdentifiers(sGuid)
            MySql = "*"
            MySql = "Update Email set EmailIdentifier = '" + sVal + "' where EmailGuid = '" + sGuid + "' "
            b = ExecuteSqlNewConn(90102, MySql)
            If Not b Then
                ListOfGuids.Add(sGuid)
            End If
            II += 1
            If II Mod 5 = 0 Then
                frmMain.SB.Text = II.ToString + " of " + ListOfEmailIdentifiers.Count.ToString + " / " + ListOfGuids.Count.ToString
                frmMain.SB.Refresh()
            End If
            Application.DoEvents()
            MySql = "***********"
        Next
        II = 0
        For Each sGuid As String In ListOfGuids
            Application.DoEvents()
            MySql = "*"
            MySql = "delete from Email where EmailGuid = '" + sGuid + "' "
            b = ExecuteSqlNewConn(90103, MySql)
            II += 1
            If II Mod 10 = 0 Then
                frmMain.SB.Text = II.ToString + " of " + ListOfEmailIdentifiers.Count.ToString
                frmMain.SB.Refresh()
            End If
            Application.DoEvents()
            MySql = "***********"
        Next
        frmMain.SB.Text = "Done."
        MessageBox.Show("Update complete.")
    End Sub

    ''' <summary>
    ''' LoadColInfo reads table_name, column_name, data_type, character_maximum_length from
    ''' INFORMATION_SCHEMA.COLUMNS based on the provided Table Name.
    ''' </summary>
    ''' <param name="TableName">The name of the table to retrieve column information about.</param>
    Sub LoadColInfo(ByVal TableName As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " select table_name, column_name, data_type, character_maximum_length  " + environment.NewLine
        S = S + " from INFORMATION_SCHEMA.COLUMNS " + environment.NewLine
        S = S + " where table_name = '" + TableName + "' " + environment.NewLine
        S = S + " order by table_name, column_name" + environment.NewLine

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim table_name As String = ""
        Dim column_name As String = ""
        Dim data_type As String = ""
        Dim character_maximum_length As String = ""

        If UBound(TblCols, 2) > 2 Then
            Return
        End If

        ReDim TblCols(4, 0)

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                table_name = RSData.GetValue(0).ToString
                column_name = RSData.GetValue(1).ToString
                data_type = RSData.GetValue(2).ToString
                character_maximum_length = RSData.GetValue(3).ToString
                II = UBound(TblCols, 2) + 1
                ReDim Preserve TblCols(4, II)
                TblCols(0, II) = table_name
                TblCols(1, II) = column_name
                TblCols(2, II) = data_type
                TblCols(3, II) = character_maximum_length
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Audits the specified SQL.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="UserID">The user identifier.</param>
    Sub Audit(ByVal sql As String, ByVal UserID As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim i As Integer = 0
        Dim j As Integer = 0
        Dim s As String = sql.Trim

        Dim Tbl As String = GetTableNameFromSql(sql)
        'Dim wc As String = GetWhereClauseFromSql(sql)
        Dim TypeStmt As String = GetTypeSqlStmt(sql)

        Tbl = UCase(Tbl)

        sql = UTIL.RemoveSingleQuotes(sql)
        Dim A As String() = Split(sql, " ")

        gCurrUserGuidID = UserID

        Dim b As Boolean = AuditInsert(Date.Today.ToString, gCurrUserGuidID, sql, Tbl, TypeStmt, Now.ToString)

        If Not b Then
            Console.WriteLine("Audit Failed: " + sql)
        End If

    End Sub

    ''' <summary>
    ''' Cks the null.
    ''' </summary>
    ''' <param name="tVal">The t value.</param>
    ''' <returns>System.String.</returns>
    Public Function ckNull(ByVal tVal As String) As String
        If tVal.Trim.Length = 0 Then
            Return "null"
        Else
            Return tVal
        End If
    End Function

    ''' <summary>
    ''' Audits the insert.
    ''' </summary>
    ''' <param name="ChangeID">The change identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="Msg">The MSG.</param>
    ''' <param name="TableName">Name of the table.</param>
    ''' <param name="TypeChange">The type change.</param>
    ''' <param name="ChangeDate">The change date.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function AuditInsert(ByVal ChangeID As String, ByVal UserID As String, ByVal Msg As String, ByVal TableName As String, ByVal TypeChange As String, ByVal ChangeDate As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = False

        Dim S As String = ""
        S = S + " INSERT INTO audit("
        S = S + "UserID,"
        S = S + "SqlStmt,"
        S = S + "TableName,"
        S = S + "TypeChange,"
        S = S + "ChangeDate, ChangeID) values ("
        S = S + "'" + UserID + "'" + ","
        S = S + "'" + Msg + "'" + ","
        S = S + "'" + TableName + "'" + ","
        S = S + "'" + TypeChange + "'" + ","
        S = S + "'" + ChangeDate + "',"
        S = S + "'" + ChangeID + "'" + ")"

        b = ExecuteSqlNoAudit(S)

        If Not b Then
            Console.WriteLine("Audit Failed: " + S)
        End If

        Return b

    End Function

    ''' <summary>
    ''' Adds the nulls.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.String.</returns>
    Public Function AddNulls(ByVal S As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim i As Integer = 0
        Dim j As Integer = 0

        Do While InStr(S, ",,", CompareMethod.Text) > 0
            i = InStr(S, ",,", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 1)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, ",)", CompareMethod.Text) > 0
            i = InStr(S, ",)", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 1)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, "=)", CompareMethod.Text) > 0
            i = InStr(S, "=)", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 1)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, "= ,", CompareMethod.Text) > 0
            i = InStr(S, "= ,", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 2)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, "= )", CompareMethod.Text) > 0
            i = InStr(S, "= )", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 2)
            S = s1 + "null" + s2
        Loop
        Return S
    End Function

    ''' <summary>
    ''' Adds the nulls to update.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.String.</returns>
    Public Function AddNullsToUpdate(ByVal S As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim i As Integer = 0
        Dim j As Integer = 0

        Do While InStr(S, "= ,", CompareMethod.Text) > 0
            i = InStr(S, "= ,", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 2)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, "= )", CompareMethod.Text) > 0
            i = InStr(S, "= )", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 2)
            S = s1 + "null" + s2
        Loop

        Do While InStr(S, "=,", CompareMethod.Text) > 0
            i = InStr(S, "=,", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 1)
            S = s1 + "null" + s2
        Loop
        Do While InStr(S, "=)", CompareMethod.Text) > 0
            i = InStr(S, "=)", CompareMethod.Text)
            j = i + 1
            Dim s1 = Mid(S, 1, i)
            Dim s2 = Mid(S, i + 1)
            S = s1 + "null" + s2
        Loop

        Return S
    End Function

    ''' <summary>
    ''' Cks the database connection.
    ''' </summary>
    ''' <param name="From">From.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckDbConnection(ByVal From As String) As Boolean
        ddebug = False

        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr()

        CkConn()

        Try
            If gConn Is Nothing Then

                Try
                    gConn.ConnectionString = CS
                    gConn.Open()
                    b = True
                Catch ex As Exception
                    Me.xTrace(28000, "ckDbConnection", ex.Message.ToString)
                    b = False
                    LOG.WriteToArchiveLog("ERROR From '" + From + "' clsDatabaseARCH : ckDbConnection : 243a : ", ex)
                    If ddebug Then LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbConnection : 25 : " + gConn.ConnectionString)
                End Try
            End If
            If gConn.State = Data.ConnectionState.Closed Then
                If ddebug Then LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbConnection : 26 : " + gConn.ConnectionString)
                Try
                    CS = getRepoConnStr()
                    If CS = Nothing Then
                        CS = System.Configuration.ConfigurationManager.AppSettings("ECMREPO")
                    End If
                    If gConn.State = ConnectionState.Open Then
                        gConn.Close()
                    End If
                    gConn.ConnectionString = CS
                    gConn.Open()
                    b = True
                Catch ex As Exception
                    Try
                        If gConn.State = ConnectionState.Open Then
                            gConn.Close()
                        End If
                        CS = System.Configuration.ConfigurationManager.AppSettings("ECMREPO")
                        If gConn.State = ConnectionState.Open Then
                            gConn.Close()
                        End If
                        gConn.ConnectionString = CS
                        gConn.Open()
                        Return True
                    Catch ex2 As Exception
                        LOG.WriteToArchiveLog("ERROR From '" + From + " ' clsDatabaseARCH : ckDbConnection : 23e: ", ex)
                    End Try
                    LOG.WriteToArchiveLog("ERROR From '" + From + " ' clsDatabaseARCH : ckDbConnection : 23b: ", ex)
                    b = False
                    Dim ShowBox As Boolean = False
                    If ShowBox And gRunUnattended = False Then MessageBox.Show("The database connection failed at error marker 2301.2334.1 : " + environment.NewLine + ex.Message)
                End Try
            Else
                b = True
            End If
        Catch ex As Exception
            If ddebug Then LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbConnection : 43 : " + CS)
            Me.xTrace(28002, "ckDbConnection", ex.Message.ToString)
            b = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbConnection : 313 : ", ex)
        End Try
        If ddebug Then LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbConnection : 44 : " + CS)
        Return b
    End Function

    ''' <summary>
    ''' Uses the encrypted.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UseEncrypted() As Boolean
        Dim strVal As String = System.Configuration.ConfigurationManager.AppSettings("UseEncrypted")
        If strVal.Equals("1") Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Resets the iso connection string.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <returns>System.String.</returns>
    Function resetIsoConnStr(SecureID As Integer) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tKey As String = "CS" + SecureID.ToString
        Dim fn As String = "CS" + SecureID.ToString + ".cs"
        ISO.PersistDataSave(tKey, "")
        Return fn
    End Function

    ''' <summary>
    ''' Gets the iso connection string.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <returns>System.String.</returns>
    Function getIsoConnStr(SecureID As Integer) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tKey As String = "CS" + SecureID.ToString
        Dim cs As String = ISO.PersistDataRead(tKey)
        Return cs
    End Function

    ''' <summary>
    ''' Saves the iso connection string.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="ECS">The ecs.</param>
    Sub saveIsoConnStr(SecureID As Integer, ECS As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tKey As String = "CS" + SecureID.ToString
        Dim fn As String = "CS" + SecureID.ToString + ".cs"
        ISO.PersistDataSave(tKey, ECS)
    End Sub

    'Public Function getGateWayConnStr(SecureID As Integer) As String

    ' Dim CS As String = "" Dim strSecID = SecureID.ToString

    ' CS = getIsoConnStr(SecureID) If (CS.Length > 0) Then gDictOfConstr.Add(SecureID, CS) CS =
    ' ENC.AES256DecryptString(CS) Return CS End If If gDictOfConstr.Count > 0 Then If
    ' gDictOfConstr.ContainsKey(SecureID) Then CS = gDictOfConstr(SecureID) CS =
    ' ENC.AES256DecryptString(CS) End If Else 'Dim ProxyGateway As New SVCGateway.Service1Client Try If
    ' (ProxyGateway Is Nothing) Then ProxyGateway = New SVCGateway.Service1Client End If 'The next
    ' statement, GetCS, is defined in clsSecureLogin.cls , project clsSecureLogin CS =
    ' ProxyGateway.getCS(SecureID) If (CS.Contains("ERROR:")) Then Else saveIsoConnStr(SecureID, CS)
    ' gDictOfConstr.Add(SecureID, CS) CS = ENC.AES256DecryptString(CS) End If Catch ex As Exception CS =
    ' "" ' xTrace(666, "getRepoConnStr", "Failed to get Gateway CS: " , ex) Finally
    ' ProxyGateway = Nothing GC.Collect() GC.WaitForPendingFinalizers() End Try End If

    ' Return CS

    'End Function

    ''' <summary>
    ''' Gets the license connection string.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getLicenseConnStr() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim pw As String = System.Configuration.ConfigurationManager.AppSettings("ENCPW")
        pw = ENC.AES256DecryptString(pw)
        Dim CS As String = System.Configuration.ConfigurationManager.AppSettings("ECMLICENSE")
        CS = CS.Replace("@@PW@@", pw)
        Return CS

    End Function

    ''' <summary>
    ''' Gets the repo connection string.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getRepoConnStr() As String
        'If gTraceFunctionCalls.Equals(1) Then
        '    LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        'End If

        Dim pw As String = System.Configuration.ConfigurationManager.AppSettings("ENCPW")
        pw = ENC.AES256DecryptString(pw)
        Dim CS As String = System.Configuration.ConfigurationManager.AppSettings("ECMREPO")
        CS = CS.Replace("@@PW@@", pw)
        Return CS

    End Function

    ''' <summary>
    ''' Sets the connection string.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function setConnStr() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Return getRepoConnStr()

    End Function

    ''' <summary>
    ''' Gets the gate way connection string x.
    ''' </summary>
    ''' <param name="gGateWayID">The g gate way identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getGateWayConnStrX(gGateWayID As String) As String

        Return setConnStr()

    End Function

    ''' <summary>
    ''' Gets the thesaurus connection string.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getThesaurusConnStr() As String

        Return setThesaurusConnStr()

    End Function

    ''' <summary>
    ''' Setps the w.
    ''' </summary>
    ''' <param name="tVal">The t value.</param>
    Public Sub setpW(ByVal tVal As String)
        CurrUserPW = tVal
    End Sub

    ''' <summary>
    ''' Gets the connection.
    ''' </summary>
    ''' <returns>SqlConnection.</returns>
    Public Function GetConnection() As SqlConnection

        CkConn()
        Return gConn
    End Function

    ''' <summary>
    ''' Gets the SQL adaptor.
    ''' </summary>
    ''' <param name="Sql">The SQL.</param>
    ''' <returns>SqlDataAdapter.</returns>
    Public Function getSqlAdaptor(ByVal Sql As String) As SqlDataAdapter
        CkConn()
        Dim sSelect As String = Sql
        Dim da As New SqlDataAdapter(sSelect, gConn)
        'da.MissingSchemaAction = MissingSchemaAction.AddWithKey
        Dim CMD As New SqlCommandBuilder(da)
        Return da
    End Function

    ''' <summary>
    ''' Cks the connection.
    ''' </summary>
    Public Sub CkConn()
        If gConn Is Nothing Then
            Try
                gConn = New SqlConnection
                gConn.ConnectionString = getRepoConnStr()
                gConn.Open()
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR: clsDatabaseARCH : CkConn : 338 : ", ex)
            End Try
        End If
        If gConn.State = Data.ConnectionState.Closed Then
            Try
                gConn.ConnectionString = getRepoConnStr()
                gConn.Open()
            Catch ex As Exception
                LOG.WriteToArchiveLog("clsDatabaseARCH : CkConn : 348.1 : ", ex)
            End Try
        End If
    End Sub

    ''' <summary>
    ''' Closes the connection.
    ''' </summary>
    Public Sub CloseConn()
        If gConn Is Nothing Then
        Else
            If gConn.State = ConnectionState.Open Then
                gConn.Close()
            End If
            gConn.Dispose()
        End If
        GC.Collect()
    End Sub

    ''' <summary>
    ''' Resets the connection.
    ''' </summary>
    Public Sub ResetConn()
        If gConn Is Nothing Then
            Try
                gConn.ConnectionString = getRepoConnStr()
                gConn.Open()
            Catch ex As Exception
                'WDM Write to log
                LOG.WriteToArchiveLog("clsDatabaseARCH : ResetConn : 378 : ", ex)
            End Try
        Else
            If gConn.State = Data.ConnectionState.Open Then
                gConn.Close()
            End If
            Try
                gConn.ConnectionString = getRepoConnStr()
                gConn.Open()
            Catch ex As Exception
                LOG.WriteToArchiveLog("clsDatabaseARCH : ResetConn : 390 : ", ex)
            End Try
        End If
        If gConn.State = Data.ConnectionState.Closed Then
            Try
                gConn.ConnectionString = getRepoConnStr()
                gConn.Open()
            Catch ex As Exception
                'WDM Write to log
                LOG.WriteToArchiveLog("clsDatabaseARCH : ResetConn : 400 : ", ex)
            End Try
        End If
    End Sub

    ''' <summary>
    ''' is the execute count statement.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iExecCountStmt(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim wc As String = ""

        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open()
                Dim command As New SqlCommand(S, CONN)
                RSData = command.ExecuteReader()

                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            Me.xTrace(30021, "iExecCountStmt", ex.Message.ToString)
            cnt = -1
            LOG.WriteToArchiveLog("clsDatabaseARCH : iExecCountStmt : 100 : ", ex)
        End Try

        Return cnt

    End Function

    ''' <summary>
    ''' is the get row count.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iGetRowCount(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim i As Integer
        Dim cnt As Integer = -1
        Dim wc As String = ""

        i = InStr(S, "order by", CompareMethod.Text)
        If i > 0 Then
            S = Mid(S, 1, i - 1)
        End If
        i = InStr(S, " WHERE", CompareMethod.Text)
        If i > 0 Then
            wc = Mid(S, i)
        End If
        i = InStr(S, "select", CompareMethod.Text)
        If i > 0 Then
            s1 = "Select count(*) as CNT from"
            i = InStr(S, " from", CompareMethod.Text)
            If i > 0 Then
                s2 = Mid(S, i + 5)
                s2 = Trim(s2)
                i = InStr(1, s2, " ")
                If i > 0 Then
                    s2 = Mid(s2, 1, i)
                    s2 = Trim(s2)
                End If
            Else
                Return -1
            End If
        Else
            Return -1
        End If

        S = s1 + " " + s2 + wc
        Try
            Using gConn
                'Console.WriteLine(gConnStr)

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
                RSData = command.ExecuteReader()
                ' Call Read before accessing data.
                RSData.Read()
                cnt = RSData.GetInt32(0)
                'Dim ss As String = ""
                'ss = RSData.GetValue(0).ToString
                'cnt = RSData.Item(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            'WDM Write to log
            Me.xTrace(30021, "iGetRowCount", ex.Message.ToString)
            cnt = -1
            LOG.WriteToArchiveLog("clsDatabaseARCH : iGetRowCount : 449 : ", ex)
        End Try

        Return cnt

    End Function

    ''' <summary>
    ''' is the data exist.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iDataExist(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = 0

        Using gConn
            'Console.WriteLine(gConnStr)

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

            ' Call Read before accessing data.
            RSData.Read()
            cnt = RSData.GetInt32(0)
            'Dim ss As String = ""
            'ss = RSData.GetValue(0).ToString
            'cnt = RSData.Item(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' is the get maximum row NBR from XML.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Public Function iGetMaxRowNbrFromXml() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim S As String = " select max(RowNbr) from InitialLoadData"

        CloseConn()
        CkConn()

        Dim cnt As Integer = 1

        Using gConn
            'Console.WriteLine(gConnStr)

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            ' Call Read before accessing data.
            RSData.Read()
            cnt = RSData.GetInt32(0)
            'Dim ss As String = ""
            'ss = RSData.GetValue(0).ToString
            'cnt = RSData.Item(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the one value.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.String.</returns>
    Public Function getOneVal(ByVal S As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tVal As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            tVal = RSData.GetValue(0).ToString
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return tVal

    End Function

    ''' <summary>
    ''' XCKs the email exists.
    ''' </summary>
    ''' <param name="SenderEmailAddress">The sender email address.</param>
    ''' <param name="ReceivedByName">Name of the received by.</param>
    ''' <param name="ReceivedTime">The received time.</param>
    ''' <param name="SenderName">Name of the sender.</param>
    ''' <param name="SentOn">The sent on.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function xckEmailExists(ByVal SenderEmailAddress As String, ByVal ReceivedByName As String, ByVal ReceivedTime As String, ByVal SenderName As String, ByVal SentOn As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tQuery As String = ""
        Dim S As String = ""

        S = S + " SELECT [SenderEmailAddress]     "
        S = S + " ,[ReceivedByName]"
        S = S + " ,[ReceivedTime]     "
        S = S + " ,[SenderName]"
        S = S + " ,[SentOn]"
        S = S + " FROM  [Email]"
        S = S + " where [UserID] = '" + gCurrUserGuidID + "'"
        S = S + " and [SenderEmailAddress] = 'XXX'"
        S = S + " and [ReceivedByName] = 'XXX'"
        S = S + " and [ReceivedTime] = '2008-01-10 12:22:06.000'"
        S = S + " and [SenderName] = 'XXX'"
        S = S + " and [SentOn] = '2008-01-10 12:19:14.000'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        If cnt > 0 Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Cks the email unique identifier exists.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckEmailGuidExists(ByVal EmailGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " SELECT count(*) from Email where EmailGuid = '" + EmailGuid + "'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Cks the content unique identifier exists.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckContentGuidExists(ByVal SourceGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " SELECT count(*) from DataSource where SourceGuid = '" + SourceGuid + "'"
        CloseConn()
        CkConn()
        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Gets the source datatype by unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getSourceDatatypeByGuid(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " SELECT[SourceTypeCode] from DataSource where SourceGuid = '" + SourceGuid + "'"
        CloseConn()
        CkConn()
        Dim tVal As String = ""
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            tVal = RSData.GetValue(0).ToString
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
            GC.Collect()
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return tVal
    End Function

    ''' <summary>
    ''' Increments the next identifier.
    ''' </summary>
    Public Sub IncrementNextID()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        CloseConn()
        CkConn()
        Dim S As String = "update [NextIdNbr] set IdNbr = IdNbr + 1 "
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
    End Sub

    ''' <summary>
    ''' Sets the folder as active.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="sAction">The s action.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SetFolderAsActive(ByVal FolderName As String, ByVal sAction As String) As Boolean
        Dim SS As String = " "
        SS = "update  [EmailFolder] set [SelectedForArchive] = '" + sAction + "' where FolderName = '" + FolderName + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(SS, False)
        Return b
    End Function

    ''' <summary>
    ''' Gets the next identifier.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Public Function getNextID() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tQuery As String = ""
        Dim S As String = "Select max([IdNbr]) FROM [NextIdNbr] "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            cnt = cnt + 1
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Sets the user default notifications.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    Public Sub SetUserDefaultNotifications(ByVal UserID As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = "INSERT INTO [OwnerNotifications]"
        S = S + " ([OwnerNotificationID]"
        S = S + " ,[NotifyText]"
        S = S + " ,[NotifyType]"
        S = S + " ,[ImportanceLevel]"
        S = S + " ,[CreateDate]"
        S = S + " , [ExpireDate]"
        S = S + " ,[ResponseRequired]"
        S = S + " ,[OwnerNotificationDate]"
        S = S + " ,[EnteredById]"
        S = S + " )"
        S = S + " VALUES "
        S = S + " ('" + UserID + "'"
        S = S + " ,'Please Setup your account'"
        S = S + " ,'O'"
        S = S + " ,'H'"
        S = S + " ,getdate()"
        S = S + " ,getdate() + 360"
        S = S + " ,'Y'"
        S = S + " ,getdate()"
        S = S + " ,'AutoUpdate')"

        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)

    End Sub

    ''' <summary>
    ''' Counts the user entries.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Public Function CountUserEntries() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim S As String = "Select count(*) from UserData "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the global seach count.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getGlobalSeachCnt(ByVal UID As String) As Integer
        Dim tQuery As String = ""
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = "Select count(*) FROM [GlobalSeachResults] where userid = '" + UID + "'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Cks the user information data.
    ''' </summary>
    Public Sub ckUserInfoData()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim S As String = "Select count(*) from UserData where UserID = '" + gCurrUserGuidID + "'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using
        If cnt < 100 Then
            For i As Integer = 100 To 705
                Dim tUid As String = "PP" + Str(i).Trim
                If i = 700 Then
                    tUid = "PPADMIN"
                End If
                If i = 701 Then
                    tUid = "PPDEV"
                End If
                Dim S1 As String = "Select count(*) from UserData where UserID = '" + tUid + "'"
                Dim k As Integer = SelCount(S1)
                If k = 0 Then
                    S1 = "INSERT INTO Userdata"
                    S1 = S1 + " (UserID"
                    S1 = S1 + " ,UserPW"
                    S1 = S1 + " ,ExpireDate"
                    S1 = S1 + " ,UserLevel"
                    S1 = S1 + " ,UserClassification"
                    S1 = S1 + " ,CreateDate"
                    S1 = S1 + " ,UserName"
                    S1 = S1 + " ,UserEmail"
                    S1 = S1 + " ,SecurityQuestion"
                    S1 = S1 + " ,SecurityAnswer"
                    S1 = S1 + " ,EmergencyPhoneNbr)"
                    S1 = S1 + " VALUES "
                    S1 = S1 + " ('" + tUid + "'"

                    If tUid.Equals("PP621") Or tUid.Equals("PPADMIN") Or tUid.Equals("PPDEV") Then
                        S1 = S1 + " ,'junebug'"
                    Else
                        S1 = S1 + " ,'password'"
                    End If
                    S1 = S1 + " ,getdate() + 720"

                    If tUid.Equals("PP621") Or tUid.Equals("PPADMIN") Or tUid.Equals("PPDEV") Then
                        S1 = S1 + " ,'" + "A" + "'"
                    Else
                        S1 = S1 + " ,'" + "U" + "'"
                    End If

                    S1 = S1 + " ,'" + "O" + "'"

                    S1 = S1 + " ,'" + Now.ToString + "'"
                    S1 = S1 + " ,'Owner Name'"
                    S1 = S1 + " ,'" + tUid + ".PassagePoint.org" + "'"
                    S1 = S1 + " ,'" + "You need to set this up." + "'"
                    S1 = S1 + " ,'" + "You need to set this up." + "'"
                    S1 = S1 + " ,'" + "555-555-1212" + "')"
                    Dim b As Boolean = Me.ExecuteSqlNewConn(S1, False)
                    If b Then
                        SetUserDefaultNotifications(tUid)
                    End If
                End If
            Next
        End If
    End Sub

    ''' <summary>
    ''' Sels the count.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function SelCount(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Cks the admin user.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="PW">The pw.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckAdminUser(ByVal Userid As String, ByVal PW As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select userid from dco.<SchemaName>.admin_user where userid = '" + Userid + "' and password = '" + PW + "'"
        S = "Select userid from ADMIN_USER where userid = '" + Userid + "' and password = '" + PW + "'"
        Dim i As Integer = 0

        Dim rsData As SqlDataReader

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            b = True
        Else
            b = False
        End If
        rsData.Close()
        rsData = Nothing
        Return b
    End Function

    ''' <summary>
    ''' Gets the admin user identifier.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="PW">The pw.</param>
    ''' <returns>System.String.</returns>
    Public Function getAdminUserId(ByVal Userid As String, ByVal PW As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select useridnbr from admin_user where userid = '" + Userid + "' and password = '" + PW + "'"
        S = "Select useridnbr from ADMIN_USER where userid = '" + Userid + "' and password = '" + PW + "'"
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the name of the document cat identifier by.
    ''' </summary>
    ''' <param name="CatName">Name of the cat.</param>
    ''' <returns>System.String.</returns>
    Public Function getDocCatIdByName(ByVal CatName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select CategoryID  FROM DocumentCategories  where CategoryName = '" + CatName + "' "
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the user name by identifier.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <returns>System.String.</returns>
    Public Function getUserNameByID(ByVal Userid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select UserName FROM Users where UserID = '" + Userid + "' "
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the user login by userid.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <returns>System.String.</returns>
    Public Function getUserLoginByUserid(ByVal Userid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select UserLoginID FROM Users where UserID = '" + Userid + "' "
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Adds the profile file types.
    ''' </summary>
    ''' <param name="ProfileName">Name of the profile.</param>
    ''' <param name="LB">The lb.</param>
    Public Sub AddProfileFileTypes(ByVal ProfileName As String, ByVal LB As ListBox)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rsData As SqlDataReader = Nothing
        Try
            Dim b As Boolean = True
            Dim S As String = "Select [SourceTypeCode] FROM  [LoadProfileItem] where ProfileName = '" + ProfileName + "' order by [SourceTypeCode]"
            Dim i As Integer = 0
            Dim FileType As String = ""
            Dim II As Integer = 0
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    b = True
                    FileType = rsData.GetValue(0).ToString
                    For II = 0 To LB.Items.Count - 1
                        Dim tStr As String = LB.Items(II).ToString
                        If tStr = FileType Then
                            b = False
                            Exit For
                        End If
                    Next
                    If b = True Then
                        LB.Items.Add(FileType)
                    End If
                Loop
            End If
        Catch ex As Exception
            'WDM Write to log
            LOG.WriteToArchiveLog("clsDatabaseARCH : AddProfileFileTypes : 816 : ", ex)
        End Try

        rsData.Close()
        rsData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the skip words.
    ''' </summary>
    ''' <param name="A">a.</param>
    Public Sub GetSkipWords(ByRef A As ArrayList)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rsData As SqlDataReader = Nothing
        Try
            Dim b As Boolean = True
            Dim S As String = "Select [tgtWord] FROM [SkipWords] order by [tgtWord]"
            Dim i As Integer = 0
            Dim SkipWord As String = ""
            Dim II As Integer = 0
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    b = True
                    SkipWord = rsData.GetValue(0).ToString.ToUpper
                    A.Add(SkipWord)
                Loop
            End If
        Catch ex As Exception
            'WDM Write to log
            Me.xTrace(300277, "GetSkipWords", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetSkipWords : 100 : ", ex)
        End Try

        rsData.Close()
        rsData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the device identifier.
    ''' </summary>
    ''' <param name="InventoryNo">The inventory no.</param>
    ''' <returns>System.String.</returns>
    Public Function getDeviceID(ByVal InventoryNo As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select DEVICEID FROM INVENTORY WHERE INVENTORYNO = " + InventoryNo
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the photo title.
    ''' </summary>
    ''' <param name="PhotoID">The photo identifier.</param>
    ''' <param name="pTitle">The p title.</param>
    ''' <returns>System.String.</returns>
    Public Function getPhotoTitle(ByRef PhotoID As Integer, ByRef pTitle As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select Caption, PhotoID from photos "
        Dim i As Integer = 0
        Dim tempTitle As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            Do While rsData.Read
                If i = PhotoID Then
                    PhotoID = rsData.GetInt32(1)
                    pTitle = rsData.GetValue(0).ToString
                    Exit Do
                End If
                i = i + 1
            Loop
            tempTitle = pTitle
        Else
            tempTitle = "No Photo Found"
        End If
        rsData.Close()
        rsData = Nothing
        Return tempTitle
    End Function

    ''' <summary>
    ''' Gets the photo title.
    ''' </summary>
    ''' <param name="PhotoID">The photo identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getPhotoTitle(ByRef PhotoID As Integer) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim S As String = "Select Caption from photos where PhotoID = " & PhotoID
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(1).ToString
        Else
            id = "No Photo Found"
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the contact identifier.
    ''' </summary>
    ''' <param name="FirstName">The first name.</param>
    ''' <param name="LastName">The last name.</param>
    ''' <returns>System.String.</returns>
    Public Function getContactID(ByVal FirstName As String, ByVal LastName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim SS As String = "Select ContactID FROM Contacts "
        SS = SS + " where NameFirst = '" + FirstName + "' "
        SS = SS + " 	and NameLast = '" + LastName + "'"

        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(SS, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Records the exists.
    ''' </summary>
    ''' <param name="Tbl">The table.</param>
    ''' <param name="WhereVar">The where variable.</param>
    ''' <param name="CompareVal">The compare value.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function RecordExists(ByVal Tbl As String, ByVal WhereVar As String, ByVal CompareVal As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim SQL As String = "Select * from " + Tbl + " where " + WhereVar + " = '" + CompareVal + "'"
        Dim i As Integer = 0

        i = iGetRowCount(SQL)
        If i = 0 Then
            b = False
        End If
        Return b
    End Function

    ''' <summary>
    ''' Gets the next key.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="tCol">The t col.</param>
    ''' <returns>System.String.</returns>
    Public Function getNextKey(ByVal TBL As String, ByVal tCol As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        CloseConn()
        CkConn()
        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim S As String = "Select max(" + tCol + ") + 1 from " + TBL
        Dim d As String = ""

        'Dim cnt As Double = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Try
            'rsData = SqlQry(sql, rsData)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            d = rsData.GetValue(0).ToString
            If Len(d) = 0 Then
                d = "0"
            End If
            'Dim ss As String = ""
            'ss = rsData.GetValue(0).ToString
            'cnt = rsData.Item(0)
            rsData.Close()
            'End Using
        Catch ex As Exception
            'WDM Write to log
            ' xTrace(1010177, "getNextKey", ex.Message.ToString + " : " + "Error 99.23.1x - " + S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getNextKey : 908 : ", ex)
        End Try

        Return d
    End Function

    ''' <summary>
    ''' Gets the next key.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="tCol">The t col.</param>
    ''' <param name="SQL">The SQL.</param>
    ''' <returns>System.String.</returns>
    Public Function getNextKey(ByVal TBL As String, ByVal tCol As String, ByVal SQL As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        'Dim sql As String = "Select max(" + tCol + ") + 1 from " + TBL
        Dim d As String = ""

        'Dim cnt As Double = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False

        b = SqlQry(SQL, rsData)

        rsData.Read()
        d = rsData.GetValue(0).ToString

        rsData.Close()

        Return d
    End Function

    ''' <summary>
    ''' Gets the key by lookup col.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="kCol">The k col.</param>
    ''' <param name="tCol">The t col.</param>
    ''' <param name="LookUpVal">The look up value.</param>
    ''' <returns>System.String.</returns>
    Public Function getKeyByLookupCol(ByVal TBL As String, ByVal kCol As String, ByVal tCol As String, ByVal LookUpVal As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim sql As String = "Select " + kCol + " from " + TBL + " where " + tCol + " = '" + LookUpVal + "'"
        Dim d As String = ""

        'Dim cnt As Double = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False

        b = SqlQry(sql, rsData)

        If rsData.HasRows Then
            rsData.Read()
            d = rsData.GetValue(0).ToString
        Else
            d = ""
        End If
        rsData.Close()
        'End Using
        Return d
    End Function

    ''' <summary>
    ''' Gets the key by lookup col.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="kCol">The k col.</param>
    ''' <param name="tCol">The t col.</param>
    ''' <param name="LookUpVal">The look up value.</param>
    ''' <returns>System.String.</returns>
    Public Function getKeyByLookupCol(ByVal TBL As String, ByVal kCol As String, ByVal tCol As String, ByVal LookUpVal As Integer) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim tQuery As String = ""
        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim s3 As String = ""
        Dim sql As String = "Select " + kCol + " from " + TBL + " where " + tCol + " = " + LookUpVal.ToString
        Dim d As String = ""

        'Dim cnt As Double = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        b = SqlQry(sql, rsData)
        If rsData.HasRows Then
            rsData.Read()
            d = rsData.GetValue(0).ToString
        Else
            d = ""
        End If
        rsData.Close()
        'End Using
        Return d
    End Function

    ''' <summary>
    ''' Validates the user by uid.
    ''' </summary>
    ''' <param name="uid">The uid.</param>
    ''' <param name="upw">The upw.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ValidateUserByUid(ByVal uid As String, ByVal upw As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = "Select count(*) as CNT from Users where UserID = '" + uid + "' and UserPassword = '" + upw + "'"
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()
            Try
                RSData.Read()
                i = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateUserByUid : 965 : ", ex)
            End Try

        End Using
        Return i
    End Function

    ''' <summary>
    ''' Validates the content ownership.
    ''' </summary>
    ''' <param name="tgtGuid">The TGT unique identifier.</param>
    ''' <param name="contentTypeCode">The content type code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ValidateContentOwnership(ByVal tgtGuid As String, ByVal contentTypeCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        Dim uid As String = gCurrUserGuidID

        If contentTypeCode.ToUpper.Equals(".MSG") Then
            S = "Select count(*) as CNT from EMAIL where Emailguid = '" + tgtGuid + "' and UserID = '" + uid + "' "
        Else
            S = "Select count(*) as CNT from DataSource where SourceGuid = '" + tgtGuid + "' and DataSourceOwnerUserID = '" + uid + "' "
        End If

        Dim isOwner As Boolean = False
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            Try
                ' Call Read before accessing data.
                RSData.Read()
                i = RSData.GetInt32(0)
                'Dim ss As String = ""
                'ss = RSData.GetValue(0).ToString
                'cnt = RSData.Item(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                If i > 0 Then
                    isOwner = True
                Else
                    isOwner = False
                End If
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateContentOwnership : 100 : ", ex)
                isOwner = False
            End Try

        End Using
        Return isOwner
    End Function

    ''' <summary>
    ''' Validates the co owner.
    ''' </summary>
    ''' <param name="OwnerGuid">The owner unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ValidateCoOwner(ByVal OwnerGuid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = "Select count(*) from CoOwner where PreviousOwnerUserID = '" + OwnerGuid + "' and CurrentOwnerUserID = '" + gCurrUserGuidID + "'"
        Dim uid As String = gCurrUserGuidID

        'If contentTypeCode.ToUpper.Equals(".MSG") Then
        '    S = "Select count(*) as from EMAIL where Emailguid = '" + tgtGuid  + "' and UserID = '" + uid + "' "
        'Else
        '    S = "Select count(*) as from DataSource where SourceGuid = '" + tgtGuid  + "' and DataSourceOwnerUserID = '" + uid + "' "
        'End If

        Dim isCoOwner As Boolean = False
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            Try
                ' Call Read before accessing data.
                RSData.Read()
                i = RSData.GetInt32(0)
                'Dim ss As String = ""
                'ss = RSData.GetValue(0).ToString
                'cnt = RSData.Item(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                If i > 0 Then
                    isCoOwner = True
                Else
                    isCoOwner = False
                End If
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateContentOwnership : 100 : ", ex)
                isCoOwner = False
            End Try

        End Using
        Return isCoOwner
    End Function

    ''' <summary>
    ''' Validates the content of the co owner of.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="ContentType">Type of the content.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ValidateCoOwnerOfContent(ByVal ContentGuid As String, ByVal ContentType As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim OwnerGuid As String = getContentOwnerGuid(ContentGuid, ContentType)

        If OwnerGuid.Trim.Length = 0 Then
            Return False
        End If

        Dim S As String = "Select count(*) from CoOwner where PreviousOwnerUserID = '" + OwnerGuid + "' and CurrentOwnerUserID = '" + gCurrUserGuidID + "'"
        Dim uid As String = gCurrUserGuidID

        Dim isCoOwner As Boolean = False
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            Try
                ' Call Read before accessing data.
                RSData.Read()
                i = RSData.GetInt32(0)
                'Dim ss As String = ""
                'ss = RSData.GetValue(0).ToString
                'cnt = RSData.Item(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                If i > 0 Then
                    isCoOwner = True
                Else
                    isCoOwner = False
                End If
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateContentOwnership : 100 : ", ex)
                isCoOwner = False
            End Try

        End Using
        Return isCoOwner
    End Function

    ''' <summary>
    ''' Gets the content owner unique identifier.
    ''' </summary>
    ''' <param name="tgtGuid">The TGT unique identifier.</param>
    ''' <param name="contentTypeCode">The content type code.</param>
    ''' <returns>System.String.</returns>
    Public Function getContentOwnerGuid(ByVal tgtGuid As String, ByVal contentTypeCode As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        Dim OwnerGuid As String = ""

        If contentTypeCode.ToUpper.Equals(".MSG") Then
            S = "Select Userid from EMAIL where Emailguid = '" + tgtGuid + "'"
        Else
            S = "Select DataSourceOwnerUserID from DataSource where SourceGuid = '" + tgtGuid + "' "
        End If

        Dim isOwner As Boolean = False
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            Try
                ' Call Read before accessing data.
                If RSData.HasRows Then
                    RSData.Read()
                    OwnerGuid = RSData.GetValue(0).ToString
                    RSData.Close()
                    RSData = Nothing
                    command.Connection.Close()
                    command = Nothing
                Else
                    OwnerGuid = ""
                End If
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateContentOwnership : 100 : ", ex)
            End Try
        End Using
        Return OwnerGuid
    End Function

    ''' <summary>
    ''' Validates the user identifier.
    ''' </summary>
    ''' <param name="uid">The uid.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ValidateUserId(ByVal uid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = "Select count(*) as CNT from Userdata where UserID = '" + uid + "'"
        Dim i As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            Try
                ' Call Read before accessing data.
                RSData.Read()
                i = RSData.GetInt32(0)
                'Dim ss As String = ""
                'ss = RSData.GetValue(0).ToString
                'cnt = RSData.Item(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            Catch ex As Exception
                'WDM Write to log
                i = 0
                LOG.WriteToArchiveLog("clsDatabaseARCH : ValidateUserId : 980 : ", ex)
            End Try

        End Using
        Return i
    End Function

    ''' <summary>
    ''' Gets the authority.
    ''' </summary>
    ''' <param name="uid">The uid.</param>
    ''' <returns>System.String.</returns>
    Public Function getAuthority(ByVal uid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If uid = Nothing Then
            '"Error","User id has not been set...")
            Return ""
        End If
        Dim S As String = ""
        S = S + " Select Admin "
        S = S + " FROM Users "
        S = S + " where UserID = '" + uid + "'"
        Dim Auth As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        rsData = command.ExecuteReader()

        rsData.Read()
        Auth = rsData.GetValue(0).ToString
        rsData.Close()
        rsData = Nothing

        Dim AuthDesc As String = "User"
        If Auth.ToUpper.Equals("A") Then
            AuthDesc = "Admin"
        End If
        If Auth.ToUpper.Equals("G") Then
            AuthDesc = "Global Searcher"
        End If
        If Auth.ToUpper.Equals("S") Then
            AuthDesc = "Super Admin"
        End If

        Return AuthDesc

    End Function

    ''' <summary>
    ''' Gets the photo ext.
    ''' </summary>
    ''' <param name="pid">The pid.</param>
    ''' <returns>System.String.</returns>
    Public Function getPhotoExt(ByVal pid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If pid = Nothing Then
            '"Error","User id has not been set...")
            Return ""
        End If
        Dim S As String = ""
        S = S + " Select [PhotoFqn]"
        S = S + " FROM Photos "
        S = S + " where PhotoID = '" + pid + "'"
        Dim Auth As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        rsData.Read()
        Auth = rsData.GetValue(0).ToString
        rsData.Close()
        rsData = Nothing

        Return Auth

    End Function

    ''' <summary>
    ''' Gets the type of the photo img.
    ''' </summary>
    ''' <param name="pid">The pid.</param>
    ''' <returns>System.String.</returns>
    Public Function getPhotoImgType(ByVal pid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If pid = Nothing Then
            '"Error","User id has not been set...")
            Return ""
        End If
        Dim S As String = ""
        S = S + " Select ImgType "
        S = S + " FROM Photos "
        S = S + " where PhotoID = '" + pid + "'"
        Dim Auth As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        rsData.Read()
        Auth = rsData.GetValue(0).ToString
        rsData.Close()
        rsData = Nothing

        Return Auth

    End Function

    ''' <summary>
    ''' Gets the type of the user.
    ''' </summary>
    ''' <param name="uid">The uid.</param>
    ''' <returns>System.String.</returns>
    Public Function getUserType(ByVal uid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " Select [UserID]"
        S = S + " ,[UserPW]"
        S = S + " ,[ExpireDate]"
        S = S + " ,[UserLevel]"
        S = S + " ,[UserNbr]"
        S = S + " ,[UserClassification]"
        S = S + " ,[CreateDate]"
        S = S + " FROM Userdata"
        S = S + " where UserID = '" + uid + "'"
        Dim Auth As String = ""
        Dim queryString As String = S

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        rsData.Read()
        Auth = rsData.GetValue(5).ToString
        rsData.Close()
        rsData = Nothing

        Return Auth.Trim

    End Function

    ''' <summary>
    ''' Gets the source CRC.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceType">Type of the source.</param>
    ''' <returns>System.String.</returns>
    Public Function getSourceCrc(ByVal SourceGuid As String, ByVal SourceType As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Try
            Dim S As String = ""
            If SourceType.Equals("EMAIL") Then
                S = "Select CRC from email where EmailGuid = '" + SourceGuid + "'"
            Else
                S = "Select AttributeValue from SourceAttribute where SourceGuid = '" + SourceGuid + "' AND AttributeName = 'CRC'"
            End If
            Dim CRC As String = ""
            Dim queryString As String = S
            CloseConn()
            CkConn()
            Dim cnt As Integer = -1
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            CRC = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
            Return CRC.Trim
        Catch ex As Exception
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Gets the source image hash.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceType">Type of the source.</param>
    ''' <returns>System.String.</returns>
    Public Function getSourceImageHash(ByVal SourceGuid As String, ByVal SourceType As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Try
            Dim ImageHash As String = ""
            Dim S As String = ""
            If SourceType.Equals("EMAIL") Then
                S = "Select ImageHash from email where EmailGuid = '" + SourceGuid + "'"
            Else
                S = "Select ImageHash from DataSource where SourceGuid = '" + SourceGuid + "'"
            End If
            Dim CRC As String = ""
            Dim queryString As String = S
            CloseConn()
            CkConn()
            Dim cnt As Integer = -1
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            ImageHash = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
            Return ImageHash.Trim
        Catch ex As Exception
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Gets the length of the source.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceType">Type of the source.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getSourceLength(ByVal SourceGuid As String, ByVal SourceType As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Try
            Dim S As String = ""
            If SourceType.Equals("EMAIL") Then
                S = "Select MsgSize from Email where EmailGuid = '" + SourceGuid + "'"
            Else
                S = "Select FileLength from DataSource where SourceGuid = '" + SourceGuid + "'"
            End If
            Dim FLEN As Integer = 0
            Dim queryString As String = S
            CloseConn()
            CkConn()
            Dim cnt As Integer = -1
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            FLEN = rsData.GetInt32(0)
            rsData.Close()
            rsData = Nothing
            Return FLEN
        Catch ex As Exception
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' SQLs the qry.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="rsData">The rs data.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SqlQry(ByVal sql As String, ByRef rsData As SqlDataReader) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If ddebug Then
            LOG.WriteToArchiveLog("____________________________________________")
            LOG.WriteToArchiveLog("Started: " + Now.ToString)
            LOG.WriteToArchiveLog(sql)

            Console.WriteLine("____________________________________________")
            Console.WriteLine("Started: " + Now.ToString)
            Console.WriteLine(sql)
        End If

        Dim CMDX As New SqlCommand

        Dim queryString As String = sql
        Dim rc As Boolean = False

        rsData = Nothing

        If gConn.State = Data.ConnectionState.Open Then
            gConn.Close()
        End If

        CloseConn()
        CkConn()

        If ddebug Then Console.WriteLine("SQLQRY Started: " + Now.ToString)
        If ddebug Then LOG.WriteToArchiveLog("SQLQRY Started: " + Now.ToString)

        Try
            'Dim CMDX As New SqlCommand(sql, gConn)
            CMDX.Connection = gConn
            CMDX.ExecuteReader()

            rsData = CMDX.ExecuteReader()
            CMDX.Dispose()
            CMDX = Nothing
            Return True
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQry : 1085 : ", ex)
            Return False
        End Try
    End Function

    ''' <summary>
    ''' Creates new id.
    ''' </summary>
    ''' <param name="Tbl">The table.</param>
    ''' <param name="idCol">The identifier col.</param>
    ''' <returns>System.Int32.</returns>
    Public Function NewID(ByVal Tbl As String, ByVal idCol As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select max(" + idCol + ")+1 from " + Tbl
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As Integer = rsData.GetInt32(0)
            rsData.Close()
            rsData = Nothing
            Return CInt(iStr)
        Else
            rsData.Close()
            rsData = Nothing
            Return 0
        End If

    End Function

    ''' <summary>
    ''' Gets the maximum photo identifier.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getMaxPhotoID() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select max(photoid) from photos "
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As String = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
            Return iStr
        Else
            rsData.Close()
            rsData = Nothing
            Return "0"
        End If

    End Function

    ''' <summary>
    ''' Gets the photo identifier bycaption.
    ''' </summary>
    ''' <param name="Caption">The caption.</param>
    ''' <returns>System.String.</returns>
    Public Function getPhotoIDBycaption(ByVal Caption As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select photoid from photos where caption = '" + Caption + "'"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As String = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
            Return iStr
        Else
            rsData.Close()
            rsData = Nothing
            Return "0"
        End If

    End Function

    ''' <summary>
    ''' Gets the user pw.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.String.</returns>
    Public Function getUserPW(ByVal UID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select UserPW from userdata where userid = '" + UID + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            rsData.Close()
            rsData = Nothing
        End If
        Return iStr.Trim
    End Function

    ''' <summary>
    ''' Gets the FQN from unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="TgtTbl">The TGT table.</param>
    ''' <returns>System.String.</returns>
    Public Function getFqnFromGuid(ByVal SourceGuid As String, Optional TgtTbl As String = "DataSource") As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        If TgtTbl.ToUpper.Equals("DATASOURCE") Then
            s = "Select FQN FROM DataSource Where SourceGuid = '" + SourceGuid + "'"
        Else
            s = "Select AttachmentName FROM EmailAttachment Where RowGuid = '" + SourceGuid + "'"
        End If

        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(s, CONN)
        rsData = command.ExecuteReader()

        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            'rsData = Nothing
        Else
            rsData.Close()
            'rsData = Nothing
        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()

        Return iStr.Trim
    End Function

    ''' <summary>
    ''' Gets the filename by unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getFilenameByGuid(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select SourceName FROM DataSource Where SourceGuid = '" + SourceGuid + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            rsData.Close()
            rsData = Nothing
        End If
        Return iStr.Trim
    End Function

    ''' <summary>
    ''' Gets the user unique identifier identifier.
    ''' </summary>
    ''' <param name="UserLoginId">The user login identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getUserGuidID(ByVal UserLoginId As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        'MessageBox.Show("getUserGuidID 1: " + UserLoginId)
        Dim s As String = ""
        s = "Select [UserID] FROM  [Users] Where UserLoginID = '" + UserLoginId + "'"
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim rsData As SqlDataReader = Nothing
        'MessageBox.Show("getUserGuidID 2")
        Try
            'MessageBox.Show("getUserGuidID 3 gGateWayID: " + gGateWayID.ToString)
            Dim CS As String = getRepoConnStr()
            'MessageBox.Show("getUserGuidID 4: " + CS)
            Dim CONN As New SqlConnection(CS)
            'MessageBox.Show("getUserGuidID 5")
            CONN.Open()
            'MessageBox.Show("getUserGuidID 6: " + s)
            Dim command As New SqlCommand(s, CONN)
            'MessageBox.Show("getUserGuidID 7")
            rsData = command.ExecuteReader()
            'MessageBox.Show("getUserGuidID 8")
            If rsData.HasRows Then
                'MessageBox.Show("getUserGuidID 9")
                rsData.Read()
                iStr = rsData.GetValue(0).ToString
                rsData.Close()
                rsData = Nothing
            Else
                'MessageBox.Show("getUserGuidID 10")
                rsData.Close()
                rsData = Nothing
            End If
            'MessageBox.Show("getUserGuidID 11")
        Catch ex As Exception
            'MessageBox.Show("Could not attach to the server with the current loginid of: " + UserLoginId + " - continuing.")
        End Try
        'MessageBox.Show("getUserGuidID 12: " + iStr.Trim)
        Return iStr.Trim
    End Function

    ''' <summary>
    ''' Gets the quick reference identifier NBR.
    ''' </summary>
    ''' <param name="QuickRefName">Name of the quick reference.</param>
    ''' <param name="UserGuidID">The user unique identifier identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getQuickRefIdNbr(ByVal QuickRefName As String, ByVal UserGuidID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select  [QuickRefIdNbr] FROM [QuickRef] where QuickRefName = '" + QuickRefName + "' and UserID = '" + UserGuidID + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            iStr = "-1"
            rsData.Close()
            rsData = Nothing
        End If
        Return iStr.Trim
    End Function

    ''' <summary>
    ''' Gets the next document identifier.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getNextDocID() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select max (DocumentID) FROM [Documents]"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            rsData.Close()
            rsData = Nothing
        End If
        Return iStr.Trim

    End Function

    ''' <summary>
    ''' Gets the document identifier by FQN.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>System.String.</returns>
    Public Function getDocIdByFqn(ByVal FQN As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim s As String = ""
        s = "Select DocumentID FROM [Documents] where DocFqn = '" + FQN + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            rsData.Close()
            rsData = Nothing
        End If
        Return iStr.Trim

    End Function

    ''' <summary>
    ''' Cks the document exist by FQN.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckDocExistByFqn(ByVal FQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim s As String = ""
        s = "Select DocumentID FROM [Documents] where DocFqn = '" + FQN + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim B As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Close()
            rsData = Nothing
            B = True
        Else
            rsData.Close()
            rsData = Nothing
            B = False
        End If
        Return B

    End Function

    ''' <summary>
    ''' Executes the count SQL.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ExecCountSQL(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim I As Integer = 0
        Try
            Dim rsData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                Dim iStr As String = rsData.GetValue(0).ToString
                I = CInt(iStr)
                rsData.Close()
                rsData = Nothing
            Else
                rsData.Close()
                rsData = Nothing
                I = 0
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecCountSQL : 0001 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecCountSQL : 0001a : " + S)
            I = -1
        End Try
        Return I
    End Function

    ''' <summary>
    ''' Verifies the user identifier.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function VerifyUserID(ByVal UID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        s = "Select count(*) from Userdata where Userid = '" + UID + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As String = rsData.GetValue(0).ToString
            I = CInt(iStr)
            rsData.Close()
            rsData = Nothing
            If I > 0 Then
                Return True
            Else
                Return False
            End If
        Else
            rsData.Close()
            rsData = Nothing
            Return False
        End If

    End Function

    ''' <summary>
    ''' Items the exists.
    ''' </summary>
    ''' <param name="Tbl">The table.</param>
    ''' <param name="idCol">The identifier col.</param>
    ''' <param name="ColVal">The col value.</param>
    ''' <param name="ColType">Type of the col.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ItemExists(ByVal Tbl As String, ByVal idCol As String, ByVal ColVal As String, ByVal ColType As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        Dim b As Boolean = False
        CloseConn()
        CkConn()
        If ColType = "N" Then
            s = "Select count(*) from " + Tbl + " where " + idCol + " = " + ColVal
        Else
            s = "Select count(*) from " + Tbl + " where " + idCol + " = '" + ColVal + "'"
        End If

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As Integer = rsData.GetInt32(0)
            If CInt(iStr) > 0 Then
                b = True
            Else
                b = False
            End If
        Else
            Return b
        End If
        rsData.Close()
        rsData = Nothing
        Return b
    End Function

    ''' <summary>
    ''' Validates the device identifier.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ValidateDeviceID(ByVal ID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim s As String = ""
        If ID.Length = 0 Then
            Return False
        End If
        Dim b As Boolean = False
        s = "Select count(*) from Devices where deviceid = " + ID

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            Dim iStr As Integer = rsData.GetInt32(0)
            If CInt(iStr) > 0 Then
                b = True
            Else
                b = False
            End If
        Else
            Return b
        End If
        rsData.Close()
        rsData = Nothing
        Return b
    End Function

    ''' <summary>
    ''' Xxes the SQL qry.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function xxSqlQry(ByVal sql As String) As SqlDataReader
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        SyncLock Me
            Dim rsDataQry As SqlDataReader = Nothing
            Try
                ''Session("ActiveError") = False
                Dim ddebug As Boolean = True
                Dim queryString As String = sql
                Dim rc As Boolean = False

                CloseConn()
                CkConn()

                If gConn.State = Data.ConnectionState.Open Then
                    gConn.Close()
                End If

                CloseConn()
                CkConn()

                Dim command As New SqlCommand(sql, gConn)

                Try
                    rsDataQry = command.ExecuteReader()
                Catch ex As Exception
                    LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQry : 1319 : ", ex)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQry : 1319 Server too Busy : " + environment.NewLine + sql)
                End Try

                command.Dispose()
                command = Nothing
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR: SqlQry 100 - Server too busy: ", ex)
            End Try
            Return rsDataQry
        End SyncLock
    End Function

    ''' <summary>
    ''' SQLs the qry new thread.
    ''' </summary>
    ''' <param name="tSql">The t SQL.</param>
    ''' <param name="tConn">The t connection.</param>
    ''' <param name="rsDataQry">The rs data qry.</param>
    Public Sub SqlQryNewThread(ByVal tSql As String, ByRef tConn As SqlConnection, ByRef rsDataQry As SqlDataReader)

        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim rc As Boolean = False

        'SyncLock Me
        'Dim tConn As New SqlConnection
        Dim CS As String = getRepoConnStr()
        Dim xConn As New SqlConnection(CS)
        xConn.Open()

        Dim command As New SqlCommand(tSql, xConn)

        Try
            rsDataQry = command.ExecuteReader()
        Catch ex As Exception
            ' xTrace(10081, "clsDataBase:SqlQry" + ex.Message)
            ' xTrace(10092, "clsDataBase:SqlQry", ex.StackTrace)
            ' xTrace(10033, "clsDataBase:SqlQry", tSql)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryNewThread : 1337 : ", ex)
        End Try

        command.Dispose()
        command = Nothing

        'End SyncLock

    End Sub

    ''' <summary>
    ''' SQLs the qry.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="Conn">The connection.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function SqlQry(ByVal sql As String, ByVal Conn As SqlConnection) As SqlDataReader
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        ''Session("ActiveError") = False
        Dim ddebug As Boolean = False
        Dim queryString As String = sql
        Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing

        If Conn.State <> Data.ConnectionState.Open Then
            Conn.Open()
        End If

        Dim command As New SqlCommand(sql, Conn)

        Try
            rsDataQry = command.ExecuteReader()
        Catch ex As Exception
            ''Session("ActiveError") = True
            ''Session("ErrMsg") = ex.Message
            ''Session("ErrStack") = ex.StackTrace + environment.NewLine + environment.NewLine + sql
            ' xTrace(18001, "clsDataBase:SqlQry" + ex.Message)
            ' xTrace(19002, "clsDataBase:SqlQry", ex.StackTrace)
            ' xTrace(13003, "clsDataBase:SqlQry", sql)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQry : 1352 : ", ex)
        End Try

        'If ddebug Then log.WriteToArchiveLog("SQLQRY Ended: " + Now.tostring)
        'If ddebug Then Console.WriteLine("SQLQRY Ended: " + Now.tostring)

        command.Dispose()
        command = Nothing

        Return rsDataQry
    End Function

    ''' <summary>
    ''' SQLs the qry new connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function SqlQryNewConn(ByVal sql As String) As SqlDataReader
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        ''Session("ActiveError") = False
        Dim ddebug As Boolean = False
        Dim queryString As String = sql
        Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing

        Dim CN As New SqlConnection(getRepoConnStr())

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim command As New SqlCommand(sql, CN)

        Try
            rsDataQry = command.ExecuteReader()
        Catch ex As Exception
            ''Session("ActiveError") = True
            ''Session("ErrMsg") = ex.Message
            ''Session("ErrStack") = ex.StackTrace + environment.NewLine + environment.NewLine + sql
            ' xTrace(10301, "clsDataBase:SqlQry" + ex.Message)
            ' xTrace(10042, "clsDataBase:SqlQry", ex.StackTrace)
            ' xTrace(10035, "clsDataBase:SqlQry", sql)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryNewConn : 1368a : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryNewConn : 1368b : " + sql)
        End Try

        'If ddebug Then log.WriteToArchiveLog("SQLQRY Ended: " + Now.tostring)
        'If ddebug Then Console.WriteLine("SQLQRY Ended: " + Now.tostring)

        command.Dispose()
        command = Nothing

        Return rsDataQry
    End Function

    ''' <summary>
    ''' Updates the remote machine.
    ''' </summary>
    ''' <param name="CompanyID">The company identifier.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="Applied">The applied.</param>
    ''' <param name="LicenseID">The license identifier.</param>
    Public Sub UpdateRemoteMachine(ByVal CompanyID As String, ByVal MachineID As String, ByVal Applied As String, ByVal LicenseID As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim RemoteConnStr As String = ""

        CompanyID = UTIL.RemoveSingleQuotes(CompanyID)
        MachineID = UTIL.RemoveSingleQuotes(MachineID)

        RemoteConnStr = System.Configuration.ConfigurationManager.AppSettings("HELP.DBARCH")
        RemoteConnStr = ENC.AES256DecryptString(RemoteConnStr)

        Dim CN As New SqlConnection(RemoteConnStr)

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim QrySql As String = "UPDATE [License] SET [MachineID] = '" + MachineID + "' ,[Applied] = " + Applied + " WHERE CompanyID = '" + CompanyID + "' and LicenseID = " + LicenseID

        Dim command As New SqlCommand(QrySql, CN)
        Dim iRows As Integer = command.ExecuteNonQuery

        If iRows = 0 Then
            LOG.WriteToArchiveLog("ERROR 132.34.1 - Failed to udpate remote Machine ID.")
        End If

        'UPDATE [License] SET [MachineID] = 'XX' ,[Applied] = 1 WHERE CompanyID = 'XX' and LicenseID = 0
    End Sub

    ''' <summary>
    ''' SQLs the qry remote connection.
    ''' </summary>
    ''' <param name="QrySql">The qry SQL.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function SqlQryRemoteConn(ByVal QrySql As String) As SqlDataReader
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ''Session("ActiveError") = False
        Dim ddebug As Boolean = False
        Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing
        Dim RemoteConnStr As String = ""

        RemoteConnStr = System.Configuration.ConfigurationManager.AppSettings("HELP.DBARCH")
        RemoteConnStr = ENC.AES256DecryptString(RemoteConnStr)

        Dim CN As New SqlConnection(RemoteConnStr)

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim command As New SqlCommand(QrySql, CN)

        Try
            rsDataQry = command.ExecuteReader()
        Catch ex As Exception
            ''Session("ActiveError") = True
            ''Session("ErrMsg") = ex.Message
            ''Session("ErrStack") = ex.StackTrace + environment.NewLine + environment.NewLine + sql
            ' xTrace(104501, "clsDataBase:SqlQryRemoteConn" + ex.Message)
            ' xTrace(106502, "clsDataBase:SqlQryRemoteConn", ex.StackTrace)
            ' xTrace(107503, "clsDataBase:SqlQryRemoteConn", QrySql)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryRemoteConn : 1368 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryRemoteConn : 1368a : " + QrySql)
        End Try

        'If ddebug Then log.WriteToArchiveLog("SQLQRY Ended: " + Now.tostring)
        'If ddebug Then Console.WriteLine("SQLQRY Ended: " + Now.tostring)

        command.Dispose()
        command = Nothing

        Return rsDataQry
    End Function

    ''' <summary>
    ''' SQLs the qry new connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="ConnectionString">The connection string.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function SqlQryNewConn(ByVal sql As String, ByVal ConnectionString As String) As SqlDataReader

        ''Session("ActiveError") = False
        Dim ddebug As Boolean = False
        Dim queryString As String = sql
        Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing

        Dim CN As New SqlConnection(ConnectionString)

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim command As New SqlCommand(sql, CN)

        Try
            rsDataQry = command.ExecuteReader()
        Catch ex As Exception
            ''Session("ActiveError") = True
            ''Session("ErrMsg") = ex.Message
            ''Session("ErrStack") = ex.StackTrace + environment.NewLine + environment.NewLine + sql
            ' xTrace(80401, "clsDataBase:SqlQry" + ex.Message)
            ' xTrace(80052, "clsDataBase:SqlQry", ex.StackTrace)
            ' xTrace(80036, "clsDataBase:SqlQry", sql)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryNewConn : 1368aa : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : SqlQryNewConn : 1368bb : " + sql)
        End Try

        'If ddebug Then log.WriteToArchiveLog("SQLQRY Ended: " + Now.tostring)
        'If ddebug Then Console.WriteLine("SQLQRY Ended: " + Now.tostring)

        command.Dispose()
        command = Nothing

        Return rsDataQry
    End Function

    ''' <summary>
    ''' Sets the global conection.
    ''' </summary>
    Public Sub setGlobalConection()
        CloseConn()
        CkConn()
    End Sub

    ''' <summary>
    ''' Closes the global conection.
    ''' </summary>
    Public Sub closeGlobalConection()
        If gConn.State = Data.ConnectionState.Open Then
            gConn.Close()
        End If
    End Sub

    ''' <summary>
    ''' Cks the site facility.
    ''' </summary>
    ''' <param name="FacilityID">The facility identifier.</param>
    Public Sub ckSiteFacility(ByVal FacilityID As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim NewKey As String = Trim(FacilityID)
        Dim H As String = Hex(CInt(NewKey))

        Dim iCnt As Integer = SelCount("Select count(*) from sites where facilityID = " + FacilityID)
        If iCnt > 0 Then
            Return
        End If

        iCnt = SelCount("Select count(*) from sites where sitecode = '?" + H + "'")
        If iCnt > 0 Then
            Return
        End If

        Dim NextDispOrder As Integer = NewID("SITES", "SiteDisplayOrder")

        Dim S As String = ""
        S = S + " insert into sites (sitecode, sitename, facilityid, sitemenuname, SiteDisplayOrder)"
        S = S + " values "
        S = S + " ('?" + H + "', 'Undefined Site', " + FacilityID + ", 'NA','" + NextDispOrder.ToString + "')"

        Dim b As Boolean = ExecuteSqlNewConn(S, False)

    End Sub

    ''' <summary>
    ''' Executes the SQL tx.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlTx(ByVal sql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim TxName As String = "TX001"
        Dim rc As Boolean = False

        ''Session("ActiveError") = False
        ''Session("ErrMsg") = ""
        ''Session("ErrStack") = ""

        CloseConn()
        CkConn()

        Using gConn
            Dim dbCmd As SqlCommand = gConn.CreateCommand()
            Dim transaction As SqlTransaction

            ' Start a local transaction
            transaction = gConn.BeginTransaction(TxName)

            ' Must assign both transaction object and connection to dbCmd object for a pending local transaction.
            dbCmd.Connection = gConn
            dbCmd.Transaction = transaction

            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                ' Attempt to commit the transaction.
                transaction.Commit()

                'Audit(sql)

                'Dim debug As Boolean = False
                'If debug Then
                '    Console.WriteLine("Successful execution: " + environment.NewLine + sql)
                'End If
                rc = True
            Catch ex As Exception
                rc = False

                ''Session("ActiveError") = True
                ''Session("ErrMsg") = "SQL Error check table PgmTrace: " , ex
                ''Session("ErrStack") = "Stack Trace: " + environment.NewLine + environment.NewLine + ex.StackTrace
                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlTx : 1412.1 : ", ex)
                ' xTrace(1991, "ExecuteSql: ", "-----------------------")
                ' xTrace(1992, "ExecuteSql: ", ex.Message.ToString)
                ' xTrace(2993, "ExecuteSql: ", ex.StackTrace.ToString)
                ' xTrace(3994, "ExecuteSql: ", sql)

                ' Attempt to roll back the transaction.
                Try
                    transaction.Rollback()
                Catch ex2 As Exception
                    ' This catch block will handle any errors that may have occurred on the server
                    ' that would cause the rollback to fail, such as a closed connection.
                    Console.WriteLine("Rollback Exception Type: {0}", ex2.GetType())
                    Console.WriteLine("  Message: {0}", ex2.Message)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlTx : 1412 : " + ex2.Message)
                End Try
            End Try
        End Using

        Return rc
    End Function

    ''' <summary>
    ''' Executes the SQL no tx.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlNoTx(ByVal sql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rc As Boolean = False

        ''Session("ActiveError") = False
        ''Session("ErrMsg") = ""
        ''Session("ErrStack") = ""

        CloseConn()
        CkConn()

        Using gConn

            Dim dbCmd As SqlCommand = gConn.CreateCommand()

            ' Must assign both transaction object and connection to dbCmd object for a pending local transaction.
            dbCmd.Connection = gConn

            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                rc = True
            Catch ex As Exception
                rc = False

                ''Session("ActiveError") = True
                ''Session("ErrMsg") = "ExecuteNoTx SQL: " + environment.NewLine + sql + environment.NewLine + environment.NewLine + ex.Message
                ''Session("ErrStack") = "Stack Trace: " + environment.NewLine + environment.NewLine + ex.StackTrace

                ' xTrace(87, "ExecuteSqlNoTx: ", "-----------------------")
                ' xTrace(134360, "ExecuteSqlNoTx: ", ex.Message.ToString)
                ' xTrace(234361, "ExecuteSqlNoTx: ", ex.StackTrace.ToString)
                ' xTrace(334362, "ExecuteSqlNoTx: ", sql)

                'EL.Add("error 12.23.68: ", ex)

                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNoTx : 1428 : ", ex)
            End Try
        End Using

        Return rc
    End Function

    ''' <summary>
    ''' xes the execute SQL new connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="ValidateOwnerShip">if set to <c>true</c> [validate owner ship].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function xExecuteSqlNewConn(ByVal sql As String, ByVal ValidateOwnerShip As Boolean) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If ValidateOwnerShip = True Then
            If TgtGuid.Length = 0 Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.01 - TgtGuid left blank and is required, contact Dale as this is an error.")
                LOG.WriteToArchiveLog("ERROR 666.01 - TgtGuid left blank and is required, contact Dale as this is an error.")
                Return False
            End If
            Dim isOwner As Boolean = ckContentOwnership(TgtGuid, gCurrUserGuidID)
            If isOwner = False Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.01a - This will be removed - tried to update content you do not own, ABORTED!")
                LOG.WriteToTraceLog("ExecuteSql: User '" + gCurrUserGuidID + "' tried to change '" + TgtGuid + "' w/o ownership.")
                Return False
            End If
        End If

        Dim rc As Boolean = False
        CloseConn()
        CkConn()
        Using gConn
            Dim dbCmd As SqlCommand = gConn.CreateCommand()
            ' Must assign both transaction object and connection to dbCmd object for a pending local transaction.
            dbCmd.Connection = gConn
            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                Return True
            Catch ex As Exception
                rc = False
                If InStr(ex.Message, "The DELETE statement conflicted with the REFERENCE", CompareMethod.Text) > 0 Then
                    MessageBox.Show("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                ElseIf InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSql : 1442.a : ", ex)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSql : 1442.a : " + sql)
                    Return True
                Else
                    'messagebox.show("Execute SQL: " + ex.message + environment.NewLine + "Please review the trace log." + environment.NewLine + sql)
                    If ddebug Then Clipboard.SetText(sql)
                End If

                '' xTrace(39901, "ExecuteSqlNoTx: " , ex.Message.ToString)
                '' xTrace(39901, "ExecuteSqlNoTx: ", ex.StackTrace.ToString)
                '' xTrace(39901, "ExecuteSqlNoTx: ", Mid(sql, 1, 2000))
                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSql : 1442.x : ", ex)
                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSql : 1442.x : " + environment.NewLine + sql + environment.NewLine)

            End Try
        End Using

        Return rc
    End Function

    ''' <summary>
    ''' Machines the register.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="NetWorkName">Name of the net work.</param>
    ''' <returns>System.String.</returns>
    Function MachineRegister(MachineName As String, NetWorkName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim MySql As String = "Select Count(*) from MachineRegistered where MachineName ='" + MachineName + "' and NetworkName = '" + NetWorkName + "' "
        Dim iCnt As Integer = iCount(MySql)
        Dim MachineGuid As String = ""

        If iCnt > 0 Then
            Try
                MySql = "Select MachineGuid from MachineRegistered where MachineName ='" + MachineName + "' and NetworkName = '" + NetWorkName + "' "
                CloseConn()
                CkConn()

                Dim rsData As SqlDataReader = Nothing
                Dim b As Boolean = False
                Dim CS As String = getRepoConnStr()
                Dim CONN As New SqlConnection(CS)
                CONN.Open()
                Dim command As New SqlCommand(MySql, CONN)
                rsData = command.ExecuteReader()
                rsData.Read()
                MachineGuid = rsData.GetValue(0).ToString
                rsData.Close()
                rsData = Nothing
            Catch ex As Exception
                ' xTrace(12306, "clsDataBase:MachineRegister" + ex.Message)
                LOG.WriteToArchiveLog("ERROR 56453.21: ", ex)
                LOG.WriteToArchiveLog("clsDatabaseARCH : MachineRegister : 2054 : ", ex)
                Return "NA"
            End Try
        Else

            MySql = ""

            MachineGuid = getGuid()
            MySql += "INSERT INTO [MachineRegistered]" + environment.NewLine
            MySql += "(" + environment.NewLine
            MySql += "[MachineGuid]" + environment.NewLine
            MySql += ",[MachineName]" + environment.NewLine
            MySql += ",[NetWorkName]" + environment.NewLine
            MySql += ")" + environment.NewLine
            MySql += "VALUES " + environment.NewLine
            MySql += "(" + environment.NewLine
            MySql += "'" + MachineGuid + "'," + environment.NewLine
            MySql += "'" + MachineName + "'," + environment.NewLine
            MySql += "'" + NetWorkName + "'" + environment.NewLine
            MySql += ")" + environment.NewLine

            Dim B As Boolean = ExecuteSqlNewConn(90104, MySql)

        End If

        Return MachineGuid

    End Function

    ''' <summary>
    ''' Executes the SQL new connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="ValidateOwnerShip">if set to <c>true</c> [validate owner ship].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlNewConn(ByVal sql As String, ByVal ValidateOwnerShip As Boolean) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim BB As Boolean = True

        SyncLock Me
            If ValidateOwnerShip = True Then
                If TgtGuid.Length = 0 Then
                    If gTgtGuid.Length > 0 Then
                        TgtGuid = gTgtGuid
                    Else
                        ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.04x1 - TgtGuid left blank and is required, contact ADMINISTRATOR as this is an error.")
                        LOG.WriteToArchiveLog("ERROR 666.04x1 - TgtGuid left blank and is required, contact ADMINISTRATOR as this is an error.")
                        Return False
                    End If
                End If
                Dim isOwner As Boolean = ckContentOwnership(TgtGuid, gCurrUserGuidID)
                If isOwner = False Then
                    'messagebox.show("ERROR 666.04a - This will be removed - tried to update content you do not own, ABORTED!")
                    LOG.WriteToTraceLog("ExecuteSqlNewConn: User '" + gCurrUserGuidID + "' tried to change '" + TgtGuid + "' w/o ownership.")
                    Return False
                End If
            End If
            Dim rc As Boolean = False
            Dim CnStr As String = getRepoConnStr()
            If (CnStr.Contains("ERROR:")) Then
                ' xTrace(19554121, "ExecuteSqlNoTx: ", "ERROR: Failed to acquire connection string from gateway.")
                BB = False
            ElseIf (CnStr.Length > 0) Then

                Dim CN As New SqlConnection(CnStr)
                CN.Open()
                Dim dbCmd As SqlCommand = CN.CreateCommand()
                Using dbCmd
                    Using CN
                        dbCmd.Connection = CN
                        Try
                            dbCmd.CommandText = sql
                            dbCmd.ExecuteNonQuery()
                            BB = True
                        Catch ex As Exception
                            rc = False

                            If InStr(ex.Message, "Could not allocate space", CompareMethod.Text) > 0 And InStr(ex.Message, "is full", CompareMethod.Text) > 0 Then
                                frmOutOfSpace.Show()
                                Application.DoEvents()
                            End If
                            If InStr(ex.Message, "The DELETE statement conflicted with the REFERENCE", CompareMethod.Text) > 0 Then
                                ' If gRunUnattended = False Then MessageBox.Show("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c0 It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                                BB = False
                            ElseIf InStr(ex.Message, "HelpText", CompareMethod.Text) > 0 Then
                                BB = True
                            ElseIf InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                                BB = True
                            ElseIf InStr(ex.Message, "duplicate key", CompareMethod.Text) > 0 Then
                                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c2 - NOT AN ERROR, JUST RI PROTECTING THE DBARCH.")
                                LOG.WriteToArchiveLog("Advisory - clsDatabaseARCH : ExecuteSqlNewConn : 1465c2 : ", ex)
                                LOG.WriteToArchiveLog("Advisory - clsDatabaseARCH : ExecuteSqlNewConn : 1465c2 : " + sql)
                                BB = True
                            ElseIf InStr(ex.Message, "duplicate", CompareMethod.Text) > 0 Then
                                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c3 - NOT AN ERROR, JUST RI PROTECTING THE DBARCH.")
                                LOG.WriteToArchiveLog("Advisory - clsDatabaseARCH : ExecuteSqlNewConn : 1466c3 : ", ex)
                                LOG.WriteToArchiveLog("Advisory - clsDatabaseARCH : ExecuteSqlNewConn : 1466c3 : " + sql)
                                BB = True
                            ElseIf ex.Message.Contains("Cannot insert duplicate key row") Then
                                BB = True
                            Else
                                BB = False
                                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9448a2x.1: ", ex)
                                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9448a2x.2: " + environment.NewLine + sql + environment.NewLine)
                            End If
                        End Try
                    End Using
                End Using

            End If

            GC.Collect()
            GC.WaitForPendingFinalizers()
            GC.WaitForFullGCComplete()
        End SyncLock
        Return BB
    End Function

    ''' <summary>
    ''' Executes the SQL same connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="CN">The cn.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlSameConn(ByVal sql As String, ByVal CN As SqlConnection) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rc As Boolean = False

        Dim dbCmd As SqlCommand = CN.CreateCommand()
        Dim BB As Boolean = True
        Using CN
            dbCmd.Connection = CN
            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                BB = True
            Catch ex As Exception
                rc = False

                If InStr(ex.Message, "The DELETE statement conflicted with the REFERENCE", CompareMethod.Text) > 0 Then
                    ' If gRunUnattended = False Then MessageBox.Show("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c0 It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                    BB = False
                ElseIf InStr(ex.Message, "HelpText", CompareMethod.Text) > 0 Then
                    BB = True
                ElseIf InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c1 - NOT AN ERROR, JUST RI PROTECTING THE DBARCH.")
                    LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1464c1 : ", ex)
                    'LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1464c1 : " + sql)
                    BB = True
                ElseIf InStr(ex.Message, "duplicate key", CompareMethod.Text) > 0 Then
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c2 - NOT AN ERROR, JUST RI PROTECTING THE DBARCH.")
                    LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1465c2 : ", ex)
                    LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1465c2 : " + sql)
                    BB = True
                ElseIf InStr(ex.Message, "duplicate", CompareMethod.Text) > 0 Then
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c3 - NOT AN ERROR, JUST RI PROTECTING THE DBARCH.")
                    LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1466c3 : ", ex)
                    LOG.WriteToArchiveLog("Notification - clsDatabaseARCH : ExecuteSqlNewConn : 1466c3 : " + sql)
                    BB = True
                Else
                    'messagebox.show("Execute SQL: " + ex.message + environment.NewLine + "Please review the trace log." + environment.NewLine + sql)
                    If ddebug Then Clipboard.SetText(sql)
                    BB = False
                    ' xTrace(1998134, "ExecuteSqlNoTx: ", ex.Message.ToString)
                    ' xTrace(2998134, "ExecuteSqlNoTx: ", ex.StackTrace.ToString)
                    ' xTrace(3998134, "ExecuteSqlNoTx: ", Mid(sql, 1, 2000))
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9442a2x.1: ", ex)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9442a2x.2: " + environment.NewLine + sql + environment.NewLine)
                End If
            End Try
        End Using

        GC.Collect()

        Return BB
    End Function

    ''' <summary>
    ''' Executes the SQL new connection.
    ''' </summary>
    ''' <param name="loc">The loc.</param>
    ''' <param name="sql">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlNewConn(loc As Int32, ByVal sql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim RC As Boolean = True
        Dim RetMsg As String = ""
        Dim CMD As New SqlCommand
        Dim connString As String = getRepoConnStr()
        Dim conn As New SqlConnection(connString)

        Try
            conn.Open()

            Dim SkipThis As Boolean = False

            If Not SkipThis Then

                If conn Is Nothing Then
                    conn = New SqlConnection(getRepoConnStr())
                End If
                If conn.State = ConnectionState.Closed Then
                    conn.ConnectionString = getRepoConnStr()
                    conn.Open()
                End If

                CMD = conn.CreateCommand()
                CMD.Connection = conn

                'Dim dbCmd As SqlCommand = conn.CreateCommand()
                Dim BB As Boolean = True
                Using conn
                    If CMD.Connection.State = ConnectionState.Closed Then
                        CMD.Connection = conn
                    End If

                    Try
                        CMD.CommandText = sql
                        CMD.ExecuteNonQuery()
                        BB = True
                    Catch ex As Exception
                        RC = False

                        If InStr(ex.Message, "The DELETE statement conflicted with the REFERENCE", CompareMethod.Text) > 0 Then
                            ' If gRunUnattended = False Then MessageBox.Show("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                            LOG.WriteToArchiveLog("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                        ElseIf InStr(ex.Message, "HelpText", CompareMethod.Text) > 0 Then
                            BB = True
                        ElseIf InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                            'LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c1 : ", ex)
                            'LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c1 : " + sql)
                            BB = True
                        ElseIf InStr(ex.Message, "duplicate key", CompareMethod.Text) > 0 Then
                            'log.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1465c2 : " , ex)
                            'log.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c2 : " + sql)
                            BB = True
                        ElseIf InStr(ex.Message, "duplicate", CompareMethod.Text) > 0 Then
                            'log.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1466c3 : " , ex)
                            'log.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464c3 : " + sql)
                            BB = True
                        Else
                            If ddebug Then Clipboard.SetText(sql)
                            BB = False
                            ' xTrace(19981647, "ExecuteSqlNoTx: ", ex.Message.ToString)
                            If ddebug Then Debug.Print(ex.Message.ToString)
                            ' xTrace(29981647, "ExecuteSqlNoTx: ", ex.StackTrace.ToString)
                            ' xTrace(39981647, "ExecuteSqlNoTx: ", Mid(sql, 1, 2000))
                            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9442a1p1: " + loc.ToString + " : ", ex)
                            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 9442a1p2: " + environment.NewLine + sql + environment.NewLine)
                        End If

                    End Try
                End Using
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 2166a3x.2: " + environment.NewLine + sql + environment.NewLine)
        Finally
            If conn.State = ConnectionState.Open Then
                conn.Close()
            End If
            conn.Dispose()
            CMD.Dispose()
        End Try

        GC.Collect()
        GC.WaitForPendingFinalizers()

        Return RC
    End Function

    ''' <summary>
    ''' Applies the SQL statement.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="ErrMsg">The error MSG.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ApplySqlStmt(ByVal sql As String, ByRef ErrMsg As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rc As Boolean = False

        Dim CN As New SqlConnection(getRepoConnStr())
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()

        Using CN
            dbCmd.Connection = CN
            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                rc = True
                ErrMsg = ""
            Catch ex As Exception
                ErrMsg = ex.Message
                LOG.WriteToArchiveLog("clsDatabaseARCH : ApplySqlStmt : 100: ", ex)
            End Try
        End Using

        If CN.State = ConnectionState.Open Then
            CN.Close()
        End If
        CN = Nothing
        dbCmd = Nothing
        Return rc
    End Function

    ''' <summary>
    ''' Executes the SQL lookup table.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlLookupTable(ByVal sql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim rc As Boolean = False

        Dim CN As New SqlConnection(getRepoConnStr())
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()

        Using CN
            dbCmd.Connection = CN
            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                rc = True
            Catch ex As Exception
                rc = False
                If InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                    Return True
                End If
                ' xTrace(934161, "ExecuteSqlLookupTable: ", ex.Message.ToString)
                ' xTrace(934162, "ExecuteSqlLookupTable: ", Mid(sql, 1, 2000))
            End Try
        End Using

        If CN.State = ConnectionState.Open Then
            CN.Close()
        End If
        CN = Nothing
        dbCmd = Nothing
        Return rc
    End Function

    ''' <summary>
    ''' Executes the SQL.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="NewConnectionStr">Creates new connectionstr.</param>
    ''' <param name="ValidateOwnerShip">if set to <c>true</c> [validate owner ship].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSql(ByVal sql As String, ByVal NewConnectionStr As String, ByVal ValidateOwnerShip As Boolean) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If ValidateOwnerShip = True Then
            If TgtGuid.Length = 0 Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.05 - TgtGuid left blank and is required, contact ADMIN as this is an error.")
                LOG.WriteToArchiveLog("ERROR 666.05 - TgtGuid left blank and is required, contact ADMIN as this is an error.")
                Return False
            End If
            Dim isOwner As Boolean = ckContentOwnership(TgtGuid, gCurrUserGuidID)
            If isOwner = False Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.05a - This will be removed - tried to update content you do not own, ABORTED!")
                LOG.WriteToTraceLog("ExecuteSqlNewConn2: User '" + gCurrUserGuidID + "' tried to change '" + TgtGuid + "' w/o ownership.")
                Return False
            End If
        End If
        Try
            Dim rc As Boolean = True

            Dim CN As New SqlConnection(NewConnectionStr)
            CN.Open()
            Dim dbCmd As SqlCommand = CN.CreateCommand()

            Using CN
                dbCmd.Connection = CN
                Try
                    dbCmd.CommandText = sql
                    dbCmd.ExecuteNonQuery()
                    rc = True
                Catch ex As Exception
                    rc = False
                    If InStr(ex.Message, "The DELETE statement conflicted with the REFERENCE", CompareMethod.Text) > 0 Then
                        ' If gRunUnattended = False Then MessageBox.Show("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                        LOG.WriteToArchiveLog("It appears this user has DATA within the repository associated to them and cannot be deleted." + environment.NewLine + environment.NewLine + ex.Message)
                    ElseIf InStr(ex.Message, "duplicate key row", CompareMethod.Text) > 0 Then
                        LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNewConn : 1464 : ", ex)
                        Return True
                    Else
                        'messagebox.show("Execute SQL: " + ex.message + environment.NewLine + "Please review the trace log." + environment.NewLine + sql)
                        If ddebug Then Clipboard.SetText(sql)
                    End If
                    ' xTrace(2343111, "ExecuteSqlNoTx: ", "-----------------------")
                    ' xTrace(2343112, "ExecuteSqlNoTx: ", ex.Message.ToString)
                    ' xTrace(2343113, "ExecuteSqlNoTx: ", ex.StackTrace.ToString)
                    ' xTrace(2343114, "ExecuteSqlNoTx: ", Mid(sql, 1, 2000))
                    LOG.WriteToArchiveLog("ERROR: ExecuteSql 2001 - " + sql)
                End Try
            End Using

            If CN.State = ConnectionState.Open Then
                CN.Close()
            End If
            CN = Nothing
            dbCmd = Nothing
            Return rc
        Catch ex As Exception
            ' xTrace(9914, "ExecuteSql", ex.Message.ToString)
            ' If gRunUnattended = False Then MessageBox.Show(ex.Message)
            LOG.WriteToArchiveLog("ERROR ExecuteSql 100a1: ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Executes the sp.
    ''' </summary>
    ''' <param name="spName">Name of the sp.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecSP(ByVal spName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim B As Boolean = False
        Dim TimeTrk As Boolean = True
        Try
            CloseConn()
            CkConn()
            If TimeTrk Then
                System.Console.WriteLine(spName + " Start: " + DateTime.Today.ToString)
            End If
            Dim command As SqlCommand = New SqlCommand(spName, gConn)
            command.CommandType = Data.CommandType.StoredProcedure
            command.CommandText = spName
            command.CommandTimeout = 3600
            command.ExecuteNonQuery()
            command = Nothing
            gConn.Close()
            B = True
            If TimeTrk Then
                System.Console.WriteLine(spName + " End: " + DateTime.Today.ToString)
            End If
        Catch ex As Exception
            'Session("ErrorLocation") = 'Session("ErrorLocation") + " : " , ex
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : ExecSP : 1498 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Sps the apply update.
    ''' </summary>
    ''' <param name="UpdateSql">The update SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SP_ApplyUpdate(ByVal UpdateSql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim spName As String = ""

        spName = "funcEcmUpdateDB " + UpdateSql
        Dim B As Boolean = False
        'Dim TimeTrk As Boolean = True
        Try
            CloseConn()
            CkConn()
            'If TimeTrk Then
            '    System.Console.WriteLine(spName + " Start: " + DateTime.Today.ToString)
            'End If
            'Dim command As SqlCommand = New SqlCommand(spName, gConn)
            'command.CommandType = Data.CommandType.StoredProcedure
            'command.CommandText = spName
            'command.CommandTimeout = 3600
            'command.ExecuteNonQuery()
            'command = Nothing
            'gConn.Close()

            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("funcEcmUpdateDB", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@pSql", UpdateSql))
                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    connection.Dispose()
                    command.Dispose()
                End Using
            End Using
            B = True
            'If TimeTrk Then
            '    System.Console.WriteLine(spName + " End: " + DateTime.Today.ToString)
            'End If
        Catch ex As Exception
            'Session("ErrorLocation") = 'Session("ErrorLocation") + " : " , ex
            Console.WriteLine(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : SP_ApplyUpdate : 100 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Executes the SQL no audit.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlNoAudit(ByVal sql As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim TxName As String = "TX001"
        Dim rc As Boolean = False

        CloseConn()
        CkConn()

        Using gConn

            Dim dbCmd As SqlCommand = gConn.CreateCommand()

            'Dim transaction As SqlTransaction

            'transaction = gConn.BeginTransaction(TxName)

            ' Must assign both transaction object and connection to dbCmd object for a pending local transaction.
            dbCmd.Connection = gConn
            'dbCmd.Transaction = transaction

            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                ' Attempt to commit the transaction.
                'transaction.Commit()
                'Dim debug As Boolean = False
                'If debug Then
                '    Console.WriteLine("Successful execution: " + environment.NewLine + sql)
                'End If
                rc = True
            Catch ex As Exception
                rc = False
                Console.WriteLine("Exception Type: {0}", ex.GetType())
                Console.WriteLine("  Message: {0}" + ex.Message)
                Console.WriteLine(sql)

                ''Session("ActiveError") = True
                ''Session("ErrMsg") = "ExecuteSqlNoAudit - SQL Error check table PgmTrace: " , ex
                ''Session("ErrStack") = "Stack Trace: " + environment.NewLine + environment.NewLine + ex.StackTrace

                ' xTrace(23435460, "ExecuteSql: ", "-----------------------")
                ' xTrace(23435461, "ExecuteSql: ", ex.Message.ToString)
                ' xTrace(23435462, "ExecuteSql: ", ex.StackTrace.ToString)
                ' xTrace(23435463, "ExecuteSql: ", sql)

                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSqlNoAudit : 1516 : ", ex)
            End Try
        End Using

        Return rc
    End Function

    ''' <summary>
    ''' Saves the history.
    ''' </summary>
    ''' <param name="SQL">The SQL.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function saveHistory(ByVal SQL As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = True
        Dim typeSql As String = ""
        Dim tbl As String = ""
        Dim i As Integer = 0
        Dim j As Integer = 0

        i = InStr(1, SQL, " ", CompareMethod.Text)
        typeSql = Mid(SQL, 1, i - 1)
        typeSql = UCase(typeSql)

        If typeSql = "INSERT" Then
            i = InStr(1, SQL, "into", CompareMethod.Text)
            i = i + Len("into ")
            j = InStr(i, SQL, " ")
            tbl = Mid(SQL, i, j - i)
        End If
        If typeSql = "DELETE" Then
            i = InStr(1, SQL, "from", CompareMethod.Text)
            i = i + Len("from ")
            j = InStr(i, SQL, " ")
            tbl = Mid(SQL, i, j - i)
        End If
        If typeSql = "UPDATE" Then
            i = InStr(1, SQL, " ", CompareMethod.Text)
            i = i + Len(" ")
            j = InStr(i, SQL, " ")
            tbl = Mid(SQL, i, j - i)
        End If

        tbl = UCase(tbl)
        If tbl = "USER_ACCESS" Then
            Return True
        End If
        If tbl = "HISTORY" Then
            Return True
        End If

        SQL = UTIL.RemoveSingleQuotes(SQL)
        '** select tbl, sqlstmt,LAST_MOD_DATE,user_name,action from history
        'Public MachineName As String = ""
        'Public MachineIP As String = ""
        'Public UserID As String = ""

        Dim S As String = "insert into HISTORY (tbl, sqlstmt,LAST_MOD_DATE,user_name,action, HostName, IPAddr, Last_Mod_User, Create_user) values ("
        S = S + "'" + tbl + "',"
        S = S + "'" + SQL + "', "
        S = S + " getdate(), "
        'S = S + "'" + Now() + "',"
        S = S + "'" + LOG.getEnvVarUserID + "',"
        S = S + "'" + typeSql + "',"
        S = S + "'" + DMA.getHostname() + "',"
        S = S + "'" + DMA.getIpAddr() + "',"
        S = S + "'" + LOG.getEnvVarUserID + "',"
        S = S + "'" + LOG.getEnvVarUserID + "')"

        'Clipboard.Clear()
        'Clipboard.SetText(S)

        b = ExecuteSqlNewConn(S, False)

        Return b
    End Function

    ''' <summary>
    ''' Gets the cpu time.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getCpuTime() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        '** You can browse the available performance counters by
        '** going to Control Panel | Administrative Tools | Performance and clicking Add.
        Dim perfCounter As New System.Diagnostics.PerformanceCounter()
        Dim loopCount As Integer
        Dim CPU As String = ""

        perfCounter.CategoryName = "Processor"
        perfCounter.CounterName = "% Processor Time"
        perfCounter.InstanceName = "_Total"

        For loopCount = 1 To 2
            'Debug.WriteLine(perfCounter.NextValue.ToString())
            CPU = perfCounter.NextValue.ToString()
        Next

        perfCounter.Close()

        Return CPU

    End Function

    ''' <summary>
    ''' Gets the table name from SQL.
    ''' </summary>
    ''' <param name="Sql">The SQL.</param>
    ''' <returns>System.String.</returns>
    Function GetTableNameFromSql(ByVal Sql As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim typeSql As String = ""
        Dim tbl As String = ""
        Dim i As Integer = 0
        Dim j As Integer = 0

        Sql = Trim(Sql)

        Dim s1 As String = ""
        Dim s2 As String = ""
        Dim ch As String = ""

        For i = 1 To Len(Sql)
            ch = Mid(Sql, i, 1)
            If ch = "(" Then
                s1 = s1 + " " + ch
            ElseIf ch = ")" Then
                s1 = s1 + ch + " "
            Else
                s1 = s1 + ch
            End If
        Next

        Sql = s1

        i = InStr(1, Sql, " ", CompareMethod.Text)
        typeSql = Mid(Sql, 1, i - 1)
        typeSql = UCase(typeSql)

        If typeSql = "INSERT" Then
            i = InStr(1, Sql, "into", CompareMethod.Text)
            i = i + Len("into ")
            j = InStr(i, Sql, " ")
            tbl = Mid(Sql, i, j - i)
        End If
        If typeSql = "DELETE" Then
            i = InStr(1, Sql, "from", CompareMethod.Text)
            i = i + Len("from ")
            j = InStr(i, Sql, " ")
            tbl = Mid(Sql, i, j - i)
        End If
        If typeSql = "UPDATE" Then
            i = InStr(1, Sql, " ", CompareMethod.Text)
            i = i + Len(" ")
            j = InStr(i, Sql, " ")
            tbl = Mid(Sql, i, j - i)
        End If

        Return tbl

    End Function

    ''' <summary>
    ''' Gets the where clause from SQL.
    ''' </summary>
    ''' <param name="Sql">The SQL.</param>
    ''' <returns>System.String.</returns>
    Function GetWhereClauseFromSql(ByVal Sql As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim typeSql As String = ""
        Dim wc As String = ""
        Dim tbl As String = ""
        Dim i As Integer = 0
        Dim j As Integer = 0

        i = InStr(1, Sql, " where", CompareMethod.Text)
        If i > 0 Then
            wc = Mid(Sql, i)
        End If

        Return wc

    End Function

    ''' <summary>
    ''' Gets the type SQL statement.
    ''' </summary>
    ''' <param name="Sql">The SQL.</param>
    ''' <returns>System.String.</returns>
    Function GetTypeSqlStmt(ByVal Sql As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim typeSql As String = ""
        Dim tbl As String = ""
        Dim i As Integer = 0
        Dim j As Integer = 0
        Dim SqlType As String = ""

        Sql = Trim(Sql)
        i = InStr(1, Sql, " ", CompareMethod.Text)
        typeSql = Mid(Sql, 1, i - 1)
        typeSql = UCase(typeSql)

        If typeSql = "INSERT" Then
            SqlType = typeSql
        End If
        If typeSql = "DELETE" Then
            SqlType = typeSql
        End If
        If typeSql = "UPDATE" Then
            SqlType = typeSql
        End If
        If typeSql = "SELECT" Then
            SqlType = typeSql
        End If
        Return SqlType
    End Function

    ''' <summary>
    ''' Cks the module authentication.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="AuthCode">The authentication code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckModuleAuth(ByVal UID As String, ByVal AuthCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        AuthCode = UCase(AuthCode)
        Dim AuthGranted As Boolean = False
        Select Case AuthCode
            Case "DBA"
                AuthGranted = False
            Case "GRAPHICS"
                AuthGranted = False
            Case "INVENTORY"
                AuthGranted = False
            Case "STANDARDS"
                AuthGranted = False
            Case "ACCESS"
                AuthGranted = False
            Case "ACTION"
                AuthGranted = False
            Case "REPORTS"
                AuthGranted = False
            Case "COMPLAINTS"
                AuthGranted = False
            Case "COMPLAINANTS"
                AuthGranted = False
            Case "EMPLOYMENT"
                AuthGranted = False
            Case Else
                AuthGranted = False
                'DMA.SaveErrMsg(, "Error 121.99.2", "100.10c - Incorrect authority code entered, returning...")
                ''Session("ErrMsg") = "Error 121.99.2"
                ''Session("ErrStack") = "100.10c - Incorrect authority code entered, returning..."
                'Response.Redirect("frmErrDisplay.aspx")
                Return AuthGranted
        End Select

        Dim Level As String = ""

        Dim s As String = "Select * from user_rights where user_name = '" + UID + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        Try
            If rsData.IsClosed Then
                Console.WriteLine("ckModuleAuth HERE it is closed: " + UID)
            Else
                Console.WriteLine("ckModuleAuth HERE it is OPEN: " + UID)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckModuleAuth : 1680 : ", ex)
        End Try

        If rsData.HasRows Then
            rsData.Read()
            Level = rsData.GetValue(rsData.GetOrdinal(AuthCode)).ToString
            If Level <> "0" Then
                AuthGranted = True
            Else
                AuthGranted = False
            End If
        Else
            AuthGranted = False
        End If
        rsData.Close()
        'connection.Close()

        Return AuthGranted
    End Function

    ''' <summary>
    ''' Gets the name of the server database.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getServerDbName() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'SELECT DB_NAME() AS DataBaseName
        Dim s As String = "Select DB_NAME() AS DataBaseName"
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim ServerDbName As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        Try
            If rsData.IsClosed Then
                Console.WriteLine("getServerName HERE it is closed.")
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getServerDbName : 10 : ", ex)
        End Try

        If rsData.HasRows Then
            rsData.Read()
            ServerDbName = rsData.GetValue(0).ToString
        End If
        rsData.Close()
        rsData = Nothing
        Return ServerDbName
    End Function

    ''' <summary>
    ''' Cks the authority.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="AuthCode">The authentication code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckAuthority(ByVal UID As String, ByVal AuthCode As String) As Boolean
        Dim AuthGranted As Boolean = False
        AuthCode = UCase(AuthCode)
        Select Case AuthCode
            Case "ADMIN"
                AuthGranted = False
            Case "SUPER USER"
                AuthGranted = False
            Case "USER"
                AuthGranted = False
            Case Else
                AuthGranted = False
                LOG.WriteToArchiveLog("Error 100.10a - Incorrect authority code entered, returning.")
                Return AuthGranted
        End Select
        Dim Auth As String = ""
        Dim s As String = "Select user_type_cd from user_database where user_name = '" + UID + "' "
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()

        rsData.Read()
        Auth = rsData.GetValue(rsData.GetOrdinal(AuthCode)).ToString
        If Auth = AuthCode Then
            AuthGranted = True
        Else
            AuthGranted = False
        End If
        rsData.Close()

        Return AuthGranted
    End Function

    ''' <summary>
    ''' Users the has authority.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="AuthCode">The authentication code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UserHasAuthority(ByVal UID As String, ByVal AuthCode As String) As Boolean
        Dim AuthGranted As Boolean = False
        AuthCode = UCase(AuthCode)
        Select Case AuthCode
            Case "EDIT"
                AuthGranted = False
            Case "INSERT"
                AuthGranted = False
            Case "UPDATE"
                AuthGranted = False
            Case "DELETE"
                AuthGranted = False
            Case "READ"
                AuthGranted = False
            Case "MAINT"
                AuthGranted = False
            Case "EXECUTE"
                AuthGranted = False
            Case Else
                AuthGranted = False
                LOG.WriteToArchiveLog("Error 100.10t - Incorrect authority code entered, returning.")
                Return AuthGranted
        End Select
        Dim Auth As String = ""
        Dim s As String = "Select user_type_cd from user_database where user_name = '" + UID + "' "
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()
        Auth = rsData.GetValue(0).ToString
        If Auth = "ADMIN" Then
            AuthGranted = True
        Else
            Select Case AuthCode
                Case "INSERT"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case "EDIT"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case "UPDATE"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case "DELETE"
                    If Auth = "SUPER USER" Then
                        AuthGranted = False
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case "READ"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = True
                    Else
                        AuthGranted = False
                    End If
                Case "MAINT"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case "EXECUTE"
                    If Auth = "SUPER USER" Then
                        AuthGranted = True
                    ElseIf Auth = "USER" Then
                        AuthGranted = False
                    Else
                        AuthGranted = False
                    End If
                Case Else
                    AuthGranted = False
            End Select
        End If
        rsData.Close()

        Return AuthGranted
    End Function

    ''' <summary>
    ''' Cks the length of the field.
    ''' </summary>
    ''' <param name="Title">The title.</param>
    ''' <param name="fld">The field.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckFldLen(ByVal Title As String, ByVal fld As String) As Boolean
        If Len(fld) = 0 Then
            LOG.WriteToArchiveLog("Error ckFldLen 100.10i - " + Title + " is a required field.")
            Return False
        Else
            Return True
        End If
    End Function

    'Public Sub log.WriteToArchiveLog(ByVal Msg )

    ' Dim cPath As String = GetCurrDir() Dim tFQN = cPath + "\AdmsApp.Log" ' Create an instance of
    ' StreamWriter to write text to a file. Using sw As StreamWriter = New StreamWriter(tFQN, True) '
    ' Add some text to the file. sw.WriteLine(Now() + ": " + Msg) sw.Close() End Using

    'End Sub

    ''' <summary>
    ''' Gets the curr dir.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function GetCurrDir() As String
        Dim s As String = ""
        Dim ch As String = ""
        Dim i As Integer = 0
        's = Application.ExecutablePath
        s = System.Reflection.Assembly.GetExecutingAssembly.Location.ToString
        If InStr(1, s, "\") > 0 Then
            i = Len(s)
            ch = ""
            Do While ch <> "\"
                i = i - 1
                ch = Mid(s, i, 1)
            Loop
        End If
        Dim cPath As String = ""
        cPath = Mid(s, 1, i - 1)
        Return cPath
    End Function

    ''' <summary>
    ''' Retrieves the document.
    ''' </summary>
    ''' <param name="DocID">The document identifier.</param>
    ''' <returns>System.Byte().</returns>
    Public Function RetrieveDocument(ByVal DocID As String) As Byte()

        Dim cn As SqlConnection = Nothing
        cn.ConnectionString = gConnStr
        cn.Open()

        Dim sql As String = "Select DocumentText from documents where documentid = " & DocID
        Dim CMD As New SqlCommand(sql, cn)
        Dim da As New SqlDataAdapter(CMD)
        Dim ds As New Data.DataSet

        da.Fill(ds, "BLOBIMAGE")

        Dim c As Integer = ds.Tables("BLOBIMAGE").Rows.Count

        If c > 0 Then
            Try
                Dim bytBLOBData() As Byte = CType(ds.Tables("BLOBIMAGE").Rows(c - 1)("DocumentText"), Byte())
                'Dim stmBLOBData As New MemoryStream(bytBLOBData)
                'MS = stmBLOBData
                If gClipBoardActive = True Then Console.WriteLine("Document Bytes Retrieved: " & bytBLOBData.Length)
                cn.Close()
                cn = Nothing
                Return bytBLOBData
            Catch ex As Exception
                ' xTrace(12304, "clsDataBase:RetrieveDocument" + ex.Message)
                Console.Write(ex.StackTrace)
                If gClipBoardActive = True Then Console.WriteLine("*************************************")
                If gClipBoardActive = True Then Console.WriteLine(ex.Message)
                If gClipBoardActive = True Then Console.WriteLine("********Inner Exception *********")
                If gClipBoardActive = True Then Console.WriteLine(ex.InnerException.Message)
                LOG.WriteToArchiveLog("clsDatabaseARCH : RetrieveDocument : 1856 : ", ex)
            End Try

        End If
        cn.Close()
        cn = Nothing
        Return Nothing
    End Function

    ''' <summary>
    ''' Gets the document FQN by identifier.
    ''' </summary>
    ''' <param name="DocID">The document identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getDocumentFqnById(ByVal DocID As String) As String

        Dim cn As SqlConnection = Nothing

        'gConnStr = ConfigurationManager.ConnectionStrings(ConnectionStringID).ConnectionString

        cn.ConnectionString = gConnStr
        cn.Open()

        Dim sql As String = "Select DocFqn from documents where documentid = " & DocID
        Dim CMD As New SqlCommand(sql, cn)
        Dim da As New SqlDataAdapter(CMD)
        Dim ds As New Data.DataSet

        da.Fill(ds, "DocFqn")

        Dim c As Integer = ds.Tables("DocFqn").Rows.Count

        If c > 0 Then
            Try
                Dim FQN As String = CStr(ds.Tables("DocFqn").Rows(c - 1)("DocFqn"))
                'Dim stmBLOBData As New MemoryStream(bytBLOBData)
                'MS = stmBLOBData
                If gClipBoardActive = True Then Console.WriteLine("Graphic Bytes Retrieved: " & FQN.Length)
                cn.Close()
                cn = Nothing
                Return FQN
            Catch ex As Exception
                ' xTrace(12305, "clsDataBase:GetDocumentFqnById" + ex.Message)
                Console.Write(ex.StackTrace)
                If gClipBoardActive = True Then Console.WriteLine("*************************************")
                If gClipBoardActive = True Then Console.WriteLine(ex.Message)
                If gClipBoardActive = True Then Console.WriteLine("********Inner Exception *********")
                If gClipBoardActive = True Then Console.WriteLine(ex.InnerException.Message)
                LOG.WriteToArchiveLog("clsDatabaseARCH : getDocumentFqnById : 1880 : ", ex)
            End Try

        End If
        cn.Close()
        cn = Nothing
        Return Nothing
    End Function

    ''' <summary>
    ''' zs the trace.
    ''' </summary>
    ''' <param name="StmtID">The statement identifier.</param>
    ''' <param name="Stmt">The statement.</param>
    ''' <param name="PgmName">Name of the PGM.</param>
    ''' <param name="ex">The ex.</param>
    Sub ZTrace(ByVal StmtID As Integer, ByVal Stmt As String, ByVal PgmName As String, ByVal ex As Exception)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim ErrStack As String = ex.StackTrace.ToString
        Dim ErrorSource As String = ex.Source.ToString
        ' Dim InnerException = ex.InnerException.Message.ToString
        Dim ErrMsg As String = ex.Message.ToString
        'Dim exData As Collection = ex.Data
        Dim ConnectiveGuid As String = Me.getGuid()

        PgmName = UTIL.RemoveSingleQuotes(PgmName)
        Dim S As String = ""
        Stmt = UTIL.RemoveSingleQuotes(Stmt)
        S = "INSERT INTO PgmTrace ([StmtID] ,[PgmName], ConnectiveGuid, stmt, UserID) VALUES(" & StmtID & ", '" & PgmName & "' , '" + ConnectiveGuid + "', '" + Stmt + "', '" + gCurrUserGuidID + "')"
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        If b = False Then
            ''Session("ErrMsg") = "StmtId Call: " + 'Session("ErrMsg")
            ''Session("ErrStack") = "StmtId Call Stack: " + ''Session("ErrStack")
        End If

        SaveErrMsg(ErrMsg, ErrStack, StmtID.ToString, ConnectiveGuid)

    End Sub

    ''' <summary>
    ''' Fixes the single quotes.
    ''' </summary>
    ''' <param name="Stmt">The statement.</param>
    Sub FixSingleQuotes(ByRef Stmt As String)
        Dim I As Integer = 0
        Dim CH As String = ""
        For I = 1 To Stmt.Length
            CH = Mid(Stmt, I, 1)
            If CH = "'" Then
                Mid(Stmt, I, 1) = "`"
            End If
        Next
    End Sub

    ''' <summary>
    ''' xes the trace.
    ''' </summary>
    ''' <param name="StmtID">The statement identifier.</param>
    ''' <param name="PgmName">Name of the PGM.</param>
    ''' <param name="Stmt">The statement.</param>
    Public Sub xTrace(ByVal StmtID As Integer, ByVal PgmName As String, ByVal Stmt As String)

        If Stmt.Contains("Failed to save search results") Then
            Return
        End If
        If Stmt.Contains("Column names in each table must be unique") Then
            Return
        End If
        If Stmt.Contains("clsArchiver:ArchiveQuickRefItems") Then
            Return
        End If

        Try
            FixSingleQuotes(Stmt)
            Dim S As String = ""
            PgmName = UTIL.RemoveSingleQuotes(PgmName)
            S = "INSERT INTO PgmTrace (StmtID ,PgmName, Stmt) VALUES(" & StmtID & ", '" & PgmName & "','" & Stmt & "')"
            Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
            If b = False Then
                ''Session("ErrMsg") = "StmtId Call: " + 'Session("ErrMsg")
                ''Session("ErrStack") = "StmtId Call Stack: " + ''Session("ErrStack")
            End If
        Catch ex As Exception

            If ddebug Then Debug.Print(ex.Message)
            If gClipBoardActive = True Then Console.WriteLine(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ' xTrace : 1907 : ", ex)

        End Try

    End Sub

    ''' <summary>
    ''' Clears the restore queue.
    ''' </summary>
    ''' <param name="gGateWayID">The g gate way identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ClearRestoreQueue(gGateWayID As Integer, UserID As String) As Boolean

        Dim rsData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        Try
            Dim S As String = "Delete from RestoreQueue where UserID = '" & UserID & "'"
            Dim b As Boolean = Me.ExecuteSqlNewConn(S, CS, False)
            Return b
        Catch ex As Exception

            If ddebug Then Debug.Print(ex.Message)
            If gClipBoardActive = True Then Console.WriteLine(ex.Message)
            LOG.WriteToArchiveLog("ClearRestoreQueue : ' xTrace : 5567 : ", ex)
            Return False
        End Try
    End Function

    ''' <summary>
    ''' Remotes the trace.
    ''' </summary>
    ''' <param name="StmtID">The statement identifier.</param>
    ''' <param name="PgmName">Name of the PGM.</param>
    ''' <param name="Stmt">The statement.</param>
    Public Sub RemoteTrace(ByVal StmtID As Integer, ByVal PgmName As String, ByVal Stmt As String)

        If Stmt.Contains("Failed to save search results") Then
            Return
        End If
        If Stmt.Contains("Column names in each table must be unique") Then
            Return
        End If
        If Stmt.Contains("clsArchiver:ArchiveQuickRefItems") Then
            Return
        End If

        'Dim CS As String = System.Configuration.ConfigurationManager.AppSettings("DEBUGREPO")
        Dim CS As String = getRepoConnStr()
        Try
            FixSingleQuotes(Stmt)
            Dim S As String = ""
            PgmName = UTIL.RemoveSingleQuotes(PgmName)
            S = "INSERT INTO PgmTrace (StmtID ,PgmName, Stmt) VALUES(" & StmtID & ", '" & PgmName & "','" & Stmt & "')"
            Dim b As Boolean = Me.ExecuteSqlNewConn(S, CS, False)
            If b = False Then
                ''Session("ErrMsg") = "StmtId Call: " + 'Session("ErrMsg")
                ''Session("ErrStack") = "StmtId Call Stack: " + ''Session("ErrStack")
            End If
        Catch ex As Exception

            If ddebug Then Debug.Print(ex.Message)
            If gClipBoardActive = True Then Console.WriteLine(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ' xTrace : 1907 : ", ex)

        End Try

    End Sub

    ''' <summary>
    ''' Zeroes the trace.
    ''' </summary>
    Sub ZeroTrace()
        Dim S As String = ""
        S = "delete from PgmTrace "
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        If b = False Then
            ''Session("ErrMsg") = "ZeroTrace Call: " + 'Session("ErrMsg")
            ''Session("ErrStack") = "ZeroTrace Call Stack: " + ''Session("ErrStack")
            'Response.Redirect("frmErrDisplay.aspx")
        End If
    End Sub

    ''' <summary>
    ''' Zeroizes the email to delete.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    Sub ZeroizeEmailToDelete(ByVal Userid As String)
        Dim S As String = ""
        S = "delete from EmailToDelete where UserID = '" + Userid + "'"
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        If b = False Then
            ''Session("ErrMsg") = "ZeroTrace Call: " + 'Session("ErrMsg")
            ''Session("ErrStack") = "ZeroTrace Call Stack: " + ''Session("ErrStack")
            'Response.Redirect("frmErrDisplay.aspx")
        End If
    End Sub

    ''' <summary>
    ''' Logs the entry new.
    ''' </summary>
    ''' <param name="IPADDR">The ipaddr.</param>
    ''' <returns>System.Int32.</returns>
    Public Function LogEntryNew(ByVal IPADDR As String) As Integer

        Dim NextKey As String = getNextKey("LOGINS", "LoginTrackingNbr")
        Dim S As String = ""

        S = S + "INSERT INTO [Logins]"
        S = S + "([LoginID]"
        S = S + ",[LoginDate]"
        S = S + ",[LoginTrackingNbr]"
        S = S + ",[Duration]"
        S = S + ",[IPAddress])"
        S = S + "VALUES( "
        S = S + "'VISITOR'"
        S = S + ",getdate()"
        S = S + "," + NextKey
        S = S + ",getdate()"
        S = S + ",'" + IPADDR + "')"

        Dim b As Boolean = ExecuteSqlNoTx(S)
        If b Then
            Return CInt(NextKey)
        Else
            Return -1
        End If

    End Function

    ''' <summary>
    ''' Logs the entry update.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="LoginTrackingNbr">The login tracking NBR.</param>
    Public Sub LogEntryUpdate(ByVal UID As String, ByVal LoginTrackingNbr As Integer)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        If UID = Nothing Then
            If Not LoginTrackingNbr = Nothing Then
                LogEntryUpdate(LoginTrackingNbr)
            End If
            Return
        End If

        If UID.Length = 0 Then
            Return
        End If

        Dim S As String = ""

        S = S + "UPDATE [Logins]"
        S = S + " SET [LoginID] = '" + UID + "'"
        S = S + " ,[Duration] = getdate()      "
        S = S + " WHERE (LoginTrackingNbr = " + Str(LoginTrackingNbr) + ") "

        Dim b As Boolean = ExecuteSqlNoTx(S)

    End Sub

    ''' <summary>
    ''' Logs the entry update.
    ''' </summary>
    ''' <param name="LoginTrackingNbr">The login tracking NBR.</param>
    Public Sub LogEntryUpdate(ByVal LoginTrackingNbr As Integer)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""

        S = S + "UPDATE [Logins]"
        S = S + " SET [Duration] = getdate()      "
        S = S + " WHERE (LoginTrackingNbr = " + Str(LoginTrackingNbr) + ") "

        Dim b As Boolean = ExecuteSqlNoTx(S)

    End Sub

    ''' <summary>
    ''' Inserts the email.
    ''' </summary>
    ''' <param name="EmailFrom">The email from.</param>
    ''' <param name="EmailTo">The email to.</param>
    ''' <param name="EmailSubj">The email subj.</param>
    ''' <param name="EmailCC">The email cc.</param>
    ''' <param name="EmailBCC">The email BCC.</param>
    ''' <param name="EMailBody">The e mail body.</param>
    ''' <param name="EMailBody2">The e mail body2.</param>
    ''' <param name="EmailDate">The email date.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function InsertEmail(ByVal EmailFrom As String, ByVal EmailTo As String, ByVal EmailSubj As String, ByVal EmailCC As String, ByVal EmailBCC As String, ByVal EMailBody As String, ByVal EMailBody2 As String, ByVal EmailDate As Date) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim S As String = ""
        S = S + " INSERT INTO [Emails]"
        S = S + " ([EmailTo]"
        S = S + " ,[EmailFrom]"
        S = S + " ,[EmailSubj]"
        S = S + " ,[EmailBody]"
        S = S + " ,[EmailBody2]"
        S = S + " ,[EmailDate]"
        S = S + " ,[EmailCC]"
        S = S + " ,[EmailBcc])"
        S = S + " VALUES"
        S = S + " ('" + EmailTo + "','"
        S = S + EmailFrom + "','"
        S = S + EmailSubj + "','"
        S = S + EMailBody + "','"
        S = S + EMailBody2 + "','"
        S = S + EmailDate.ToString + "','"
        S = S + EmailCC + "','"
        S = S + EmailBCC + "')"

        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        Return b
    End Function

    ''' <summary>
    ''' Adds the upload file data.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="UploadedBy">The uploaded by.</param>
    Public Sub AddUploadFileData(ByVal FQN As String, ByVal UploadedBy As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = ckDatasourceExists(FQN, UploadedBy)
        If Not B Then
            InsertFileAudit(FQN, UploadedBy)
        End If
    End Sub

    ''' <summary>
    ''' Inserts the file audit.
    ''' </summary>
    ''' <param name="FN">The function.</param>
    ''' <param name="UploadedBy">The uploaded by.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function InsertFileAudit(ByVal FN As String, ByVal UploadedBy As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim b As Boolean = False
        Dim s As String = ""

        b = ckDatasourceExists(FN, UploadedBy)

        If b Then
            Return True
        End If

        s = s + " INSERT INTO [FileUpload] ([FileName],[UploadedBy]) VALUES( "
        s = s + "'" + FN + "',"
        s = s + "'" + UploadedBy + "')"

        b = ExecuteSqlNoAudit(s)

        If Not b Then
            Console.WriteLine("Audit Failed: " + s)
        End If

        Return b

    End Function

    ''' <summary>
    ''' Sets the upload success true.
    ''' </summary>
    ''' <param name="UploadID">The upload identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function setUploadSuccessTrue(ByVal UploadID As Integer) As Boolean

        Dim b As Boolean = False
        Dim s As String = ""

        s = " Update FileUpload set SuccessfulLoad = 1 where UploadID = " & UploadID
        b = ExecuteSqlNoAudit(s)
        s = " Update FileUpload set EndTime = getdate() where UploadID = " & UploadID
        b = ExecuteSqlNoAudit(s)
        s = " update FileUpload set ElapsedTime = DATEDIFF(second, StartTime, GETDATE()) where UploadID = " & UploadID
        b = ExecuteSqlNoAudit(s)
        If Not b Then
            Console.WriteLine("Audit Failed: " + s)
        End If
        Return b
    End Function

    ''' <summary>
    ''' Gets the last upload time.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function GetLastUploadTime() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        CloseConn()
        CkConn()
        Dim S As String = ""
        S = "Select max(UploadID) from FileUpload where SuccessfulLoad = 1 "
        Dim rsData As SqlDataReader = Nothing
        Dim I As Integer = 0
        Dim iStr As String = ""
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            iStr = rsData.GetValue(0).ToString
            rsData.Close()
            rsData = Nothing
        Else
            rsData.Close()
            rsData = Nothing
        End If

        If iStr.Length = 0 Then
            Return "No file has been loaded as of now..."
        End If

        Dim FN As String = ""
        Dim ET As String = ""
        GetElapsedTime(iStr, FN, ET)

        If FN.Length > 0 Then
            Return "The last upload, '" + FN + "', took " + ET + " seconds."
        Else
            Return "The current load could possibly take several minutes..."
        End If

    End Function

    ''' <summary>
    ''' Gets the elapsed time.
    ''' </summary>
    ''' <param name="UploadID">The upload identifier.</param>
    ''' <param name="FN">The function.</param>
    ''' <param name="ET">The et.</param>
    Sub GetElapsedTime(ByVal UploadID As String, ByRef FN As String, ByRef ET As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Try
            Dim S As String = ""
            S = "Select FileName, ElapsedTime from FileUpload where UploadID = " + UploadID
            Dim rsData As SqlDataReader = Nothing
            Dim I As Integer = 0
            Dim iStr As String = ""
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                FN = rsData.GetValue(0).ToString
                ET = rsData.GetValue(1).ToString
                rsData.Close()
                rsData = Nothing
            Else
                rsData.Close()
                rsData = Nothing
            End If
        Catch ex As Exception
            FN = ""
            ET = ""
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetElapsedTime : 2043 : ", ex)
        End Try
    End Sub

    ''' <summary>
    ''' Cks the attribute exists.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    ''' <param name="PropVal">The property value.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckAttributeExists(ByVal AttributeName As String, ByVal PropVal As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim s As String = "Select count(*) from Attribute where AttributeName = '" + AttributeName + "'"
        Dim Cnt As Integer
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()

        rsData.Read()
        Cnt = rsData.GetInt32(0)
        If Cnt > 0 Then
            b = True
        Else
            b = False
        End If
        rsData.Close()

        Return b
    End Function

    ''' <summary>
    ''' Cks the email folder exist.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="ContainerName">Name of the container.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckEmailFolderExist(UserID As String, FolderID As String, FolderName As String, ContainerName As String) As Boolean

        Dim s As String = "select count(*) from EmailFolder where [UserID] = '" + UserID + "' and [FolderID] = '" + FolderID + "' and [FolderName] = '" + FolderName + "' and [ContainerName] = '" + ContainerName + "' "
        Dim Cnt As Integer
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open()
        Dim command As New SqlCommand(s, CONN)
        rsData = command.ExecuteReader()

        Try
            rsData.Read()
            Cnt = rsData.GetInt32(0)
            If Cnt > 0 Then
                b = True
            Else
                b = False
            End If
            rsData.Close()
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: " + ex.Message + environment.NewLine + s)
        End Try

        Return b

    End Function

    '' <summary>
    '' Determines of a file has alraedy been loaded into the system or not.
    '' </summary>
    '' <param name="FN"></param>
    '' <returns>TRUE if the file has been loaded, FALSE if not.</returns>
    '' <remarks></remarks>
    ''' <summary>
    ''' Cks the datasource exists.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="UID">The uid.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckDatasourceExists(ByVal FQN As String, ByVal UID As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        CloseConn()
        CkConn()

        Dim Cnt As Integer
        Dim s As String = "Select count(*) FROM DataSource "
        s = s + " where FQN = '" + FQN + "' and UserID = '" + UID + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()

        rsData.Read()
        Cnt = rsData.GetInt32(0)
        If Cnt > 0 Then
            b = True
        Else
            b = False
        End If
        rsData.Close()

        Return b

    End Function

    ''' <summary>
    ''' Gets the table count.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getTableCount(ByVal TblName As String) As Integer
        Try
            Dim S As String = "Select  count(*) FROM " + TblName
            CloseConn()
            CkConn()
            Dim Cnt As Integer
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            Cnt = rsData.GetInt32(0)

            rsData.Close()

            Return Cnt
        Catch ex As Exception
            ' xTrace(12306, "clsDataBase:getTableCount" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getTableCount : 2083 : ", ex)

            Return 0
        End Try

    End Function

    ''' <summary>
    ''' is the count.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iCount(ByVal S As String) As Integer
        SyncLock Me
            Try

                Dim Cnt As Integer
                Dim rsData As SqlDataReader = Nothing
                Dim b As Boolean = False
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
                rsData.Read()
                Cnt = rsData.GetInt32(0)
                rsData.Close()
                rsData = Nothing
                Return Cnt
            Catch ex As Exception
                ' xTrace(12306, "clsDataBase:iCount" + ex.Message)
                LOG.WriteToArchiveLog("ERROR 1993.21: ", ex)
                LOG.WriteToArchiveLog("clsDatabaseARCH : iCount : 2054 : ", ex)
                Return -1
            End Try
        End SyncLock
    End Function

    ''' <summary>
    ''' is the content of the count.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iCountContent(ByVal S As String) As Integer

        Dim I As Integer = 0
        Dim J As Integer = 0
        Dim K As Integer = 0
        Dim S1 As String = ""
        Dim S2 As String = ""
        S = S.Trim
        Dim NewSql As String = ""
        Dim A As String() = S.Split(CChar(environment.NewLine))
        For I = 0 To UBound(A)
            If InStr(A(I), "and KEY_TBL.RANK", CompareMethod.Text) > 0 Then
                'Console.WriteLine(A(I))
            Else
                NewSql = NewSql + A(I) + environment.NewLine
            End If
            S = NewSql
        Next

        If InStr(1, S, "FROM ", CompareMethod.Text) > 0 Then
            I = InStr(1, S, "select", CompareMethod.Text)
            'I = I + 5
            'I = InStr(I, S, "select", CompareMethod.Text)
            If I <= 0 Then
                Return -1
            End If
            J = InStr(1, S, "FROM ", CompareMethod.Text)
            S1 = ""
            S2 = Mid(S, J)
            Dim SS As String = "Select count(*) " + S2
            J = InStr(1, SS, "order by", CompareMethod.Text)
            If J > 0 Then
                SS = Mid(SS, 1, J - 1)
            End If
            S = SS
            'Clipboard.Clear()
            'Clipboard.SetText(S)
            'Console.WriteLine(S)
        Else
            Return 1
        End If

        K = InStr(S, "order by", CompareMethod.Text)
        If K > 0 Then
            S = Mid(S, 1, K - 1)
        End If

        Try

            CloseConn()
            CkConn()
            Dim Cnt As Integer
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            Cnt = rsData.GetInt32(0)
            rsData.Close()
            rsData = Nothing
            Return Cnt
        Catch ex As Exception
            ' xTrace(12309, "clsDataBase:iCountContent" + ex.Message)
            LOG.WriteToArchiveLog("Warning - clsDatabaseARCH : iCountContent : 2150 : ", ex)
            Return 1
        End Try

    End Function

    ''' <summary>
    ''' Gets the ss count data source files.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns>System.String.</returns>
    Public Function getSSCountDataSourceFiles(ByVal SourceName As String, ByVal CRC As String) As String
        Dim SourceGuid As String = ""
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)

            Dim S As String = "Select top 1 SourceGuid from DataSource"
            S = S + " where "
            S = S + " [SourceName] = '" + SourceName + "'"
            S = S + " and CRC = " + CRC + ""
            Try
                CloseConn()
                CkConn()

                Dim rsData As SqlDataReader = Nothing
                Dim b As Boolean = False
                Dim CS As String = getRepoConnStr()
                Dim CONN As New SqlConnection(CS)
                CONN.Open()
                Dim command As New SqlCommand(S, CONN)

                rsData = command.ExecuteReader()
                rsData.Read()
                SourceGuid = rsData.GetValue(0).ToString
                rsData.Close()
            Catch ex As Exception
                Return ""
            End Try
        Catch ex As Exception
            ' xTrace(12309, "clsDataBase:getCountDataSourceFiles" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2162a : ", ex)
            Return ""
        End Try
        Return SourceGuid
    End Function

    ''' <summary>
    ''' Hexadecimals the string to binary.
    ''' </summary>
    ''' <param name="hexString">The hexadecimal string.</param>
    ''' <returns>System.String.</returns>
    Function HexStringToBinary(ByVal hexString As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'hexString = "0x" + hexString
        Dim num As Integer = Integer.Parse(hexString, NumberStyles.HexNumber)
        Return Convert.ToString(num, 2)
    End Function
    'Function BinaryToHexString(ByVal BinData As Byte()) As String
    '    'hexString = "0x" + hexString
    '    Dim num As Integer = Integer.Parse(BinData, NumberStyles.HexNumber)
    '    Return Convert.ToString(num, 2)
    'End Function

    ''' <summary>
    ''' Gets the count data source files.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="HexHash">The hexadecimal hash.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getCountDataSourceFiles(ByVal SourceName As String, HexHash As String) As Integer
        Dim CNT As Integer = -1
        'If Not HexHash.Contains("0x") Then
        '    HexHash = "0x" + HexHash
        'End If
        ''Dim HexStr As String = HexStringToBinary(HexHash)
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)
            Dim S As String = "Select count(*) FROM DataSource where SourceName = '" + SourceName + "' and ImageHash = '" + HexHash + "'; "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            CNT = rsData.GetInt32(0)
            rsData.Close()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return CNT
    End Function

    Public Function getSourceGuidByImageHash(ByVal SourceName As String, HexHash As String) As String
        Dim SourceGuid As String = ""
        'If Not HexHash.Contains("0x") Then
        '    HexHash = "0x" + HexHash
        'End If
        ''Dim HexStr As String = HexStringToBinary(HexHash)
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)
            Dim S As String = "Select SourceGuid FROM DataSource where SourceName = '" + SourceName + "' and ImageHash = '" + HexHash + "'; "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            SourceGuid = rsData.GetValue(0).ToString
            rsData.Close()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return SourceGuid
    End Function


    Public Function ckZipchildExists(ParentGuid As String, ByVal SourceName As String, HexHash As String) As Integer
        Dim CNT As Integer = -1
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)
            Dim S As String = "Select count(*) FROM DataSource where SourceName = '" + SourceName + "' and ImageHash = '" + HexHash + "' and SourceGuid = '+ParentGuid+' "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            CNT = rsData.GetInt32(0)
            rsData.Close()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return CNT
    End Function


    ''' <summary>
    ''' Updates the data source file information.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <param name="Imagehash">The imagehash.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function UpdateDataSourceFileInfo(FQN As String, SourceGuid As String, FileLength As Integer, Imagehash As String) As Boolean

        Dim b As Boolean = True
        Dim SourceName As String = ""
        'Dim Imagehash As String = ""
        Dim CRC As String = ""
        Dim LastAccessDate As DateTime = Now
        Dim LastWriteTime As DateTime = Now
        Dim SourceTypeCode As String = ""
        Dim OriginalFileType As String = ""
        Dim MachineID As String = ""
        Dim RecLen As String = ""
        Dim RecHash As String = ""
        Dim FI As New FileInfo(FQN)

        Try
            SourceName = FI.Name
            SourceTypeCode = getProcessAsExt(FI.Extension)
            Imagehash = ENC.GenerateSHA512HashFromFile(FQN)
            If Imagehash.Length < 10 Then
                Return False
            End If
            CRC = Imagehash
            LastAccessDate = FI.LastAccessTime
            LastWriteTime = FI.LastWriteTime
            OriginalFileType = FI.Extension
            MachineID = Environment.MachineName
            RecLen = FileLength
            RecHash = CRC
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR  UpdateDataSourceFileInfo 022: " + ex.Message)
        Finally
            FI = Nothing
        End Try

        Dim S As String = ""

        S = "update DataSource
        set  [SourceName] = @SourceName,
            [Imagehash] = @Imagehash,
            [CRC] = @Imagehash,
            [LastAccessDate] = @LastAccessDate,
            [LastWriteTime] = @LastWriteTime,
            [SourceTypeCode] = @SourceTypeCode,
            [OriginalFileType] = @OriginalFileType,
            [MachineID] = @MachineID,
            [FileLength] = @FileLength,
            [RecLen] = @FileLength,
            [RecHash] = @Imagehash
        where SourceGuid = @SourceGuid  "

        Dim ConnStr As String = setConnStr()
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If
        LL = 35
        Dim CMD As New SqlCommand()
        CMD.CommandType = CommandType.StoredProcedure
        Try
            CMD.Connection = CONN
            CMD.CommandText = "UpdateDataSourceImage"
            CMD.CommandText = S
            CMD.CommandType = CommandType.Text
            Using CONN
                Using CMD

                    CMD.Parameters.Add(New SqlParameter("@SourceName", SourceName))
                    CMD.Parameters.Add(New SqlParameter("@Imagehash", Imagehash))
                    CMD.Parameters.Add(New SqlParameter("@CRC", Imagehash))
                    CMD.Parameters.Add(New SqlParameter("@LastAccessDate", LastAccessDate))
                    CMD.Parameters.Add(New SqlParameter("@LastWriteTime", LastWriteTime))
                    CMD.Parameters.Add(New SqlParameter("@SourceTypeCode", SourceTypeCode))
                    CMD.Parameters.Add(New SqlParameter("@OriginalFileType", OriginalFileType))
                    CMD.Parameters.Add(New SqlParameter("@MachineID", MachineID))
                    CMD.Parameters.Add(New SqlParameter("@FileLength", FileLength))
                    CMD.Parameters.Add(New SqlParameter("@RecLen", FileLength))
                    CMD.Parameters.Add(New SqlParameter("@RecHash", Imagehash))
                    CMD.Parameters.Add(New SqlParameter("@SourceGuid", SourceGuid))

                    CMD.ExecuteNonQuery()
                End Using
            End Using
            b = True
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 721x UpdateDataSourceFileInfo 00: " + ex.Message)
            LOG.WriteToArchiveLog("[SourceName] " + SourceName.Length.ToString)
            LOG.WriteToArchiveLog("[Imagehash] " = Imagehash.Length.ToString)
            LOG.WriteToArchiveLog("[CRC] " = Imagehash.Length.ToString)
            LOG.WriteToArchiveLog("[SourceTypeCode] " = SourceTypeCode.Length.ToString)
            LOG.WriteToArchiveLog("[OriginalFileType] " = OriginalFileType.Length.ToString)
            LOG.WriteToArchiveLog("[MachineID] " = MachineID.Length.ToString)
            LOG.WriteToArchiveLog("[RecHash] " = Imagehash.Length.ToString)
            b = False
        End Try

        Return b

    End Function

    ''' <summary>
    ''' Updates the souce image.
    ''' </summary>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="Imagehash">The imagehash.</param>
    ''' <param name="RetentionExpirationDate">The retention expiration date.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function UpdateSouceImage(MachineID As String, FQN As String, Imagehash As String, RetentionExpirationDate As DateTime) As Boolean

        If FQN.Contains("'") Then
            FQN = FQN.Replace("''", "'")
        End If

        Dim b As Boolean = False
        Dim ConnStr As String = setConnStr()
        Dim MySql As String = ""
        Dim SourceImage As Byte() = IO.File.ReadAllBytes(FQN)
        Dim ImageLen As Integer = SourceImage.Length

        MySql = "UPDATE DataSource SET "
        MySql += " SourceImage = @SourceImage "
        MySql += " , Imagehash = @Imagehash"
        MySql += " , LastAccessDate = getdate()"
        MySql += " , RetentionExpirationDate = @RetentionExpirationDate"
        MySql += " , ImageLen = @ImageLen"
        MySql += " where MachineID = @MachineID and FQN = @FQN"

        Try
            Using connection As New SqlConnection(ConnStr)
                If connection.State.Equals(connection.State.Closed) Then
                    connection.Open()
                End If
                Using Command As New SqlCommand(MySql, connection)
                    Command.Parameters.Add(New SqlParameter("@MachineID", MachineID))
                    Command.Parameters.Add(New SqlParameter("@FQN", FQN))
                    Command.Parameters.Add(New SqlParameter("@Imagehash", Imagehash))
                    Command.Parameters.Add(New SqlParameter("@SourceImage", SourceImage))
                    Command.Parameters.Add(New SqlParameter("@RetentionExpirationDate", RetentionExpirationDate))
                    Command.Parameters.Add(New SqlParameter("@ImageLen", ImageLen))

                    Command.ExecuteNonQuery()
                End Using
            End Using
            LOG.WriteToDBUpdatesLog("NOTICE Successfully updated SourceImage for <" + FQN + ">")
            b = True
        Catch ex As Exception
            LOG.WriteToArchiveLog("FATAL ERROR :UpdateSouceImage 22.345.22 - Failed to add source image." + environment.NewLine + MySql + Environment.NewLine + ex.Message)
            b = False
        End Try
        Return b

    End Function

    ''' <summary>
    ''' Updates the souce image.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="RetentionYears">The retention years.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function UpdateSouceImage(SourceGuid As String, FQN As String, RetentionYears As Integer) As Boolean

        If FQN.Contains("'") Then
            FQN = FQN.Replace("''", "'")
        End If

        If Not File.Exists(FQN) Then
            LOG.WriteToDBUpdatesLog("ERROR 626x: FIle Missing 00A: " + FQN)
            Return False
        End If

        Dim B As Boolean = True
        Try
            Dim FI As New FileInfo(FQN)

            Dim LastWriteTime As DateTime = FI.LastWriteTime
            Dim LastAccessTime As DateTime = FI.LastAccessTime
            Dim FLen As Int64 = FI.Length

            FI = Nothing

            Dim SourceImage As Byte() = File.ReadAllBytes(FQN)
            Dim CMD As New SqlCommand
            Dim connString As String = getRepoConnStr()
            Dim conn As New SqlConnection(connString)
            Dim RetentionExpirationDate As DateTime = DateAdd("yyyy", RetentionYears, Now)

            MySql = "update DataSource set RetentionExpirationDate = @RetentionExpirationDate, FileLength = @FileLength, LastAccessDate = @LastAccessDate, LastWriteTime = @LastWriteTime, SourceImage = @SourceImage
                where SourceGuid = @SourceGuid"
            Try
                conn.Open()
                Using conn
                    I = 0
                    CMD.Connection = conn
                    CMD.CommandText = MySql
                    CMD.CommandType = CommandType.Text
                    Using conn
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@RetentionExpirationDate", RetentionExpirationDate))
                            CMD.Parameters.Add(New SqlParameter("@FileLength", FLen))
                            CMD.Parameters.Add(New SqlParameter("@LastAccessDate", LastAccessTime))
                            CMD.Parameters.Add(New SqlParameter("@LastWriteTime", LastWriteTime))
                            CMD.Parameters.Add(New SqlParameter("@SourceImage", SourceImage))
                            CMD.Parameters.Add(New SqlParameter("@SourceGuid", SourceGuid))

                            CMD.CommandText = MySql
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End Using
                B = True
            Catch ex As Exception
                LOG.WriteToDBUpdatesLog("ERROR 44x: UpdateSouceImage 01: " + ex.Message + environment.NewLine + MySql)
                LOG.WriteToArchiveLog("ERROR 44x: UpdateSouceImage 01: " + ex.Message + environment.NewLine + MySql)
                B = False
            End Try

        Catch ex As Exception
            LOG.WriteToDBUpdatesLog("ERROR 44x: UpdateSouceImage 00A: " + ex.Message)
            LOG.WriteToArchiveLog("ERROR 44x: UpdateSouceImage 00A: " + ex.Message)
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Cks the file exist in repo.
    ''' </summary>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function ckFileExistInRepo(MachineID As String, ByVal FQN As String) As List(Of String)

        Dim BFound As Boolean = False
        Dim ListOfGuids As New List(Of String)
        Dim SourceGuid As String = ""

        Try
            FQN = FQN.Replace("''", "'")
            FQN = FQN.Replace("'", "''")
            Dim S As String = "select SOurceGuid from DataSource where MachineID = '" + MachineID + "' and  FQN = '" + FQN + "' "
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            Dim FOund As Boolean = False
            rsData = command.ExecuteReader()
            Using command
                Using CONN
                    Using rsData
                        'rsData.Read()
                        'If rsData.HasRows Then
                        Do While rsData.Read()
                            SourceGuid = rsData.GetValue(0).ToString
                            ListOfGuids.Add(SourceGuid)
                            rsData.Read()
                            BFound = True
                        Loop
                        'End If
                    End Using
                End Using
            End Using

        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:getCountDataSourceFiles" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return ListOfGuids
    End Function

    ''' <summary>
    ''' Gets the count data source files.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="WebPagePublishDate">The web page publish date.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getCountDataSourceFiles(ByVal SourceName As String, WebPagePublishDate As Date) As Integer
        Dim CNT As Integer = -1
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)

            Dim S As String = "Select  count(*) FROM DataSource where SourceName = '" + SourceName + "' and WebPagePublishDate = '" + WebPagePublishDate.ToString + "' "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            CNT = rsData.GetInt32(0)
            rsData.Close()
        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:getCountDataSourceFiles" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return CNT
    End Function

    ''' <summary>
    ''' Gets the count RSS file.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="WebPagePublishDate">The web page publish date.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getCountRssFile(ByVal SourceName As String, WebPagePublishDate As String) As Integer
        Dim CNT As Integer = -1
        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)

            Dim S As String = "Select  count(*) FROM DataSource where SourceName = '" + SourceName + "' and WebPagePublishDate = '" + WebPagePublishDate + "' "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            rsData.Read()
            CNT = rsData.GetInt32(0)
            rsData.Close()
        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:getCountDataSourceFiles" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return CNT
    End Function

    ''' <summary>
    ''' Gets the maximum data source version NBR.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>System.Int32.</returns>
    Function GetMaxDataSourceVersionNbr(ByVal UserID As String, ByVal FQN As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            FQN = UTIL.RemoveSingleQuotes(FQN)

            Dim S As String = "Select  max ([VersionNbr]) FROM DataSource where FQN = '" + FQN + "' and DataSourceOwnerUserID = '" + UserID + "'"
            CloseConn()
            CkConn()
            Dim Cnt As Integer

            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()

            Try
                If rsData.HasRows Then
                    rsData.Read()
                    Cnt = rsData.GetInt32(0)
                Else
                    Cnt = -1
                End If
            Catch ex As Exception
                Cnt = -1
            End Try

            If Not rsData.IsClosed Then
                rsData.Close()
            End If
            rsData = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()

            Return Cnt
        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:GetMaxDataSourceVersionNbr" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetMaxDataSourceVersionNbr : 2157 : ", ex)
            Return 0
        End Try
    End Function

    ''' <summary>
    ''' Gets the maximum data source version NBR.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <returns>System.Int32.</returns>
    Function GetMaxDataSourceVersionNbr(ByVal SourceName As String, ByVal CRC As String, ByVal FileLength As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)

            Dim S As String = "Select  max ([VersionNbr]) FROM DataSource  where  SourceName = '" + SourceName + "' and FIleLength = " + FileLength + " and CRC = " + CRC + " "
            CloseConn()
            CkConn()
            Dim Cnt As Integer

            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

            If rsData.HasRows Then
                rsData.Read()
                Cnt = rsData.GetInt32(0)
            Else
                Cnt = -1
            End If

            rsData.Close()
            rsData = Nothing

            Return Cnt
        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:GetMaxDataSourceVersionNbr" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetMaxDataSourceVersionNbr : 2157 : ", ex)
            Return 0
        End Try
    End Function

    ''' <summary>
    ''' Gets the unique identifier.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getGuid() As String
        Dim MyGuid As Guid = Guid.NewGuid()
        Return MyGuid.ToString
    End Function

    '' <summary>
    '' Bilds the sorted lists for blazing fast lookup speeds.
    '' </summary>
    '' <remarks></remarks>
    ''' <summary>
    ''' Populates the sorted lists.
    ''' </summary>
    Public Sub PopulateSortedLists()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        PopulateProjectSortedList()
        PopulateProjectTeamSortedList()
    End Sub

    '' <summary>
    '' The subroutine PopulateProjectSortedList populates a sorted list with all projects from the
    '' input Excel spreadsheet. This list allows us to verify that a project exists without having to
    '' access the database thus giving us extreme speed.
    '' </summary>
    '' <remarks></remarks>
    ''' <summary>
    ''' Populates the project sorted list.
    ''' </summary>
    Sub PopulateProjectSortedList()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        Dim PID As Integer = 0
        Dim s As String = "Select RomID, ProjectID from Project"
        Dim rsData As SqlDataReader = Nothing

        slProjects.Clear()

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then
            Do While rsData.Read()
                Dim RomID As String = rsData.GetValue(0).ToString
                Dim ProjectID As Integer = rsData.GetInt32(1)
                slProjects.Add(ProjectID, RomID)
            Loop
        Else
            slProjects.Add(-1, "  New Project")
        End If

        rsData.Close()
    End Sub

    ''' <summary>
    ''' Populates the project team sorted list.
    ''' </summary>
    Sub PopulateProjectTeamSortedList()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        slProjectTeams.Clear()
        Dim PID As Integer = 0
        Dim s As String = "Select [ProjectTeamIdentifier] +'|'+ cast([ProjectID] as varchar(50)), ProjectTeamID FROM [ProjectTeam]"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then
            Do While rsData.Read()
                Dim TeamKey As String = rsData.GetValue(0).ToString
                Dim ProjectTeamID As Integer = rsData.GetInt32(1)
                slProjectTeams.Add(ProjectTeamID, TeamKey)
            Loop
        Else
            slProjectTeams.Add(-1, "XXXX")
        End If

        rsData.Close()
    End Sub

    ''' <summary>
    ''' Populates the metric period sorted list.
    ''' </summary>
    Sub PopulateMetricPeriodSortedList()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        slMetricPeriods.Clear()
        Dim PID As Integer = 0
        Dim s As String = "Select cast([MetricPeriod] as varchar(50)) + '|' + cast([ProjectTeamID] as varchar(50)), [MetricRowGuid] FROM [MetricPeriodData]"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then
            Do While rsData.Read()
                Dim MetricKey As String = rsData.GetValue(0).ToString
                Dim MetricID As Integer = rsData.GetInt32(1)
                slMetricPeriods.Add(MetricID, MetricKey)
            Loop
        Else
            slMetricPeriods.Add(-1, "~~~~")
        End If

        rsData.Close()
    End Sub

    ''' <summary>
    ''' Gets the metric period identifier by key.
    ''' </summary>
    ''' <param name="MetricPeriod">The metric period.</param>
    ''' <param name="ProjectTeamID">The project team identifier.</param>
    ''' <returns>System.String.</returns>
    Function getMetricPeriodIdByKey(ByVal MetricPeriod As String, ByVal ProjectTeamID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        slMetricPeriods.Clear()
        Dim PID As Integer = 0
        Dim s As String = ""
        Dim tKey As String = ""

        s = s + "Select [MetricRowGuid] "
        s = s + "FROM [MetricPeriodData]"
        s = s + "where MetricPeriod= '" + MetricPeriod + "'"
        s = s + "and ProjectTeamID = " + ProjectTeamID
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then
            Do While rsData.Read()
                tKey = rsData.GetValue(0).ToString
            Loop
        Else
            tKey = ""
        End If

        rsData.Close()
        Return tKey
    End Function

    ''' <summary>
    ''' Links the run identifier.
    ''' </summary>
    Sub LinkRunId()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim LoadID As Integer = 0
        Dim s As String = "Select max([UploadID]) FROM [FileUpload]"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then

            LoadID = rsData.GetInt32(0)

            rsData.Close()

            s = s + "update MetricPeriodData set UploadID = " & LoadID & " where UploadID is null"

            Dim b As Boolean = ExecuteSqlNoAudit(s)

        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If

    End Sub

    ''' <summary>
    ''' Gets the last upload identifier.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function getLastUploadID() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim LoadID As Integer = -1
        Dim s As String = "Select max([UploadID]) FROM [FileUpload]"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then

            LoadID = rsData.GetInt32(0)

            rsData.Close()

        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If

        Return LoadID

    End Function

    ''' <summary>
    ''' Gets the last project identifier.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function getLastProjectID() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim LoadID As Integer = -1
        Dim s As String = "Select max([ProjectID]) FROM [Project]"
        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
        rsData.Read()

        If rsData.HasRows Then

            LoadID = rsData.GetInt32(0)

            rsData.Close()

        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If

        Return LoadID

    End Function

    ''' <summary>
    ''' Cks the name of the excel col.
    ''' </summary>
    ''' <param name="ColName">Name of the col.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckExcelColName(ByVal ColName As String) As Boolean
        Dim B As Boolean = False
        Dim I As Int32 = Me.slExcelColNames.IndexOfKey(ColName)
        If I < 0 Then
            B = False
        Else
            B = True
        End If
        Return B
    End Function

    ''' <summary>
    ''' Populates the sorted lists.
    ''' </summary>
    ''' <param name="ListName">Name of the list.</param>
    ''' <param name="tKey">The t key.</param>
    ''' <param name="tDesc">The t desc.</param>
    Sub populateSortedLists(ByVal ListName As String, ByVal tKey As String, ByVal tDesc As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If


        'Public slGrowthPlatform As New SortedList
        'Public slOperatingGroup As New SortedList
        'Public slOperatingUnit As New SortedList
        'Public slGeography As New SortedList
        'Public slGeographicUnit As New SortedList
        'Public slClientServiceGroup As New SortedList
        'Public slDeliveryCenter As New SortedList
        'Public slTypeOfWork As New SortedList
        'Public slProjectTeamTypeOfWork As New SortedList
        'Public slSubmissionStatus As New SortedList

        If ListName.Equals("GrowthPlatform") Then
            slGrowthPlatform.Add(tKey, tDesc)
        ElseIf ListName.Equals("OperatingGroup") Then
            slOperatingGroup.Add(tKey, tDesc)
        ElseIf ListName.Equals("OperatingUnit") Then
            slOperatingUnit.Add(tKey, tDesc)
        ElseIf ListName.Equals("Geography") Then
            slGeography.Add(tKey, tDesc)
        ElseIf ListName.Equals("GeographicUnit") Then
            slGeographicUnit.Add(tKey, tDesc)
        ElseIf ListName.Equals("ClientServiceGroup") Then
            slClientServiceGroup.Add(tKey, tDesc)
        ElseIf ListName.Equals("DeliveryCenter") Then
            slDeliveryCenter.Add(tKey, tDesc)
        ElseIf ListName.Equals("TypeOfWork") Then
            slTypeOfWork.Add(tKey, tDesc)
        ElseIf ListName.Equals("ProjectTeamTypeOfWork") Then
            slProjectTeamTypeOfWork.Add(tKey, tDesc)
        ElseIf ListName.Equals("SubmissionStatus") Then
            slSubmissionStatus.Add(tKey, tDesc)
        ElseIf ListName.Equals("SubmittedBy") Then
            slSubmittedBy.Add(tKey, tDesc)
        End If
    End Sub

    ''' <summary>
    ''' Adds the lookup data.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="CodeCol">The code col.</param>
    ''' <param name="DescCol">The desc col.</param>
    ''' <param name="tCode">The t code.</param>
    ''' <param name="tDesc">The t desc.</param>
    Sub AddLookupData(ByVal TBL As String, ByVal CodeCol As String, ByVal DescCol As String, ByVal tCode As String, ByVal tDesc As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""

        populateSortedLists(TBL, tCode, tDesc)

        Dim b As Boolean = ItemExists(TBL, CodeCol, tCode, "S")

        If Not b Then
            S = ""
            S = S + " insert into " + TBL + " (" + CodeCol + "," + DescCol + ")"
            S = S + " values "
            S = S + " ('" + tCode + "','" + tDesc + "')"

            b = ExecuteSqlNewConn(S, False)

        End If

    End Sub

    ''' <summary>
    ''' Sets the configuration database.
    ''' </summary>
    ''' <param name="DbId">The database identifier.</param>
    Public Sub SetConfigDb(ByVal DbId As String)
        ConnectionStringID = DbId
    End Sub

    ''' <summary>
    ''' Gets the ds value.
    ''' </summary>
    ''' <param name="RS">The rs.</param>
    ''' <param name="I">The i.</param>
    ''' <returns>System.String.</returns>
    Function GetDsValue(ByVal RS As SqlDataReader, ByVal I As Integer) As String
        Dim tVal As String = RS.GetValue(I).ToString
        tVal = UTIL.RemoveSingleQuotes(tVal)
        Return tVal
    End Function

    ''' <summary>
    ''' Adds to sl.
    ''' </summary>
    ''' <param name="SL">The sl.</param>
    ''' <param name="S">The s.</param>
    ''' <param name="dups">The dups.</param>
    Sub AddToSL(ByRef SL As SortedList, ByVal S As String, ByRef dups As Integer)
        Try
            Dim I As Integer = SL.IndexOfKey(S)
            If I >= 0 Then
                dups = dups + 1
            Else
                SL.Add(S, S)
            End If
        Catch ex As Exception
            Console.WriteLine("Duplicate SQL statement, skipping and continuing.")
            dups = dups + 1
            LOG.WriteToArchiveLog("clsDatabaseARCH : AddToSL : 2351 : ", ex)
        End Try
    End Sub

    ''' <summary>
    ''' Sps the ck next identifier.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    Public Sub spCkNextID(ByVal ID As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim TimeTrk As Boolean = True
        Try
            CloseConn()
            CkConn()
            Dim command As SqlCommand = New SqlCommand("exec spCkNextID " + ID, gConn)
            command.CommandType = Data.CommandType.Text
            'command.CommandText = "spCkNextID " + ID
            command.CommandTimeout = 3600
            command.ExecuteNonQuery()
            command = Nothing
            gConn.Close()
        Catch ex As Exception
            'Session("ErrorLocation") = 'Session("ErrorLocation") + " : " , ex
            LOG.WriteToArchiveLog("clsDatabaseARCH : spCkNextID : 2361 : ", ex)
        End Try
    End Sub

    ''' <summary>
    ''' Inserts the email MSG.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ReceivedByName">Name of the received by.</param>
    ''' <param name="ReceivedTime">The received time.</param>
    ''' <param name="SenderEmailAddress">The sender email address.</param>
    ''' <param name="SenderName">Name of the sender.</param>
    ''' <param name="SentOn">The sent on.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function InsertEmailMsg(ByVal ID As Integer,
                                   ByVal UID As String,
                                   ByVal FQN As String,
                                   ByVal EmailGUID As String,
                                   ByVal UserID As String,
                                   ByVal ReceivedByName As String,
                                   ByVal ReceivedTime As DateTime,
                                   ByVal SenderEmailAddress As String,
                                   ByVal SenderName As String,
                                   ByVal SentOn As DateTime,
                                   ByVal RetentionCode As String,
                                   ByVal isPublic As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = False
        Try
            Dim EmailBinary() As Byte = CF.FileToByte(FQN)

            '*******************************************************
            Dim OriginalSize As Integer = EmailBinary.Length

            EmailBinary = COMP.CompressBuffer(EmailBinary)

            Dim CompressedSize As Integer = EmailBinary.Length
            Dim RC As Boolean = False
            Dim rMsg As String = ""
            Dim TransmissionStartTime As Date = Now
            Dim txEndTime As Date = Now

            'Dim ProxyArchive As New SVCCLCArchive.Service1Client
            'WDM CHECK THIS
            '*******************************************************

            ' 'UserID, ReceivedByName As String, ReceivedTime As DateTime, SenderEmailAddress As
            ' String, SenderName As String, SentOn As DateTime
            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("spInsertEmailMsg", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGUID))
                    command.Parameters.Add(New SqlParameter("@EmailImage", EmailBinary))
                    command.Parameters.Add(New SqlParameter("@UserID", UserID))
                    command.Parameters.Add(New SqlParameter("@ReceivedByName", ReceivedByName))
                    command.Parameters.Add(New SqlParameter("@ReceivedTime", ReceivedTime))
                    command.Parameters.Add(New SqlParameter("@SenderEmailAddress", SenderEmailAddress))
                    command.Parameters.Add(New SqlParameter("@SenderName", SenderName))
                    command.Parameters.Add(New SqlParameter("@SentOn", SentOn))
                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    connection.Dispose()
                    command.Dispose()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(12315, "clsDataBase:InsertEmailMsg" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : InsertEmailMsg : 2386 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Updates the email MSG.
    ''' </summary>
    ''' <param name="OriginalName">Name of the original.</param>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="SourceHash">The source hash.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateEmailMsg(ByVal OriginalName As String,
                                   ByVal ID As Integer,
                                   ByVal UID As String,
                                   ByVal FQN As String,
                                   ByVal EmailGUID As String,
                                   ByVal RetentionCode As String,
                                   ByVal isPublic As String, SourceHash As String,
                                   DirName As String) As Boolean
        Dim LL As Integer = 0
        FQN = UTIL.RemoveSingleQuotes(FQN)
        LL = 1
        Dim B As Boolean = False
        LL = 2

        Dim OriginalSize As Integer = 0 : LL = 3
        Dim CompressedSize As Integer = 0 : LL = 4

        Try
            Dim EmailBinary() As Byte = CF.FileToByte(FQN) : LL = 5
            '*******************************************************
            OriginalSize = EmailBinary.Length : LL = 6

            '** Use Compression to cut down on transmit time here
            EmailBinary = COMP.CompressBuffer(EmailBinary) : LL = 7

            CompressedSize = EmailBinary.Length : LL = 8

            Dim RC As Boolean = False : LL = 9
            Dim rMsg As String = "" : LL = 10
            Dim TransmissionStartTime As Date = Now : LL = 11
            Dim txEndTime As Date = Now : LL = 12

            '*******************************************************
            Dim bUseNewDbArch As Boolean = True : LL = 13
            If bUseNewDbArch Then
                LL = 14

                InsertSourceImage(gCurrUserGuidID, Environment.MachineName, OriginalName, EmailGUID, FQN, "Email", RetentionCode, isPublic, SourceHash, DirName, False)
                B = True
            End If
            '*******************************************************
            LL = 18
            LOG.WriteToArchiveLog("clsDatabaseARCH : UPLOADED EMAIL - OriginalSize = " + OriginalSize.ToString + " : CompressedSize =" + CompressedSize.ToString)
        Catch ex As Exception
            ' xTrace(12315, "UpdateEmailMsg: LL=" + LL.ToString, ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : UpdateEmailMsg : 2404 : LL = " + LL.ToString + " : " + ex.Message + environment.NewLine + " : " + FQN + environment.NewLine + " : " + EmailGUID)
            LOG.WriteToUploadLog("clsDatabaseARCH ERROR: UpdateEmailMsg : OriginalSize = " + OriginalSize.ToString + " : CompressedSize =" + CompressedSize.ToString)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Updates the attachment.
    ''' </summary>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="AttachmentBinary">The attachment binary.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="AttachmentCode">The attachment code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateAttachment(ByVal EmailGUID As String, ByVal AttachmentBinary() As Byte, ByVal AttachmentName As String, ByVal AttachmentCode As String) As Boolean

        Dim bExtendTime As Boolean = False
        If AttachmentBinary.Length > 4000000000 Then
            LOG.WriteToArchiveLog("Notification : AddSourceToRepo : 661b : Loading extremely large file: " + AttachmentName + environment.NewLine + "File Length: " + AttachmentBinary.Length.ToString)
        End If

        Dim InsertConnStr As String = getRepoConnStr()
        UTIL.ExtendTimeoutBySize(InsertConnStr, AttachmentBinary.Length)

        Dim B As Boolean = False
        Try
            Using connection As New SqlConnection(InsertConnStr)
                Using command As New SqlCommand("UpdateAttachment", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGUID))
                    command.Parameters.Add(New SqlParameter("@Attachment", AttachmentBinary))
                    command.Parameters.Add(New SqlParameter("@AttachmentName", AttachmentName))
                    command.Parameters.Add(New SqlParameter("@AttachmentCode", AttachmentCode))
                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    command.Dispose()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(12315, "clsDataBase:UpdateAttachment" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : UpdateAttachment : 2423 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Executes the sp update long name hash.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function Exec_spUpdateLongNameHash(ByVal SourceGuid As String, ByVal FQN As String) As Boolean

        Dim InsertConnStr As String = getRepoConnStr()
        Dim B As Boolean = False
        Dim SpCMD As String = "exec spUpdateLongNameHash '" + FQN + "', '" + SourceGuid + "' "
        'SpCMD += environment.NewLine + "select * from DataSourceFQN where fqn = '" + FQN + "' "
        'Clipboard.Clear()
        'Clipboard.SetText(SpCMD)
        Try
            Using connection As New SqlConnection(InsertConnStr)
                Using command As New SqlCommand("spUpdateLongNameHash", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.AddWithValue("@SourceGuid", SourceGuid)
                    command.Parameters.AddWithValue("@FQN", FQN)
                    connection.Open()
                    command.ExecuteNonQuery()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(12315, "clsDataBase:UpdateAttachment" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : Exec_spUpdateLongNameHash : 2423 : " + ex.Message)
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Updates the attachment by FQN.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="AttachmentCode">The attachment code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateAttachmentByFQN(ByVal ID As Integer, ByVal UID As String, ByVal FQN As String, ByVal EmailGUID As String, ByVal AttachmentName As String, ByVal AttachmentCode As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = False
        Try
            Dim AttachmentBinary() As Byte = CF.FileToByte(FQN)
            '*******************************************************
            Dim OriginalSize As Integer = AttachmentBinary.Length

            AttachmentBinary = COMP.CompressBuffer(AttachmentBinary)

            Dim CompressedSize As Integer = AttachmentBinary.Length
            Dim RC As Boolean = False
            Dim rMsg As String = ""
            Dim TransmissionStartTime As Date = Now
            Dim txEndTime As Date = Now

            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("UpdateAttachment", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGUID))
                    command.Parameters.Add(New SqlParameter("@Attachment", AttachmentBinary))
                    command.Parameters.Add(New SqlParameter("@AttachmentName", AttachmentName))
                    command.Parameters.Add(New SqlParameter("@AttachmentCode", AttachmentCode))
                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    command.Dispose()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(12315, "clsDataBase:UpdateAttachmentByFQN" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : UpdateAttachmentByFQN : 2443 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' xes the insert attachment.
    ''' </summary>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="AttachmentBinary">The attachment binary.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="AttachmentCode">The attachment code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function xInsertAttachment(ByVal EmailGUID As String, ByVal AttachmentBinary() As Byte, ByVal AttachmentName As String, ByVal AttachmentCode As String) As Boolean
        Dim B As Boolean = False
        Try
            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("InsertAttachment", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGUID))
                    command.Parameters.Add(New SqlParameter("@Attachment", AttachmentBinary))
                    command.Parameters.Add(New SqlParameter("@AttachmentName", AttachmentName))
                    command.Parameters.Add(New SqlParameter("@AttachmentCode", AttachmentCode))
                    connection.Open()
                    command.ExecuteNonQuery()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(82711, "InsertAttachment: ", ex.Message.ToString)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : InsertAttachment : 2460 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Validates the ext exists.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    Sub ValidateExtExists(ByVal FQN As String)
        Dim ATYPE As New clsATTACHMENTTYPE
        Dim FileExt As String = "." + UTIL.getFileSuffix(FQN)
        Dim bCnt As Integer = ATYPE.cnt_PK29(FileExt)
        If bCnt = 0 Then
            ATYPE.setDescription("Auto added this code.")
            ATYPE.setAttachmentcode(FileExt)
            ATYPE.Insert()
        End If
        ATYPE = Nothing
    End Sub

    ''' <summary>
    ''' Inserts the attachment FQN.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="AttachmentCode">The attachment code.</param>
    ''' <param name="UserGuidID">The user unique identifier identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="CrcHASH">The CRC hash.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="FileDirectory">The file directory.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function InsertAttachmentFqn(ByVal UID As String,
                                        ByVal FQN As String,
                                        ByVal EmailGUID As String,
                                        ByVal AttachmentName As String,
                                        ByVal AttachmentCode As String,
                                        ByVal UserGuidID As String,
                                        ByVal RetentionCode As String,
                                        ByVal CrcHASH As String,
                                        ByVal isPublic As String,
                                        FileDirectory As String) As Boolean

        '** See if the attachment has been added previously
        Dim OriginalFileName As String = DMA.getFileName(FQN)
        Dim AttachmentType As String = DMA.getFileExtension(FQN)

        FQN = UTIL.RemoveSingleQuotes(FQN)
        AttachmentName = UTIL.RemoveSingleQuotes(AttachmentName)

        Dim B As Boolean = False
        Dim RC As Boolean = False
        Dim ReturnMsg As String = ""
        Dim TxStartTime As Date = Now
        Dim TxEndTime As Date = Now
        Dim RetMsg As String = ""

        Dim SS As String = "select COUNT(*) from EmailAttachment where AttachmentName = '" + AttachmentName + "' and CRC = '" + CrcHASH + "'"
        Dim iCnt As Integer = iCount(SS)

        If (iCnt > 0) Then
            frmNotify2.BackColor = Color.HotPink
            frmNotify2.Refresh()
            Dim RowGuid As String = GetEmailAttachmentGuid(AttachmentName, CrcHASH)
            saveContentOwner(RowGuid, UID, "A", FileDirectory, gMachineID, gNetworkID)
            Return True
        End If
        '** See if the file already exists in the EMAIL ATTACHMENT table
        '** If so, increment the counter and return
        '** If not, add it and fall through to the rest of the code

        'If UseFileStream Then
        Dim NewAttachmentGuid As String = ""

        gMachineID = Environment.MachineName
        '********************************************************************************************************************************************
        NewAttachmentGuid = InsertEmailAttachmentRecord(EmailGUID, AttachmentName, AttachmentCode, AttachmentType, UID, RetMsg, CrcHASH)
        saveContentOwner(NewAttachmentGuid, UserGuidID, "A", FileDirectory, gMachineID, gNetworkID)
        InsertSourceImage(gCurrUserGuidID, Environment.MachineName, AttachmentName, NewAttachmentGuid, FQN, "EmailAttachment", RetentionCode, isPublic, CrcHASH, FileDirectory, False)
        '********************************************************************************************************************************************

        Dim bOcrNeeded As Boolean = ckOcrNeeded(AttachmentCode)
        If bOcrNeeded Then
            SetOcrProcessingParms(EmailGUID, "A", AttachmentName)
        End If

        GC.Collect()
        GC.WaitForPendingFinalizers()
        TxEndTime = Now
        Console.WriteLine("TX Time: " & TC.ElapsedTimeInMS(TxStartTime, TxEndTime))
        If RetMsg.Length = 0 Then
            If ckOcrNeeded(AttachmentType) Then
                SetOcrProcessingParms(EmailGUID, "A", AttachmentName)
                '** call service to LAUNCH server side console app here
            End If
            B = True
        Else
            B = False
        End If
        Return B
    End Function

    ''' <summary>
    ''' Cks the ocr needed.
    ''' </summary>
    ''' <param name="AttachmentType">Type of the attachment.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckOcrNeeded(AttachmentType As String) As Boolean
        '** Convert to use [ImageTypeCode] table in database
        If AttachmentType.ToLower.Equals(".pdf") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("pdf") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("jpg") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".jpg") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("png") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".png") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("trf") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".trf") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("gif") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".gif") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("bmp") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".bmp") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("tif") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".tif") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("tiff") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".tiff") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals("jif") Then
            Return True
        ElseIf AttachmentType.ToLower.Equals(".jif") Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Updates the email binary.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="EmailGUID">The email unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateEmailBinary(ByVal ID As Integer, ByVal UID As String, ByVal FQN As String, ByVal EmailGUID As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = False
        Dim EmailBinary() As Byte = CF.FileToByte(FQN)

        '*******************************************************
        Dim OriginalSize As Integer = EmailBinary.Length

        EmailBinary = COMP.CompressBuffer(EmailBinary)

        Dim CompressedSize As Integer = EmailBinary.Length
        Dim RC As Boolean = False
        Dim rMsg As String = ""
        Dim TransmissionStartTime As Date = Now
        Dim txEndTime As Date = Now

        Try
            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("spUpdateEmailMsg", connection)
                    command.CommandType = CommandType.StoredProcedure
                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGUID))
                    command.Parameters.Add(New SqlParameter("@EmailImage", EmailBinary))
                    connection.Open()
                    command.ExecuteNonQuery()
                End Using
            End Using
            B = True
        Catch ex As Exception
            ' xTrace(82713, "UpdateEmailBinary: ", ex.Message.ToString)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : UpdateEmailBinary : 2495a : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Cks the document exists.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckDocumentExists(ByVal SourceName As String, ByVal CRC As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Try
            S = " select count(*) from DataSource where SourceName = '" + SourceName + "' and CRC = '" + CRC.ToString + "' "
            CloseConn()
            CkConn()
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
            If cnt > 0 Then
                B = True
            Else
                B = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error 199.99.1 - clsDatabaseARCH : ckDocumentExists: ", ex)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Cks the document exists.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckDocumentExists(ByVal SourceName As String, ByVal MachineID As String, CRC As String) As Boolean
        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Try
            S = " select count(*) from DataSource where SourceName = '" + SourceName + "' and CRC = " + CRC + " and MachineID = '" + MachineID + "'"
            CloseConn()
            CkConn()
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
            If cnt > 0 Then
                B = True
            Else
                B = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error 199.99.1 - clsDatabaseARCH : ckDocumentExists: ", ex)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Gets the process as ext.
    ''' </summary>
    ''' <param name="CurrExt">The curr ext.</param>
    ''' <returns>System.String.</returns>
    Public Function getProcessAsExt(CurrExt As String) As String

        Dim pext As String = ""
        Dim B As Boolean = False
        Dim S As String = ""
        Dim rsData As SqlDataReader = Nothing

        Try

            S = "select ProcessExtCode from ProcessFileAs where ExtCode = '" + CurrExt + "' "

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()

            If rsData.HasRows Then
                rsData.Read()
                pext = rsData.GetValue(0).ToString
            Else
                pext = CurrExt
            End If

            rsData.Close()
            rsData = Nothing

            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getProcessAsExt: 9755.21cx - " + ex.Message)
            B = True
        Finally
            rsData = Nothing
        End Try

        Return pext
    End Function

    ''' <summary>
    ''' Adds the source to repo.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="NetworkName">Name of the network.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="UploadFQN">The upload FQN.</param>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="sLastAccessDate">The s last access date.</param>
    ''' <param name="sCreateDate">The s create date.</param>
    ''' <param name="sLastWriteTime">The s last write time.</param>
    ''' <param name="DataSourceOwnerUserID">The data source owner user identifier.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function AddSourceToRepo(ByVal UID As String,
                                    ByVal MachineID As String,
                                    NetworkName As String,
                                    ByVal SourceGuid As String,
                                    ByVal UploadFQN As String,
                                    ByVal SourceName As String,
                                    ByVal SourceTypeCode As String,
                                    ByVal sLastAccessDate As String,
                                    ByVal sCreateDate As String,
                                    ByVal sLastWriteTime As String,
                                    ByVal DataSourceOwnerUserID As String,
                                    ByVal VersionNbr As Integer,
                                    ByVal RetentionCode As String,
                                    ByVal isPublic As String,
                                    FileHash As String,
                                    FolderName As String) As String

        If (SourceName.Trim.Length().Equals(0)) Then
            SourceName = Path.GetFileName(UploadFQN)
        End If
        If (SourceTypeCode.Trim.Length().Equals(0)) Then
            SourceTypeCode = getProcessAsExt(Path.GetExtension(UploadFQN))
        End If

        Dim LastAccessDate As Date = Nothing
        Dim CreateDate As Date = Nothing
        Dim LastWriteTime As Date = Nothing

        saveContentOwner(SourceGuid, DataSourceOwnerUserID, "C", FolderName, MachineID, NetworkName)

        Try
            LastWriteTime = CDate(sLastWriteTime)
        Catch ex0 As Exception
            LOG.WriteToDBUpdatesLog("ERROR: AddSourceToRepo 100 - LastWriteTime: " + ex0.Message + Environment.NewLine + sLastWriteTime)
        End Try

        Try
            LastAccessDate = CDate(sLastAccessDate)
        Catch ex1 As Exception
            LOG.WriteToDBUpdatesLog("ERROR: AddSourceToRepo 101 - LastAccessDate: " + ex1.Message + Environment.NewLine + sLastAccessDate)
        End Try

        Try
            CreateDate = CDate(sCreateDate)
        Catch ex2 As Exception
            LOG.WriteToDBUpdatesLog("ERROR: AddSourceToRepo 102 - CreateDate: " + ex2.Message + Environment.NewLine + sCreateDate)
        End Try

        Dim fExt As String = SourceTypeCode

        UploadFQN = UTIL.ReplaceSingleQuotes(UploadFQN)

        Dim B As Boolean = False
        B = ckDocumentExists(SourceName, FileHash)
        If B = True Then
            saveContentOwner(SourceGuid, gCurrUserGuidID, "C", FolderName, gMachineID, gNetworkID)
            LOG.WriteToDBUpdatesLog("Info: clsDatabaseARCH : AddSourceToRepo: file exists, did not update or overwrite." + Environment.NewLine + UploadFQN)
            Return True
        Else
            Console.WriteLine("No Exists: " + SourceName)
        End If

        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        SourceTypeCode = UTIL.RemoveSingleQuotes(SourceTypeCode)
        LastAccessDate = CDate(UTIL.RemoveSingleQuotes(CStr(LastAccessDate)))
        CreateDate = CDate(UTIL.RemoveSingleQuotes(CStr(CreateDate)))
        LastWriteTime = CDate(UTIL.RemoveSingleQuotes(CStr(LastWriteTime)))
        DataSourceOwnerUserID = UTIL.RemoveSingleQuotes(DataSourceOwnerUserID)

        UploadFQN = UTIL.ReplaceSingleQuotes(UploadFQN)

        If Not File.Exists(UploadFQN) Then
            LOG.WriteToDBUpdatesLog("ERROR - AddSourceToRepo : 2519.2c : could not find file {" + UploadFQN + "}, skipped.")
            Return False
        End If

        Dim SourceImage() As Byte = CF.FileToByte(UploadFQN)
        If SourceImage Is Nothing Then
            LOG.WriteToDBUpdatesLog("Notification : AddSourceToRepo : 661c1 : FILE Failed to load: " + UploadFQN + ".")
            Return False
        End If
        If SourceImage.Length = 0 Then
            LOG.WriteToDBUpdatesLog("Notification : AddSourceToRepo : 661z1 : FILE Failed to load: " + UploadFQN + ".")
            Return False
        End If
        If SourceImage.Length > 500000000 Then
            LOG.WriteToDBUpdatesLog("Notification : AddSourceToRepo : 661b : Loading large file: " + UploadFQN + Environment.NewLine + "File Length: " + SourceImage.Length.ToString)
        End If
        If SourceImage.Length > 1000000000 Then
            LOG.WriteToDBUpdatesLog("Notification : AddSourceToRepo : 661b : Loading extremely large file: " + UploadFQN + Environment.NewLine + "File Length: " + SourceImage.Length.ToString)
        End If

        Try

            Dim RC As Boolean = False
            Dim ReturnMsg As String = ""
            Dim TxStartTime As Date = Now
            Dim TxEndTime As Date = Now

            Dim OriginalSize As Integer = SourceImage.Length
            SourceImage = COMP.CompressBuffer(SourceImage)
            Dim CompressedSize As Integer = SourceImage.Length

            '** Check to see if this file requires OCR or PDF processing here
            '** If so, copy it to the Processing directory and let the command line utiltiy process it
            'Dim ProxyArchive As New SVCCLCArchive.Service1Client
            'WDM CHECK THIS OUT
            'B = AddSourceToRepo(UID, MachineID, "LOCAL", SourceGuid, UploadFQN, SourceName, SourceTypeCode, sLastAccessDate, sCreateDate, sLastWriteTime, UID, VersionNbr, RetentionCode, isPublic, FileHash, FolderName)

            Dim FIleExt As String = Path.GetExtension(UploadFQN)
            Dim OriginalFileName As String = Path.GetFileName(UploadFQN)
            Dim DirName As String = Path.GetDirectoryName(UploadFQN)
            Dim bUseZipFles As Boolean = True
            Dim BBX As Boolean = True

            Dim LOF As List(Of String) = ckFileExistInRepo(Environment.MachineName, gCurrUserGuidID)
            If LOF.Count.Equals(0) Then

                Dim NewSourceGuid As String = insertSingleFILE(UploadFQN)
                If NewSourceGuid.Length.Equals(0) Then
                    BBX = False
                    LOG.WriteToArchiveLog("ERROR AddSource Failed for: " + UploadFQN)
                Else
                    BBX = True
                    SourceGuid = NewSourceGuid
                End If
            End If

            If BBX Then
                '********************************************************************************
                '************************ UpdateSourceImage *************************************
                B = UpdateSourceImage(SourceGuid, SourceImage)
                '********************************************************************************
                '********************************************************************************

                If Not B Then
                    LOG.WriteToDBUpdatesLog("ERROR Load Failed for: " + UploadFQN + Environment.NewLine + ReturnMsg)
                Else
                    LOG.WriteToDBUpdatesLog("Notice Load successful for: " + UploadFQN)
                    saveContentOwner(SourceGuid, gCurrUserGuidID, "C", FolderName, gMachineID, gNetworkID)
                    If ckOcrNeeded(fExt) Then
                        SetOcrProcessingParms(SourceGuid, "C", SourceName)
                    End If

                End If
            End If

            'ProxyArchive = Nothing
            GC.Collect()
            GC.WaitForPendingFinalizers()
        Catch ex As Exception
            B = False
            LOG.WriteToDBUpdatesLog("clsDatabaseARCH : AddSourceToRepo : 2495b : " + UploadFQN + Environment.NewLine + ex.Message)
        End Try
        Return SourceGuid
    End Function

    ''' <summary>
    ''' Updates the source image.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceImage">The source image.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateSourceImage(SourceGuid As String, SourceImage As Byte()) As Boolean

        Dim B As Boolean = True
        Dim CMD As New SqlCommand
        Dim connString As String = getRepoConnStr()
        Dim conn As New SqlConnection(connString)
        Dim MySql As String = "Update DataSource set SourceImage = @SourceImage where SourceGuid = @SourceGuid"

        Try
            If conn Is Nothing Then
                conn = New SqlConnection(getRepoConnStr())
            End If
            If conn.State = ConnectionState.Closed Then
                conn.ConnectionString = getRepoConnStr()
                conn.Open()
            End If
            Try
                I = 0
                CMD.Connection = conn
                CMD.CommandText = MySql
                CMD.CommandType = CommandType.Text
                Using conn
                    Using CMD
                        CMD.Parameters.Add(New SqlParameter("@SourceImage", SourceImage))
                        CMD.Parameters.Add(New SqlParameter("@SourceGuid", SourceGuid))
                        CMD.ExecuteNonQuery()
                        CMD.CommandText = MySql
                        CMD.ExecuteNonQuery()
                    End Using
                End Using
                B = True
            Catch ex As Exception
                LOG.WriteToDBUpdatesLog("ERROR 22x: UpdateSourceImage 01: " + ex.Message + Environment.NewLine + MySql)
                LOG.WriteToArchiveLog("ERROR 22x: UpdateSourceImage 01: " + ex.Message + Environment.NewLine + MySql)
                B = False
            End Try
        Catch ex As Exception
            B = False
            LOG.WriteToDBUpdatesLog("ERROR UpdateSourceImage 00: " + ex.Message)
            LOG.WriteToArchiveLog("ERROR UpdateSourceImage 00: " + ex.Message)
        End Try


        Return B

    End Function

    ''' <summary>
    ''' Applies the source type code.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="FileExt">The file ext.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Private Function ApplySourceTypeCode(MachineName As String, UserID As String, SourceName As String, FileExt As String, SourceGuid As String) As Boolean
        Dim bb As Boolean = True
        Try
            Dim cs As String = getRepoConnStr()
            Dim conn = New SqlConnection(cs)
            conn.Open()
            Using conn
                Dim cmd = New SqlCommand("sp_ApplySourceTypeCode", conn)
                Using cmd
                    cmd.CommandType = CommandType.StoredProcedure
                    cmd.Parameters.Add(New SqlParameter("@MachineID", MachineName))
                    cmd.Parameters.Add(New SqlParameter("@UserID", UserID))
                    cmd.Parameters.Add(New SqlParameter("@SourceName", SourceName))
                    cmd.Parameters.Add(New SqlParameter("@FileExt", FileExt))
                    cmd.Parameters.Add(New SqlParameter("@SourceGuid", SourceGuid))
                    cmd.ExecuteNonQuery()
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR ApplySourceTypeCode 00: " + ex.Message)
            bb = False
        End Try
        Return bb
    End Function


    ''' <summary>
    ''' Updates the source image in repo.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="LastWriteTime">The last write time.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="UploadFQN">The upload FQN.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateSourceImageInRepo(ByVal SourceName As String,
                                      ByVal UID As String,
                                      ByVal MachineID As String,
                                      ByVal SourceGuid As String,
                                      ByVal LastAccessDate As String,
                                      ByVal CreateDate As String,
                                      ByVal LastWriteTime As String,
                                      ByVal VersionNbr As Integer,
                                      ByVal UploadFQN As String,
                                      ByVal RetentionCode As String,
                                      ByVal isPublic As String,
                                      FileHash As String) As Boolean

        'DALE
        SourceName = SourceName.Replace("''", "'")
        Dim FileExt As String = Path.GetExtension(SourceName)

        ApplySourceTypeCode(MachineID, UID, SourceName, FileExt, SourceGuid)

        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim FileDirectory As String = "NA"
        Dim TrackUploads As String = System.Configuration.ConfigurationManager.AppSettings("TrackUploads")

        Dim LL As Integer = 0
        Dim B As Boolean = True
        Dim bLogUploads As Boolean = True

        Dim OriginalSize As Integer = 0
        Dim CompressedSize As Integer = 0
        Dim bError As Boolean = False
        Try

            If TrackUploads.Equals("1") Then
                bLogUploads = True
            Else
                bLogUploads = False
            End If

            LL = 1
            LastAccessDate = UTIL.RemoveSingleQuotes(LastAccessDate)
            CreateDate = UTIL.RemoveSingleQuotes(CreateDate)
            LastWriteTime = UTIL.RemoveSingleQuotes(LastWriteTime)
            LL = 2
            If InStr(UploadFQN, "''") > 0 Then
                UploadFQN = UTIL.ReplaceSingleQuotes(UploadFQN)
            End If
            LL = 4
            If Not File.Exists(UploadFQN) Then
                LOG.WriteToArchiveLog("NOTICE 100-B: Cannot update '" + UploadFQN + "' as it does not appear to exist.")
                Return False
            End If
            LL = 5

            '******************************************************************************************
            Dim AttachmentBinary() As Byte = Nothing
            AttachmentBinary = System.IO.File.ReadAllBytes(UploadFQN)
            '******************************************************************************************

            Dim bExtendTime As Boolean = False
            LL = 6
            If AttachmentBinary.Length <= 0 Then
                LOG.WriteToArchiveLog("ERROR : AddSourceToRepo : 661b failed to open file: " + UploadFQN + ".")
                Return False
            End If
            If AttachmentBinary.Length > 1000000 Then
                bExtendTime = True
            End If
            LL = 7
            If AttachmentBinary.Length > 4000000000 Then
                LOG.WriteToArchiveLog("Notification : AddSourceToRepo : 661b : Loading extremely large file: " + UploadFQN + environment.NewLine + "File Length: " + AttachmentBinary.Length.ToString)
            End If
            If AttachmentBinary.Length > 1000000000 Then
                LOG.WriteToArchiveLog("Notification : AddSourceToRepo : 661b : Loading HUGE large file: " + UploadFQN + environment.NewLine + "File Length: " + AttachmentBinary.Length.ToString)
                frmNotifyMessage.Show()
                gNotifyMsg = "Notification : 661 : Loading HUGE large file: " + UploadFQN + environment.NewLine + "File Length: " + AttachmentBinary.Length.ToString + environment.NewLine + "Over a network, this can take hours."
            End If
            LL = 8

            Dim RC As Boolean = False
            Dim ReturnMsg As String = ""
            Dim TxStartTime As Date = Now
            Dim TxEndTime As Date = Now
            Dim bFileCompressed As Boolean = False
            Dim CopyOfAttachmentBinary As Byte() = AttachmentBinary

            OriginalSize = AttachmentBinary.Length
            AttachmentBinary = COMP.CompressBuffer(AttachmentBinary)
            CompressedSize = AttachmentBinary.Length

            LL = 10

            If CompressedSize >= OriginalSize Then
                LL = 11
                AttachmentBinary = CopyOfAttachmentBinary
                CopyOfAttachmentBinary = Nothing
                bFileCompressed = False
            Else
                LL = 12
                CopyOfAttachmentBinary = Nothing
                bFileCompressed = True
            End If
            LL = 13
            If bLogUploads Then
                LL = 14
                Dim sMsg As String = "Start Upload: oSize=" & OriginalSize & " / cSize=" & CompressedSize & ", Time: " + Now.ToString + " - " + UploadFQN
                LOG.WriteToUploadLog(sMsg)
            End If
            LL = 15
            '** Herein lies the Problem:
            '**     1 - 16k seems to be the maximum size that will successfully upload.
            '**     2 - See if MS will help us setup a STREAM to memory upload as well
            '**     3 - See if MS can get us a 4GB upload both in stream to file on the
            '**         server side as well as a stream to memory on the server side.
            '**     4 - Possibly MS can give us a better way to compresss/zip messages on both ends
            'Dim ProxyArchive As New SVCCLCArchive.Service1Client

            MachineID = Environment.MachineName

            '************************************************************************************************************************************************************************************************
            Dim BBX As Boolean = InsertSourceImage(gCurrUserGuidID, Environment.MachineName, SourceName, SourceGuid, UploadFQN, "DataSource", RetentionCode, isPublic, FileHash, FileDirectory, False)
            '************************************************************************************************************************************************************************************************
            If Not BBX Then
                Return False
            End If
            LL = 18
            If ReturnMsg.Length > 0 Or Not B Then
                LL = 19
                Dim sMsg As String = "ERROR Upload: " + ReturnMsg + "  / oSize=" & OriginalSize & " / cSize=" & CompressedSize & ", Time: " + Now.ToString + " - " + UploadFQN
                LOG.WriteToUploadLog(sMsg)
            End If
            LL = 20
            'ProxyArchive = Nothing
            GC.Collect()
            GC.WaitForPendingFinalizers()
            LL = 24
            B = True
        Catch ex As Exception
            bError = True
            Dim FI As New FileInfo(UploadFQN)
            Dim fSIze As Integer = CInt(FI.Length)
            FI = Nothing

            B = False
            LOG.WriteToArchiveLog("Unrecoverable Error - clsDatabaseARCH : UpdateSourcefile : 2517a LL= '" + LL.ToString + "' : SourceGuid = '" + SourceGuid + "' : Size = " + fSIze.ToString + environment.NewLine + ex.Message)
            LOG.WriteToArchiveLog("ERROR         UpdateSourcefile : 2517a : " + UploadFQN)
            If ex.InnerException IsNot Nothing Then
                LOG.WriteToArchiveLog("ERROR         UpdateSourcefile : 2517a.1 : " + ex.InnerException.ToString)
            End If

        End Try

        If bLogUploads Then
            If bError Then
                Dim sMsg As String = "END Upload: (ERROR) oSize=" & OriginalSize & " / cSize=" & CompressedSize & ", Time: " + Now.ToString + " - " + UploadFQN
                LOG.WriteToUploadLog(sMsg)
            Else
                Dim sMsg As String = "END Upload: oSize=" & OriginalSize & " / cSize=" & CompressedSize & ", Time: " + Now.ToString + " - " + UploadFQN
                LOG.WriteToUploadLog(sMsg)
            End If

        End If

        Return B
    End Function

    ''' <summary>
    ''' Updates the name of the source.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceName">Name of the source.</param>
    Sub UpdateSourceName(SourceGuid As String, SourceName As String)

        Dim b As Boolean = False
        Dim S As String = ""

        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        S = "Update DataSOurce set SourceName = '" + SourceName + "' where SourceGuid = '" + SourceGuid + "' "
        b = ExecuteSqlNewConn(90101, S)

    End Sub

    ''' <summary>
    ''' Updates the URL binary HTML.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="LastWriteTime">The last write time.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="HTML">The HTML.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateUrlBinaryHtml(ByVal UID As String, ByVal SourceGuid As String, ByVal LastAccessDate As String, ByVal CreateDate As String, ByVal LastWriteTime As String, ByVal VersionNbr As Integer, ByVal HTML As String) As Boolean

        Dim B As Boolean = False
        Dim RC As Boolean = False
        Dim ReturnMsg As String = ""
        Dim TxStartTime As Date = Now
        Dim TxEndTime As Date = Now
        Dim AttachmentBinary() As Byte = StrToByteArray(HTML)

        Dim OriginalSize As Integer = AttachmentBinary.Length
        AttachmentBinary = COMP.CompressBuffer(AttachmentBinary)
        Dim CompressedSize As Integer = AttachmentBinary.Length

        'B = ProxyArchive.UpdateUrlBinaryHtml(gGateWayID, 2, UID, SourceGuid, LastAccessDate, CreateDate, LastWriteTime, VersionNbr, AttachmentBinary, OriginalSize, CompressedSize, RC, ReturnMsg, TxStartTime, TxEndTime)
        B = UpdateUrlBinaryHtml(UID, SourceGuid, LastAccessDate, CreateDate, LastWriteTime, VersionNbr, HTML)
        'ProxyArchive = Nothing
        GC.Collect()
        GC.WaitForPendingFinalizers()

        Console.WriteLine("TX Time: " & TC.ElapsedTimeInMS(TxStartTime, TxEndTime))

        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is sourcefile older than last entry] [the specified source name].
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CrcHASH">The CRC hash.</param>
    ''' <returns><c>true</c> if [is sourcefile older than last entry] [the specified source name]; otherwise, <c>false</c>.</returns>
    Public Function isSourcefileOlderThanLastEntry(SourceName As String, CrcHASH As String) As Boolean

        Dim B As Boolean = False
        Dim S As String = ""
        Dim rsData As SqlDataReader = Nothing

        Try
            SourceName = UTIL.RemoveSingleQuotes(SourceName)

            S = "Select  count(*) from DataSource where SourceName = '" + SourceName + "' and CRC = '" + CrcHASH + "' "

            Dim iCnt As Integer = 0
            iCnt = iCount(S)

            If iCnt > 0 Then
                B = True
            Else
                B = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: 9755.21cx - ", ex)
            B = True
        Finally
            rsData = Nothing
        End Try

        Return B
    End Function

    ''' <summary>
    ''' xes the xis sourcefile older than last entry.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="UploadFQN">The upload FQN.</param>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="LastWriteTime">The last write time.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function XXisSourcefileOlderThanLastEntry(ByVal UserID As String, ByVal SourceGuid As String,
                   ByVal UploadFQN As String,
                   ByVal SourceName As String,
                   ByVal SourceTypeCode As String,
                   ByVal FileLength As String,
                   ByVal LastAccessDate As String,
                   ByVal CreateDate As String,
                   ByVal LastWriteTime As String, ByVal VersionNbr As String) As Boolean

        Dim B As Boolean = False
        Dim S As String = ""
        Dim rsData As SqlDataReader = Nothing

        Try
            UploadFQN = UTIL.RemoveSingleQuotes(UploadFQN)

            S = "Select  "
            S = S + "  [FileLength]"
            S = S + " ,[LastAccessDate]"
            S = S + " ,[CreateDate]"
            S = S + " ,[LastWriteTime]"
            S = S + " FROM DataSource "
            S = S + " where FQN = '" + UploadFQN + "' "
            S = S + " and VersionNbr = " + VersionNbr
            S = S + " and DataSourceOwnerUserID = '" + UserID + "'"

            Dim i As Integer = 0
            Dim id As String = ""

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()

            If rsData.HasRows Then

                rsData.Read()

                Dim tFileLength As String = rsData.GetValue(0).ToString
                Dim tLastAccessDate As String = rsData.GetValue(1).ToString
                Dim tCreateDate As String = rsData.GetValue(2).ToString
                Dim tLastWriteTime As String = rsData.GetValue(3).ToString

                LastAccessDate = UTIL.VerifyDate(LastAccessDate)
                CreateDate = UTIL.VerifyDate(CreateDate)
                LastWriteTime = UTIL.VerifyDate(LastWriteTime)

                tLastAccessDate = UTIL.VerifyDate(tLastAccessDate)
                tCreateDate = UTIL.VerifyDate(tCreateDate)
                tLastWriteTime = UTIL.VerifyDate(tLastWriteTime)

                If CInt(FileLength) <> CInt(tFileLength) Then
                    B = True
                ElseIf CDate(CreateDate) <> CDate(tCreateDate) Then
                    B = True
                ElseIf CDate(LastWriteTime) > CDate(tLastWriteTime) Then
                    B = True
                End If
            Else
                id = ""
            End If

            rsData.Close()
            rsData = Nothing

            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: 9755.21cx - ", ex)
            B = True
        Finally
            rsData = Nothing
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Gets the attachment from database.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.Byte().</returns>
    Public Function GetAttachmentFromDB(ByVal EmailGuid As String) As Byte()

        Dim con As New SqlConnection(getRepoConnStr())
        Dim da As New SqlDataAdapter("Select * From EmailAttachment where EmailGuid = '" & EmailGuid & "'", con)
        Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
        Dim ds As New System.Data.DataSet
        Dim TypeAttachmentCode As String = ""

        con.Open()
        da.Fill(ds, "Attachments")
        Dim myRow As System.Data.DataRow
        myRow = ds.Tables("Attachments").Rows(0)

        Dim MyData() As Byte
        MyData = CType(myRow("Attachment"), Byte())
        TypeAttachmentCode = CStr(myRow("AttachmentCode"))

        MyCB = Nothing
        ds = Nothing
        da = Nothing

        con.Close()
        con = Nothing
        Return MyData

    End Function

    ''' <summary>
    ''' Determines if an email has already been stored based on the short subject, received time, and
    ''' the sender's email address.
    ''' </summary>
    ''' <param name="EmailSubj">The subject of the email.</param>
    ''' <param name="EmailCreationTime">The email creation time.</param>
    ''' <param name="EmailReceivedTime">The time the email was received.</param>
    ''' <param name="EmailSentOn">The email sent on.</param>
    ''' <param name="SenderEmailAddress">The email addres of the sender.</param>
    ''' <returns>Boolean</returns>
    ''' <remarks>This funcition, if extended to include other parms in the lookup will be overloaded.</remarks>
    Public Function isEmailStored(ByVal EmailSubj As String, ByVal EmailCreationTime As String, ByVal EmailReceivedTime As String, ByVal EmailSentOn As String, ByVal SenderEmailAddress As String) As Boolean

        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        EmailSubj = UTIL.RemoveSingleQuotes(EmailSubj)
        SenderEmailAddress = UTIL.RemoveSingleQuotes(SenderEmailAddress)

        S = " SELECT count(*)"
        S = S + " FROM [Email] "
        S = S + " where [ShortSubj] = '" + EmailSubj + "' "
        S = S + " and creationtime = '" + EmailCreationTime + "' "
        S = S + " and SentOn = '" + EmailSentOn + "' "
        S = S + " and [ReceivedTime] = '" + EmailReceivedTime + "' "
        S = S + " and [SenderEmailAddress] = '" + SenderEmailAddress + "' "

        CloseConn()
        CkConn()

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B

    End Function

    ''' <summary>
    ''' Cks the backup folder.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckBackupFolder(ByVal UserID As String, ByVal FolderName As String) As Boolean

        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()

        S = " SELECT count(*)"
        S = S + " FROM [EmailFolder] "
        S = S + " WHERE [UserID] = '" + UserID + "' "
        S = S + " AND [FolderName] = '" + FolderName + "' "
        S = S + " AND [ArchiveEmails] = 'Y' "

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)

        Using CONN

            Dim RSData As SqlDataReader = Nothing
            CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If

        CONN = Nothing

        Return B

    End Function

    ''' <summary>
    ''' Deletes the sub dirs.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    Public Sub delSubDirs(ByVal UID As String, ByVal FQN As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "delete FROM [SubDir] where [UserID] = '" + UID + "' and [FQN] = '" + FQN + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Me.ExecuteSqlNewConn(S, False)
        End Using

    End Sub

    ''' <summary>
    ''' Deletes the file parms.
    ''' </summary>
    ''' <param name="SGUID">The sguid.</param>
    Public Sub delFileParms(ByVal SGUID As String)
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        CloseConn()
        CkConn()

        'Dim ConnStr  = System.Configuration.ConfigurationManager.AppSettings(ConnStrID)
        'Dim Conn As New SqlConnection(ConnStr)

        S = "DELETE FROM [SourceAttribute] WHERE SourceGuid = '" + SGUID + "'"

        Using gConn
            If gConn.State = ConnectionState.Closed Then
                gConn.Open()
            End If
            B = Me.ExecuteSqlNewConn(S, False)
        End Using

    End Sub

    ''' <summary>
    ''' Looks to see what filetypes have been defined to the system It looks in table AvailFileTypes.
    ''' </summary>
    ''' <returns>Bolean True/False</returns>
    Public Function ckFileExtExists() As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "Select count(*) FROM [AvailFileTypes]"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B

    End Function

    ''' <summary>
    ''' Cks the FQN exists.
    ''' </summary>
    ''' <param name="fqn">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckFQNExists(fqn As String) As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        fqn = fqn.Replace("'", "''")

        S = "Select count(*) FROM DataSource where FQN = '" + fqn + "'"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            Using RSData
                RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
            End Using
            command.Connection.Close()
            command = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B

    End Function

    ''' <summary>
    ''' Cks the user exists.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckUserExists(ByVal UserID As String) As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "Select count(*) FROM [Users] where UserID = '" + UserID + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Try
                    Conn.Open()
                Catch ex As Exception
                    ' xTrace(12325, "clsDataBase:ckUserExists" + ex.Message)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ckUserExists : 2656 : ", ex)

                    Return False
                End Try

            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B

    End Function

    ''' <summary>
    ''' Cks the user login exists.
    ''' </summary>
    ''' <param name="UserLogin">The user login.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <param name="RetMsg">The ret MSG.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckUserLoginExists(ByVal UserLogin As String, ByRef RC As Boolean, ByRef RetMsg As String) As Integer
        Dim S As String = ""
        Dim B As Boolean = True
        Dim cnt As Integer = -1

        'Dim ConnStr As String = getRepoConnStr()

        Dim ConnStr As String = getRepoConnStr()
        'ConnStr = ENC.AES256DecryptString(ConnStr)

        Dim Conn As New SqlConnection(ConnStr)

        'S = "Select count(*) FROM [User] where UserLoginID = '" + UserLogin + "' "
        S = "Select count(*) FROM [Users] where UserID = '" + UserLogin + "' "

        'MessageBox.Show("REMOVE THIS: checking for user at: " + ConnStr + environment.NewLine + S)
        'Clipboard.Clear()
        'Clipboard.SetText("REMOVE THIS: checking for user at: " + ConnStr + environment.NewLine + S)

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Try
                    Conn.Open()
                Catch ex As Exception
                    RetMsg = "ERROR: " + ex.ToString
                    ' xTrace(12325, "clsDataBase:ckUserExists" + ex.Message)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ckUserExists : 2656 : ", ex)
                    Return -1
                End Try

            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            If (cnt > 0) Then
                RC = True
            Else
                RC = False
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the binary password.
    ''' </summary>
    ''' <param name="UserLogin">The user login.</param>
    ''' <returns>System.String.</returns>
    Public Function getBinaryPassword(ByVal UserLogin As String) As String
        Dim S As String = ""
        Dim B As Boolean = False
        Dim BPW As String = ""
        'Dim ConnStr As String = getRepoConnStr()
        Dim ConnStr As String = getRepoConnStr()
        'ConnStr = ENC.AES256DecryptString(ConnStr)

        Dim Conn As New SqlConnection(ConnStr)

        S = "Select UserPassword FROM [Users] where UserID = '" + UserLogin + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Try
                    Conn.Open()
                Catch ex As Exception
                    ' xTrace(12325, "clsDataBase:ckUserExists" + ex.Message)
                    LOG.WriteToArchiveLog("clsDatabaseARCH : ckUserExists : 2656 : ", ex)

                    Return CStr(False)
                End Try

            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            BPW = RSData.GetValue(0).ToString
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        Return BPW

    End Function

    ''' <summary>
    ''' Cks the folder exists.
    ''' </summary>
    ''' <param name="FileDirectory">The file directory.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckFolderExists(ByVal FileDirectory As String, ByVal UserID As String, ByVal FolderName As String) As Boolean
        Try
            Dim S As String = ""
            Dim B As Boolean = False
            Dim cnt As Integer = -1

            Dim ConnStr As String = getRepoConnStr()
            Dim Conn As New SqlConnection(ConnStr)

            FileDirectory = UTIL.RemoveSingleQuotes(FileDirectory)

            S = "Select count(*) FROM [EmailArchParms] where FolderName = '" + FileDirectory + "' and [UserID] = '" + UserID + "' and [FolderName] = '" + FolderName + "' "
            'S = "Select count(*) FROM [EmailFolder] where [UserID] = '" + UserID  + "' and [FolderName] = '" + FolderName  + "' "
            'SELECT COUNT(*)  FROM EmailArchParms where UserID = 'wmiller' and FolderName = 'Personal Folders|Dale''s Stuff'
            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            Return B
        Catch ex As Exception
            ' xTrace(12325, "clsDataBase:ckFolderExists" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckFolderExists : 2704 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckFolderExists : 2670 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckFolderExists : 2681 : ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Cks the URL exists.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckUrlExists(ByVal FQN As String) As Boolean
        Try
            Dim S As String = ""
            Dim B As Boolean = False
            Dim cnt As Integer = -1

            Dim ConnStr As String = getRepoConnStr()
            Dim Conn As New SqlConnection(ConnStr)

            S = "Select count(*) FROM DataSource where FQN = '" + FQN + "' "

            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            Return B
        Catch ex As Exception
            ' xTrace(12325, "clsDataBase:ckFolderExists" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckFolderExists : 2681 : ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Cks the master exists.
    ''' </summary>
    ''' <param name="FileName">Name of the file.</param>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="ColName">Name of the col.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckMasterExists(ByVal FileName As String, ByVal TblName As String, ByVal ColName As String, Optional ByVal SourceGuid As String = Nothing) As Boolean
        'SELECT count(*) FROM  [DataSource] where [SourceName] = 'Current State of ECM.docx' and [isMaster] = 'Y'

        'SELECT SourceName FROM  [DataSource] where SourceGuid = 'XX'

        If SourceGuid = Nothing Then
        Else
            FileName = Me.getFilenameByGuid(SourceGuid)
        End If

        Try
            Dim S As String = ""
            Dim B As Boolean = False
            Dim cnt As Integer = -1

            Dim ConnStr As String = getRepoConnStr()
            Dim Conn As New SqlConnection(ConnStr)

            S = "Select count(*) FROM  [DataSource] where [SourceName] = '" + FileName + "' and [isMaster] = 'Y'"

            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            Return B
        Catch ex As Exception
            ' xTrace(12326, "clsDataBase:ckMasterExists" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckMasterExists : 2738 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckMasterExists : 2704 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckMasterExists : 2716 : ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Cks the parms folder exists.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckParmsFolderExists(ByVal UserID As String, ByVal FolderName As String) As Boolean
        Try
            Dim S As String = ""
            Dim B As Boolean = False
            Dim cnt As Integer = -1

            Dim ConnStr As String = getRepoConnStr()
            Dim Conn As New SqlConnection(ConnStr)

            S = "Select count(*) FROM [EmailArchParms] where [UserID] = '" + UserID + "' and [FolderName] = '" + FolderName + "' "

            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            Return B
        Catch ex As Exception
            ' xTrace(12326, "clsDataBase:ckParmsFolderExists" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckParmsFolderExists : 2768 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckParmsFolderExists : 2734 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckParmsFolderExists : 2747 : ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Selects the one email parm.
    ''' </summary>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <returns>Array.</returns>
    Public Function SelectOneEmailParm(ByVal WhereClause As String) As Array

        Dim A(11) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        Dim b As Boolean = False
        Dim s As String = ""

        s = s + " SELECT "
        s = s + "UserID,"
        s = s + "ArchiveEmails,"
        s = s + "RemoveAfterArchive,"
        s = s + "SetAsDefaultFolder,"
        s = s + "ArchiveAfterXDays,"
        s = s + "RemoveAfterXDays,"
        s = s + "RemoveXDays,"
        s = s + "ArchiveXDays,"
        s = s + "FolderName,"
        s = s + "DB_ID ,"
        s = s + "ArchiveOnlyIfRead, isSysDefault "
        s = s + " FROM EmailArchParms "
        s = s + WhereClause

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                A(0) = RSData.GetValue(0).ToString
                A(1) = RSData.GetValue(1).ToString
                A(2) = RSData.GetValue(2).ToString
                A(3) = RSData.GetValue(3).ToString
                A(4) = RSData.GetValue(4).ToString
                A(5) = RSData.GetValue(5).ToString
                A(6) = RSData.GetValue(6).ToString
                A(7) = RSData.GetValue(7).ToString
                A(8) = RSData.GetValue(8).ToString
                A(9) = RSData.GetValue(9).ToString
                A(10) = RSData.GetValue(10).ToString
                A(11) = RSData.GetValue(11).ToString
                'UserID = a(0)
                'ArchiveEmails = a(1)
                'RemoveAfterArchive = a(2)
                'SetAsDefaultFolder = a(3)
                'ArchiveAfterXDays = a(4)
                'RemoveAfterXDays = a(5)
                'RemoveXDays = a(6)
                'ArchiveXDays = a(7)
                'FolderName = a(8)
                'DB_ID = a(9)
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return A
    End Function

    ''' <summary>
    ''' Loads the avail file types.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Public Sub LoadAvailFileTypes(ByRef CB As ComboBox)
        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        s = " SELECT distinct [ExtCode] FROM [AvailFileTypes] order by [ExtCode]"
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    CB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Loads the avail users.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Public Sub LoadAvailUsers(ByRef CB As ComboBox)
        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        s = " SELECT UserLoginID FROM Users "
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    CB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Loads the retention codes.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Public Sub LoadRetentionCodes(ByRef CB As ComboBox)
        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        Dim iCnt As Integer = 0

        s = "select RetentionCode from Retention order by RetentionCode"
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    iCnt += 1
                    Dim SS As String = RSData.GetValue(0).ToString
                    CB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
            If iCnt = 0 Then
                ' If gRunUnattended = False Then MessageBox.Show("Failed to load the retention codes, this will cause issues.")
                LOG.WriteToArchiveLog("ERROR - Failed to load the retention codes, this will cause issues.")
            End If
        End Using
    End Sub

    ''' <summary>
    ''' Loads the avail file types.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    Public Sub LoadAvailFileTypes(ByRef LB As ListBox)

        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        s = " SELECT distinct [ExtCode] FROM [AvailFileTypes] order by ExtCode"
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    If SS.Equals("*") Then
                    ElseIf SS.Equals(".*") Then
                    Else
                        LB.Items.Add(SS)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Loads the file type profiles.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Public Sub LoadFileTypeProfiles(ByRef CB As ComboBox)

        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        s = " SELECT [ProfileName] FROM [LoadProfile] order by [ProfileName] "
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    CB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Gets the included file type where in.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns>System.String.</returns>
    Public Function getIncludedFileTypeWhereIn(ByVal UserID As String, ByVal DirName As String) As String

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""
        Dim WC As String = ""
        Dim bFound As Boolean = False

        DirName = UTIL.RemoveSingleQuotes(DirName)


        s = " SELECT [UserID]"
        s = s + " ,[ExtCode]"
        s = s + " ,[FQN]"
        s = s + " FROM IncludedFiles "
        s = s + " where Userid = '" + UserID + "' "
        s = s + " and FQN = '" + DirName + "'"


        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    bFound = True
                    Dim SS As String = RSData.GetValue(1).ToString.ToLower
                    If SS.Equals(".zip") Then
                        Console.WriteLine("XX11 ZIP")
                    End If
                    WC += SS + ","
                Loop
                If bFound Then
                    WC = WC.Trim.Substring(0, WC.Length - 1)
                End If
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return WC
    End Function

    ''' <summary>
    ''' Gets the included file type where in.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Public Function getIncludedFileTypeWhereIn(ByVal UserID As String) As Dictionary(Of String, String)

        Dim TDict As New Dictionary(Of String, String)
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""
        Dim WC As String = ""
        Dim bFound As Boolean = False
        Dim CurrDir As String = ""
        Dim ExtCode As String = ""
        Dim PrevDir As String = ""
        Dim iCnt As Integer = 0
        Dim idx As Integer = 0

        s = " SELECT distinct ExtCode FROM IncludedFiles where Userid = '" + UserID + "'"

        s = "select distinct FQN, EXtcode from IncludedFiles where UserID = '" + UserID + "'"
        Try
            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(s, Conn)
                Dim RSData As SqlDataReader = Nothing

                RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read()
                        bFound = True
                        CurrDir = RSData.GetValue(0).ToString.ToLower
                        ExtCode = RSData.GetValue(1).ToString.ToLower
                        If PrevDir <> CurrDir And iCnt > 0 Then
                            'WDM Do not remove the last commas as it is used in the contains stmt later in the code
                            'If WC.Contains(",") Then
                            '    WC = WC.Trim.Substring(0, WC.Length - 1)
                            'End If
                            If Not TDict.Keys.Contains(PrevDir) Then
                                TDict.Add(PrevDir, WC)
                                WC = ""
                                WC += ExtCode.ToLower + ","
                            Else
                                WC = ""
                                WC += ExtCode.ToLower + ","
                                TDict(PrevDir) = WC
                            End If
                        Else
                            WC += ExtCode.ToLower + ","
                        End If
                        iCnt += 1
                        PrevDir = CurrDir
                    Loop
                End If

                If Not TDict.Keys.Contains(CurrDir) Then
                    WC += ExtCode.ToLower + ","
                    'WC = WC.Trim.Substring(0, WC.Length - 1)
                    TDict.Add(PrevDir, WC)
                    WC = ""
                    WC += ExtCode.ToLower + ","
                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getIncluded Exts 00 : " + ex.Message)
            Console.WriteLine("ERROR getIncluded Exts 00 : " + ex.Message)
        End Try

        Return TDict
    End Function


    ''' <summary>
    ''' Loads the included file types.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="DirName">Name of the dir.</param>
    Public Sub LoadIncludedFileTypes(ByRef LB As ListBox, ByVal UserID As String, ByVal DirName As String)
        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        DirName = UTIL.RemoveSingleQuotes(DirName)

        s = " SELECT [UserID]"
        s = s + " ,[ExtCode]"
        s = s + " ,[FQN]"
        s = s + " FROM IncludedFiles "
        s = s + " where Userid = '" + UserID + "' "
        s = s + " and FQN = '" + DirName + "'"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(1).ToString
                    LB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Loads the excluded file types.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="DirName">Name of the dir.</param>
    Public Sub LoadExcludedFileTypes(ByRef LB As ListBox, ByVal UserID As String, ByVal DirName As String)
        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim s As String = ""

        DirName = UTIL.RemoveSingleQuotes(DirName)

        s = " SELECT [UserID]"
        s = s + " ,[ExtCode]"
        s = s + " ,[FQN]"
        s = s + " FROM ExcludedFiles "
        s = s + " where Userid = '" + UserID + "' "
        s = s + " and FQN = '" + DirName + "'"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(s, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(1).ToString
                    LB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Gets the active email folders.
    ''' </summary>
    ''' <param name="TopLevelOutlookFolderName">Name of the top level outlook folder.</param>
    ''' <param name="LB">The lb.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="CF">The cf.</param>
    ''' <param name="ArchivedEmailFolders">The archived email folders.</param>
    Sub GetActiveEmailFolders(ByVal TopLevelOutlookFolderName As String, ByRef LB As ListBox, ByVal UserID As String, ByVal CF As SortedList(Of String, String), ByVal ArchivedEmailFolders As ArrayList)

        ArchivedEmailFolders.Clear()

        TopLevelOutlookFolderName = UTIL.RemoveSingleQuotes(TopLevelOutlookFolderName)

        Dim S As String = " "
        S = " Select distinct FolderName "
        S = S + " FROM EmailFolder "
        S = S + " where (UserID = '" + gCurrUserGuidID + "' "
        S = S + " and SelectedForArchive = 'Y' "
        S = S + " and FolderName like '" + TopLevelOutlookFolderName + "') "
        S = S + " or isSysDefault = 1 "
        S = S + " order by FolderName "

        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    Dim A2 As String() = SS.Split(CChar("|"))
                    SS = A2(UBound(A2))
                    LB.Items.Add(SS)
                    ArchivedEmailFolders.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing

            'Dim S  = "Update EmailFolder set SelectedForArchive = NULL where UserID = '" + gCurrUserGuidID + "'"
            'Dim BB As Boolean = ExecuteSqlNoTx(S)

            Dim BB As Boolean = True

            Dim B1 As Boolean = False
            If BB Then
                For II As Integer = 0 To LB.Items.Count - 1
                    ActivateArchiveFolder(TopLevelOutlookFolderName, LB.Items(II).ToString, UserID)
                Next
            End If

        End Using

    End Sub

    ''' <summary>
    ''' Activates the archive folder.
    ''' </summary>
    ''' <param name="ParentFolder">The parent folder.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    Sub ActivateArchiveFolder(ByVal ParentFolder As String, ByVal FolderName As String, ByVal UserID As String)
        'Update EmailFolder set
        'SelectedForArchive = 'Y'
        'where UserID = 'wmiller'
        'and FolderName = '_Passage'
        'and ParentFolderName = 'Personal Folders'
        Dim FolderFQN As String = ParentFolder + "|" + FolderName
        FolderFQN = UTIL.RemoveSingleQuotes(FolderFQN)
        Dim S As String = "Update EmailFolder set SelectedForArchive = 'Y' where UserID = '" + UserID + "' and FolderName = '" + FolderFQN + "' and FileDirectory = '" + ParentFolder + "' "
        Dim B1 As Boolean = ExecuteSqlNoTx(S)
        If Not B1 Then
            MessageBox.Show("Failed to Activate folder " + FolderName)
        End If
    End Sub

    ''' <summary>
    ''' Des the activate archive folder.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    Sub deActivateArchiveFolder(ByVal FolderName As String, ByVal UserID As String)
        Dim S As String = "Update EmailFolder set SelectedForArchive = 'N' where UserID = '" + UserID + "' and FolderName = '" + FolderName + "'"
        Dim B1 As Boolean = ExecuteSqlNoTx(S)
        If Not B1 Then
            MessageBox.Show("Failed to Activate folder " + FolderName)
        End If
    End Sub

    ''' <summary>
    ''' Sets the active email folders.
    ''' </summary>
    ''' <param name="TopLevelOutlookFolder">The top level outlook folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function setActiveEmailFolders(ByVal TopLevelOutlookFolder As String, ByVal UserID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SubFoldersToProcess As Integer = 0

        Dim SLB As New SortedList
        Dim S As String = " Select distinct FolderName "
        S = S + " FROM EmailFolder "
        S = S + " where UserID = '" + UserID + "' and FolderName like '" + TopLevelOutlookFolder + "|%'  "
        S = S + " and SelectedForArchive = 'Y' "
        S = S + " or isSysDefault = 1 "
        S = S + " order by FolderName "

        '        select distinct FolderName from EmailFolder
        'where FolderName like 'Personal Folders|%' and UserID = 'wmiller'

        'Dim A (9)
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    SubFoldersToProcess += 1
                    Dim SS As String = RSData.GetValue(0).ToString
                    Dim bKeyExists As Integer = -1
                    bKeyExists = SLB.IndexOfKey(SS)
                    If bKeyExists < 0 Then
                        'If CF.ContainsKey(SS) Then
                        '    SLB.Add(SS, SS)
                        'End If
                        SLB.Add(SS, SS)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing

            ''** in - Determined we may not need to do the following on 9/27/2009
            'Dim WeNeedThis As Boolean = True
            'If WeNeedThis Then
            '    Dim S  = "Update EmailFolder set SelectedForArchive = 'N' where UserID = '" + UserID  + "'"
            '    Dim BB As Boolean = ExecuteSqlNoTx(S)
            '    Dim B1 As Boolean = False
            '    If BB Then
            '        For II As Integer = 0 To SLB.Count - 1
            '            If ddebug Then Debug.Print(SLB.GetKey(II).ToString)
            '            S  = "Update EmailFolder set SelectedForArchive = 'Y' where UserID = '" + UserID  + "' and FolderName = '" + SLB.GetKey(II).ToString + "'"
            '            B1 = ExecuteSqlNoTx(S)
            '            If Not B1 Then
            '                messagebox.show("Failed to set the Selected For Archive flag for folder " + SLB.GetKey(II).ToString)
            '            End If
            '        Next
            '    End If
            'End If
        End Using
        Return SubFoldersToProcess
    End Function

    ''' <summary>
    ''' Gets the directory data.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="DBID">The dbid.</param>
    ''' <param name="IncludeSubDirs">The include sub dirs.</param>
    ''' <param name="VersionFiles">The version files.</param>
    ''' <param name="FolderDisabled">The folder disabled.</param>
    ''' <param name="ckMetaData">The ck meta data.</param>
    ''' <param name="ckPublic">The ck public.</param>
    ''' <param name="OcrDirectory">The ocr directory.</param>
    ''' <param name="isSysDefault">The is system default.</param>
    ''' <param name="ArchiveSkipBit">if set to <c>true</c> [archive skip bit].</param>
    ''' <param name="ListenForChanges">if set to <c>true</c> [listen for changes].</param>
    ''' <param name="ListenDirectory">if set to <c>true</c> [listen directory].</param>
    ''' <param name="ListenSubDirectory">if set to <c>true</c> [listen sub directory].</param>
    ''' <param name="DirGuid">The dir unique identifier.</param>
    ''' <param name="OcrPdf">The ocr PDF.</param>
    ''' <param name="DeleteOnArchive">The delete on archive.</param>
    Sub GetDirectoryData(ByVal UserID As String,
                         ByVal FQN As String,
                         ByRef DBID As String,
                         ByRef IncludeSubDirs As String,
                         ByRef VersionFiles As String,
                         ByRef FolderDisabled As String,
                         ByRef ckMetaData As String,
                         ByRef ckPublic As String,
                         ByRef OcrDirectory As String,
                         ByRef isSysDefault As String,
                         ByRef ArchiveSkipBit As Boolean,
                         ByRef ListenForChanges As Boolean,
                         ByRef ListenDirectory As Boolean,
                         ByRef ListenSubDirectory As Boolean,
                         ByRef DirGuid As String, ByRef OcrPdf As String, ByRef DeleteOnArchive As String)

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = "Select IncludeSubDirs, DB_ID, VersionFiles, ckDisableDir, ckMetaData, ckPublic, OcrDirectory,isSysDefault, ArchiveSkipBit, DirGuid, ListenDirectory,ListenSubDirectory, OcrPdf, DeleteOnArchive FROM [Directory] where [UserID] = '" + UserID + "' and FQN = '" + FQN + "'"
        'Dim A (9)
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    IncludeSubDirs = RSData.GetValue(0).ToString
                    DBID = RSData.GetValue(1).ToString
                    VersionFiles = RSData.GetValue(2).ToString
                    FolderDisabled = RSData.GetValue(3).ToString
                    ckMetaData = RSData.GetValue(4).ToString
                    ckPublic = RSData.GetValue(5).ToString
                    OcrDirectory = RSData.GetValue(6).ToString
                    isSysDefault = RSData.GetValue(7).ToString
                    ArchiveSkipBit = RSData.GetBoolean(8)
                    DirGuid = RSData.GetValue(9).ToString
                    Dim SX As String = RSData.GetValue(10).ToString
                    SX = RSData.GetValue(11).ToString
                    OcrPdf = RSData.GetValue(12).ToString
                    DeleteOnArchive = RSData.GetValue(13).ToString
                    Try
                        ListenDirectory = RSData.GetBoolean(10)
                    Catch ex As Exception
                        ListenDirectory = False
                    End Try
                    Try
                        ListenSubDirectory = RSData.GetBoolean(11)
                    Catch ex As Exception
                        ListenSubDirectory = False
                    End Try

                    'If sArchiveSkipBit Then
                    '    ArchiveSkipBit = True
                    'Else
                    '    ArchiveSkipBit = False
                    'End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Determines whether [is sub dir processed] [the specified user identifier].
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="DirFQN">The dir FQN.</param>
    ''' <returns><c>true</c> if [is sub dir processed] [the specified user identifier]; otherwise, <c>false</c>.</returns>
    Function isSubDirProcessed(ByVal UserID As String, ByVal DirFQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        DirFQN = UTIL.RemoveSingleQuotes(DirFQN)
        Dim S As String = "Select IncludeSubDirs FROM [Directory] where [UserID] = '" + UserID + "' and FQN = '" + DirFQN + "'"
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim B As Boolean = False
        Dim IncludeSubDirs As String = ""
        Try
            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read()
                        IncludeSubDirs = RSData.GetValue(0).ToString
                        If IncludeSubDirs.ToUpper.Equals("Y") Then
                            B = True
                        Else
                            B = False
                        End If
                    Loop
                End If
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR isSubDirProcessed 100: ", ex)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Gets the directories.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ShowDisabled">if set to <c>true</c> [show disabled].</param>
    Sub GetDirectories(ByRef LB As ListBox, ByVal UserID As String, ByVal ShowDisabled As Boolean)
        '*WDM 7/20/2009 - Modified query to bring back DISTINCT directories
        Dim S As String = ""
        S = "update Directory set ckDisableDir = 'N'  where [UserID] = '" + gCurrUserGuidID + "' and ckDisableDir is null "
        ExecuteSqlNewConn(90105, S)

        S = ""
        If ShowDisabled = True Then
            S = "Select    distinct [FQN], ckDisableDir " + Environment.NewLine
            S = S + "             FROM [Directory] " + Environment.NewLine
            S = S + " where [UserID] = '" + gCurrUserGuidID + "' " + Environment.NewLine
            S = S + " and (QuickRefEntry = 0  or QuickRefEntry is null) and ckDisableDir = 'Y'" + Environment.NewLine
            S = S + " or isSysDefault = 1" + Environment.NewLine
            S = S + " group by FQN, ckDisableDir " + Environment.NewLine
            S = S + " order by fqn " + Environment.NewLine
        Else
            S = "Select    distinct [FQN], ckDisableDir " + Environment.NewLine
            S = S + "             FROM [Directory] " + Environment.NewLine
            S = S + " where [UserID] = '" + gCurrUserGuidID + "' " + Environment.NewLine
            S = S + " and (QuickRefEntry = 0  or QuickRefEntry is null) and ckDisableDir <> 'Y'  " + Environment.NewLine
            '** S = S + " or isSysDefault = 1" + environment.NewLine
            S = S + " group by FQN, ckDisableDir " + Environment.NewLine
            S = S + " order by fqn " + Environment.NewLine
        End If

        'Clipboard.Clear()
        'Clipboard.SetText(S)

        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            Dim II As Integer = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    II += 1
                    Dim SS As String = RSData.GetValue(0).ToString
                    'frmReconMain.SB2.Text = "Processing Dir/File # " + II.ToString
                    'frmReconMain.Refresh()
                    Application.DoEvents()
                    If InStr(SS, "%userid%", CompareMethod.Text) > 0 Then
                        LB.Items.Add(SS)
                    ElseIf System.IO.Directory.Exists(SS) Then
                        LB.Items.Add(SS)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
    End Sub

    ''' <summary>
    ''' Gets the directory dictionary.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Function GetDirectoryDICT(ByVal UserID As String) As Dictionary(Of String, String)
        '*WDM 11/14/2020 - Modified query to bring back list of directories

        Dim LOS As New Dictionary(Of String, String)
        Dim S As String = ""
        S = ""

        S = "Select [FQN], IncludeSubDirs " + Environment.NewLine
        S = S + "  FROM [Directory] " + Environment.NewLine
        S = S + "  where [UserID] = '" + UserID + "' " + Environment.NewLine
        S = S + "  order by fqn " + Environment.NewLine

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Using command
                Dim RSData As SqlDataReader = Nothing
                Using RSData
                    RSData = command.ExecuteReader()
                    Dim II As Integer = 0
                    If RSData.HasRows Then
                        Do While RSData.Read()
                            Dim SS As String = RSData.GetValue(0).ToString
                            Dim SD As String = RSData.GetValue(1).ToString
                            If Not LOS.Keys.Contains(SS) Then
                                LOS.Add(SS, SD)
                            End If
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return LOS

    End Function


    ''' <summary>
    ''' Gets the directories.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>List(Of System.String).</returns>
    Function GetDirectories(ByVal UserID As String) As List(Of String)
        '*WDM 11/14/2020 - Modified query to bring back list of directories
        Dim LOS As New List(Of String)
        Dim S As String = ""
        S = ""

        S = "Select    distinct [FQN] " + Environment.NewLine
        S = S + "             FROM [Directory] " + Environment.NewLine
        S = S + " where [UserID] = '" + UserID + "' " + Environment.NewLine
        S = S + " order by fqn " + Environment.NewLine

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Using command
                Dim RSData As SqlDataReader = Nothing
                Using RSData
                    RSData = command.ExecuteReader()
                    Dim II As Integer = 0
                    If RSData.HasRows Then
                        Do While RSData.Read()
                            Dim SS As String = RSData.GetValue(0).ToString
                            LOS.Add(SS)
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return LOS

    End Function

    ''' <summary>
    ''' Gets the included files.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    Sub GetIncludedFiles(ByRef LB As ListBox, ByVal UserID As String, ByVal FQN As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = "Select [ExtCode] FROM [IncludedFiles] where [UserID] = '" + UserID + "'  and [FQN] = '" + FQN + "'"

        LB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim II As Integer = 0
        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    II += 1
                    frmMain.SB2.Text = "Processing Extension# " + II.ToString
                    frmMain.Refresh()
                    Application.DoEvents()
                    Dim SS As String = RSData.GetValue(0).ToString
                    LB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Gets the active databases.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Sub GetActiveDatabases(ByRef CB As ComboBox)

        Dim S As String = " SELECT [DB_ID] FROM [Databases] "

        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim SS As String = RSData.GetValue(0).ToString
                    CB.Items.Add(SS)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Gets the process as list.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Public Sub GetProcessAsList(ByRef CB As ComboBox)

        Dim S As String = "Select [ExtCode] ,[ProcessExtCode] FROM [ProcessFileAs] order by [ExtCode],[ProcessExtCode]"

        CB.Items.Clear()
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim P As String = RSData.GetValue(0).ToString
                    Dim C As String = RSData.GetValue(1).ToString
                    CB.Items.Add(P + " --> " + C)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Cks the recon parm exists.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ReconParm">The recon parm.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckReconParmExists(ByVal UserID As String, ByVal ReconParm As String) As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "Select count(*) FROM [RunParms] "
        S = S + " where Parm = '" + ReconParm + "' "
        S = S + " and UserID = '" + UserID + "'"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B
    End Function

    ''' <summary>
    ''' Cks the process as exists.
    ''' </summary>
    ''' <param name="Pext">The pext.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckProcessAsExists(ByVal Pext As String) As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "Select count(*) FROM [ProcessFileAs] where [ExtCode] = '" + Pext + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B
    End Function

    ''' <summary>
    ''' Cks the ext exists.
    ''' </summary>
    ''' <param name="tExt">The t ext.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckExtExists(ByVal tExt As String) As Boolean
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        S = "Select count(*) from AvailFileTypes where ExtCode = '" + tExt + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B
    End Function

    ''' <summary>
    ''' Cks the directory exists.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckDirectoryExists(ByVal UserID As String, ByVal FQN As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)

        FQN = UTIL.RemoveSingleQuotes(FQN)

        S = "Select count(*) FROM [Directory] "
        S = S + " where FQN = '" + FQN + "' "
        S = S + " and UserID = '" + UserID + "'"

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            RSData.Read()
            cnt = CInt(RSData.GetValue(0).ToString)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B
    End Function

    ''' <summary>
    ''' Gets the rcon parm.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ParmID">The parm identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getRconParm(ByVal UserID As String, ByVal ParmID As String) As String

        Dim S As String = " SELECT [ParmValue] FROM [RunParms] where Parm = '" + ParmID + "' and UserID = '" + UserID + "'"
        Dim SS As String = ""

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    SS = RSData.GetValue(0).ToString
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return SS
    End Function

    ''' <summary>
    ''' Executes the SQL new connection.
    ''' </summary>
    ''' <param name="sql">The SQL.</param>
    ''' <param name="ConnStr">The connection string.</param>
    ''' <param name="ValidateOwnerShip">if set to <c>true</c> [validate owner ship].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ExecuteSqlNewConn(ByVal sql As String, ByVal ConnStr As String, ByVal ValidateOwnerShip As Boolean) As Boolean
        If ValidateOwnerShip = True Then
            If TgtGuid.Length = 0 Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.02 - TgtGuid left blank and is required, contact ADMIN as this is an error.")
                LOG.WriteToArchiveLog("ERROR 666.02 - TgtGuid left blank and is required, contact ADMIN as this is an error.")
                Return False
            End If
            Dim isOwner As Boolean = ckContentOwnership(TgtGuid, gCurrUserGuidID)
            If isOwner = False Then
                ' If gRunUnattended = False Then MessageBox.Show("ERROR 666.02b - This will be removed - tried to update content you do not own, ABORTED!")
                LOG.WriteToTraceLog("ExecuteSql2: User '" + gCurrUserGuidID + "' tried to change '" + TgtGuid + "' w/o ownership.")
                Return False
            End If
        End If
        Dim TxName As String = "TX001"
        Dim rc As Boolean = False
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim dbCmd As SqlCommand = Conn.CreateCommand()
            dbCmd.Connection = Conn
            Try
                dbCmd.CommandText = sql
                dbCmd.ExecuteNonQuery()
                Dim debug As Boolean = True
                rc = True
            Catch ex As Exception
                rc = False
                Console.WriteLine("Exception Type: {0}", ex.GetType())
                Console.WriteLine("  Message: {0}" + ex.Message)
                Console.WriteLine(sql)
                ' xTrace(997110, "ExecuteSql: ", "-----------------------")
                ' xTrace(997111, "ExecuteSql: ", ex.Message.ToString)
                ' xTrace(997112, "ExecuteSql: ", ex.StackTrace.ToString)
                ' xTrace(997113, "ExecuteSql: ", sql)
                LOG.WriteToArchiveLog("clsDatabaseARCH : ExecuteSql : 3382 : ", ex)
            End Try
        End Using
        If Conn.State = ConnectionState.Closed Then
            Conn.Close()
        End If
        Conn = Nothing
        Return rc
    End Function

    ''' <summary>
    ''' Gets the email database connection string.
    ''' </summary>
    ''' <param name="DBID">The dbid.</param>
    ''' <returns>System.String.</returns>
    Function GetEmailDBConnStr(ByRef DBID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select DB_CONN_STR from databases where DB_ID = '" + DBID + "' "
        Dim A(9) As String
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    DbConnStr = RSData.GetValue(0).ToString
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        Return DbConnStr

    End Function

    ''' <summary>
    ''' Gets the email folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFolders">a folders.</param>
    Sub GetEmailFolders(ByRef UID As String, ByRef aFolders As String())

        Dim S As String = "Select "
        S = S + "  [FolderName]"
        S = S + " FROM Email "
        S = S + " where UserID = '" + UID + "' "

        ReDim aFolders(0)
        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    DbConnStr = RSData.GetValue(0).ToString
                    If I = 0 Then
                        aFolders(0) = DbConnStr
                    Else
                        ReDim Preserve aFolders(I)
                        aFolders(I) = DbConnStr
                    End If
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Gets the user directories.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Public Function GetUserDirectories(ByVal UID As String) As Dictionary(Of String, String)

        Dim LOF As New Dictionary(Of String, String)
        IXV1 = 0
        DMA.IXV1 = 0
        Dim SQL As String = "SELECT Directory.FQN, 
                Directory.IncludeSubDirs
                FROM  Directory 
                WHERE ((Directory.UserID = '" + UID + "') OR
                (Directory.isSysDefault = 1)) and
		        Directory.ckDisableDir = 'N'
                order by Directory.fqn"

        ReDim aFolders(0)
        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim FQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim ckDisableDir As String = ""
        Dim FirstEntryComplete As Boolean = False

        Dim ListOfFiles As New List(Of String)

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(SQL, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    FQN = RSData.GetValue(0).ToString
                    IncludeSubDirs = RSData.GetValue(1).ToString

                    If Not LOF.Keys.Contains(FQN) Then
                        LOF.Add(FQN, IncludeSubDirs)
                    End If
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        Return LOF

    End Function

    ''' <summary>
    ''' Gets the content archive file folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFolders">a folders.</param>
    Public Sub GetContentArchiveFileFolders(ByVal UID As String, ByRef aFolders As String())
        IXV1 = 0
        DMA.IXV1 = 0
        Dim S As String = " "
        S = S + " SELECT Directory.FQN, "
        S = S + " Directory.IncludeSubDirs, "
        S = S + " Directory.DB_ID,"
        S = S + " Directory.VersionFiles, "
        S = S + " Directory.ckDisableDir, "
        S = S + " Directory.OcrDirectory, "
        S = S + " Directory.RetentionCode, "
        S = S + " SubDir.SUBFQN "
        S = S + " FROM  Directory FULL OUTER JOIN"
        S = S + " SubDir ON Directory.FQN = SubDir.FQN"
        S = S + " WHERE (Directory.UserID = '" + UID + "') OR"
        S = S + " (Directory.isSysDefault = 1) "
        S = S + " order by Directory.fqn"

        ReDim aFolders(0)
        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim FQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim VersionFiles As String = ""
        Dim DisableFolder As String = ""
        Dim OcrDirectory As String = ""
        Dim RetentionCode As String = ""
        Dim FirstEntryComplete As Boolean = False
        Dim SUBFQN As String = ""

        Dim ListOfFiles As New List(Of String)

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()

                    FQN = RSData.GetValue(0).ToString
                    FQN = UTIL.RemoveSingleQuotes(FQN)

                    If Not Directory.Exists(FQN) Then
                        GoTo SkipThisOne
                    End If

                    IncludeSubDirs = RSData.GetValue(1).ToString
                    DB_ID = RSData.GetValue(2).ToString
                    VersionFiles = RSData.GetValue(3).ToString
                    DisableFolder = RSData.GetValue(4).ToString
                    OcrDirectory = RSData.GetValue(5).ToString
                    RetentionCode = RSData.GetValue(6).ToString
                    SUBFQN = RSData.GetValue(7).ToString

                    If DisableFolder.ToUpper.Equals("Y") Then
                        GoTo SkipThisOne
                    End If

                    If SUBFQN.Length = 0 Then
                        '** do nothing
                    ElseIf SUBFQN.Trim.Length > 0 Then
                        FQN = SUBFQN
                    End If

                    ListOfFiles.Clear()
                    If IncludeSubDirs.Equals("Y") Then
                        'ListOfFiles = DMA.GetFilesRecursive(FQN)
                        'DMA.GetAllDirs(FQN, ListOfFiles)
                        If bUseCommandProcessForInventory = 1 Then
                            Dim BB As Boolean = DMA.GetSubDirs(FQN, ListOfFiles)
                            If BB = False Then
                                ListOfFiles = DMA.GetDirsRecursive(FQN)
                            End If
                        Else
                            ListOfFiles = DMA.GetDirsRecursive(FQN)
                        End If
                    End If

                    If Not ListOfFiles.Contains(FQN) Then
                        ListOfFiles.Add(FQN)
                    End If

                    For k As Integer = 0 To ListOfFiles.Count - 1
                        Dim tFqn As String = ListOfFiles.Item(k)
                        If FirstEntryComplete = False Then
                            FirstEntryComplete = True
                            aFolders(0) = FQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode
                        Else
                            Dim X As Integer = UBound(aFolders) + 1
                            ReDim Preserve aFolders(X)
                            aFolders(X) = FQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode
                        End If
                    Next
SkipThisOne:
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Gets the content archive file folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="tgtFolders">The TGT folders.</param>
    ''' <param name="TgtFolder">The TGT folder.</param>
    Public Sub GetContentArchiveFileFolders(ByVal UID As String, ByRef tgtFolders As List(Of String), ByVal TgtFolder As String)
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try

            ', ByRef tgtFolders As List(Of String)
            If UID Is Nothing Then
                UID = gCurrUserGuidID
            End If
            If UID.Length = 0 Then
                UID = gCurrUserGuidID
            End If
            TgtFolder = UTIL.RemoveSingleQuotes(TgtFolder)

            Dim S As String = " "
            IXV1 = 0
            DMA.IXV1 = 0
            Dim AutoIncludeSubDirs As String = System.Configuration.ConfigurationManager.AppSettings("AutoIncludeSubDirs")

            'S = "delete FROM [DirectoryTemp] where [gCurrUserGuidID] = '" + gCurrUserGuidID + "' "
            'Me.ExecuteSqlNewConn(S, False)

            S = S + " SELECT Directory.FQN, "
            S = S + " Directory.IncludeSubDirs, "
            S = S + " Directory.DB_ID,"
            S = S + " Directory.VersionFiles, "
            S = S + " Directory.ckDisableDir, "
            S = S + " Directory.OcrDirectory, "
            S = S + " Directory.RetentionCode, "
            S = S + " Directory.ArchiveSkipBit, "
            S = S + " Directory.OcrPdf, "
            S = S + " Directory.DeleteOnArchive, "
            S = S + " Directory.ckPublic "
            S = S + " FROM  Directory "
            If TgtFolder.Trim.Length > 0 Then
                S = S + " WHERE Directory.UserID = '" + UID + "' and (AdminDisabled = 0 or AdminDisabled is null) and FQN = '" + TgtFolder + "' or isSysDefault = 1 "
            Else
                S = S + " WHERE Directory.UserID = '" + UID + "' and (AdminDisabled = 0 or AdminDisabled is null)  or isSysDefault = 1 "
            End If

            S = S + " order by Directory.fqn"

            tgtFolders.Clear()

            Dim I As Integer = 0

            Dim ConnStr As String = getRepoConnStr()
            Dim Conn As New SqlConnection(ConnStr)
            Dim b As Boolean = False

            Dim FQN As String = ""
            Dim IncludeSubDirs As String = ""
            Dim DB_ID As String = ""
            Dim VersionFiles As String = ""
            Dim DisableFolder As String = ""
            Dim OcrDirectory As String = ""
            Dim OcrPdf As String = ""
            Dim RetentionCode As String = ""
            Dim FirstEntryComplete As Boolean = False
            Dim SUBFQN As String = ""
            Dim ArchiveSkipBit As String = ""
            Dim DeleteOnArchive As String = ""
            Dim ckPublic As String = ""

            Dim ListOfFiles As New List(Of String)

            Dim DbConnStr As String = ""

            Using Conn
                If Conn.State = ConnectionState.Closed Then
                    Conn.Open()
                End If

                Dim command As New SqlCommand(S, Conn)
                Dim RSData As SqlDataReader = Nothing
                RSData = command.ExecuteReader()
                I = 0
                If RSData.HasRows Then
                    Do While RSData.Read()
                        If gTerminateImmediately Then
                            Return
                        End If
                        FQN = RSData.GetValue(0).ToString
                        FQN = UTIL.RemoveSingleQuotes(FQN)

                        Dim ParentDir As String = FQN

                        'If InStr(FQN, "xuser", CompareMethod.Text) > 0 Then
                        '    Console.WriteLine("Here 999")
                        'End If

                        If InStr(FQN, "%userid%", CompareMethod.Text) > 0 And Not gCurrLoginID.ToUpper.Equals("SERVICEMANAGER") Then
                            If gClipBoardActive = True Then Console.WriteLine("Wildcard directory: " + FQN)
                            Dim S1 As String = ""
                            Dim S2 As String = ""
                            Dim iLoc As Integer = InStr(FQN, "%userid%", CompareMethod.Text)
                            S1 = Mid(FQN, 1, iLoc - 1)
                            S2 = Mid(FQN, iLoc + Len("%userid%"))
                            Dim UserName As String = System.Environment.UserName
                            FQN = S1 + UserName + S2
                            ParentDir = FQN
                        Else
                            FQN = UTIL.ReplaceSingleQuotes(FQN)
                            If Not Directory.Exists(FQN) Then
                                GoTo SkipThisOne
                            End If
                        End If

                        IncludeSubDirs = RSData.GetValue(1).ToString
                        DB_ID = RSData.GetValue(2).ToString
                        VersionFiles = RSData.GetValue(3).ToString
                        DisableFolder = RSData.GetValue(4).ToString
                        OcrDirectory = RSData.GetValue(5).ToString
                        RetentionCode = RSData.GetValue(6).ToString
                        ArchiveSkipBit = RSData.GetValue(7).ToString
                        OcrPdf = RSData.GetValue(8).ToString
                        DeleteOnArchive = RSData.GetValue(9).ToString
                        ckPublic = RSData.GetValue(10).ToString

                        If DisableFolder.ToUpper.Equals("Y") Then
                            GoTo SkipThisOne
                        End If

                        If FQN.Trim.Length > MaxFileNameLength Then
                            FQN = getShortDirName(FQN)
                        End If

                        AddArchiveDir(FQN)

                        If SUBFQN.Length = 0 Then
                            '** do nothing
                        ElseIf SUBFQN.Trim.Length > 0 Then
                            FQN = SUBFQN
                        End If

                        ListOfFiles.Clear()

                        If Not ListOfFiles.Contains(FQN) Then
                            ListOfFiles.Add(FQN)
                        End If

                        For k As Integer = 0 To ListOfFiles.Count - 1
                            Dim tFqn As String = ListOfFiles.Item(k)
                            Dim SS As String = tFqn + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode + "|" + ParentDir + "|" + ArchiveSkipBit + "|" + OcrPdf + "|" + DeleteOnArchive + "|" + ckPublic
                            If tgtFolders.Contains(SS) Then
                                'Console.WriteLine("Duplicate: " + FQN)
                            Else
                                tgtFolders.Add(SS)
                            End If
                        Next
SkipThisOne:
                        I = I + 1
                    Loop
                End If
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
            End Using

        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR GetContentArchiveFileFolders: ", ex)
        Finally
            GC.Collect()
            GC.WaitForPendingFinalizers()
        End Try

    End Sub

    ''' <summary>
    ''' Sets the content archive file folder.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="tgtFolders">The TGT folders.</param>
    ''' <param name="TgtFolder">The TGT folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function setContentArchiveFileFolder(ByVal UID As String, ByRef tgtFolders As List(Of String), ByVal TgtFolder As String) As Boolean

        TgtFolder = UTIL.RemoveSingleQuotes(TgtFolder)

        Dim isGood As Boolean = False

        Dim S As String = " "
        IXV1 = 0
        DMA.IXV1 = 0
        Dim AutoIncludeSubDirs As String = System.Configuration.ConfigurationManager.AppSettings("AutoIncludeSubDirs")

        S = S + " SELECT Directory.FQN, "
        S = S + " Directory.IncludeSubDirs, "
        S = S + " Directory.DB_ID,"
        S = S + " Directory.VersionFiles, "
        S = S + " Directory.ckDisableDir, "
        S = S + " Directory.OcrDirectory, "
        S = S + " Directory.RetentionCode, "
        S = S + " Directory.ArchiveSkipBit "
        S = S + " FROM  Directory "
        If TgtFolder.Trim.Length > 0 Then
            S = S + " WHERE Directory.UserID = '" + UID + "' and (AdminDisabled = 0 or AdminDisabled is null) and FQN = '" + TgtFolder + "' "
        Else
            S = S + " WHERE Directory.UserID = '" + UID + "' and (AdminDisabled = 0 or AdminDisabled is null) "
        End If

        S = S + " order by Directory.fqn"

        tgtFolders.Clear()

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim FQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim VersionFiles As String = ""
        Dim DisableFolder As String = ""
        Dim OcrDirectory As String = ""
        Dim RetentionCode As String = ""
        Dim FirstEntryComplete As Boolean = False
        Dim SUBFQN As String = ""
        Dim ArchiveSkipBit As String = ""

        Dim ListOfFiles As New List(Of String)

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    isGood = True
                    If gTerminateImmediately Then
                        Return False
                    End If
                    FQN = RSData.GetValue(0).ToString
                    FQN = UTIL.RemoveSingleQuotes(FQN)

                    Dim ParentDir As String = FQN

                    'If InStr(FQN, "xuser", CompareMethod.Text) > 0 Then
                    '    Console.WriteLine("Here 999")
                    'End If

                    If InStr(FQN, "%userid%", CompareMethod.Text) > 0 And Not gCurrLoginID.ToUpper.Equals("SERVICEMANAGER") Then
                        If gClipBoardActive = True Then Console.WriteLine("Wildcard directory: " + FQN)
                        Dim S1 As String = ""
                        Dim S2 As String = ""
                        Dim iLoc As Integer = InStr(FQN, "%userid%", CompareMethod.Text)
                        S1 = Mid(FQN, 1, iLoc - 1)
                        S2 = Mid(FQN, iLoc + Len("%userid%"))
                        Dim UserName As String = System.Environment.UserName
                        FQN = S1 + UserName + S2
                        ParentDir = FQN
                    Else
                        FQN = UTIL.ReplaceSingleQuotes(FQN)
                        If Not Directory.Exists(FQN) Then
                            GoTo SkipThisOne
                        End If
                    End If

                    IncludeSubDirs = RSData.GetValue(1).ToString
                    DB_ID = RSData.GetValue(2).ToString
                    VersionFiles = RSData.GetValue(3).ToString
                    DisableFolder = RSData.GetValue(4).ToString
                    OcrDirectory = RSData.GetValue(5).ToString
                    RetentionCode = RSData.GetValue(6).ToString
                    ArchiveSkipBit = RSData.GetValue(7).ToString

                    If DisableFolder.ToUpper.Equals("Y") Then
                        GoTo SkipThisOne
                    End If

                    If FQN.Trim.Length > 254 Then
                        FQN = getShortDirName(FQN)
                    End If

                    AddArchiveDir(FQN)

                    If SUBFQN.Length = 0 Then
                        '** do nothing
                    ElseIf SUBFQN.Trim.Length > 0 Then
                        FQN = SUBFQN
                    End If

                    ListOfFiles.Clear()
                    If IncludeSubDirs.Equals("Y") And TgtFolder.Trim.Length = 0 Then
                        If bUseCommandProcessForInventory = 1 Then
                            Dim BB As Boolean = DMA.GetSubDirs(FQN, ListOfFiles)
                            If BB = False Then
                                ListOfFiles = DMA.GetDirsRecursive(FQN)
                            End If
                        Else
                            ListOfFiles = DMA.GetDirsRecursive(FQN)
                        End If
                    End If

                    If Not ListOfFiles.Contains(FQN) Then
                        ListOfFiles.Add(FQN)
                    End If

                    For k As Integer = 0 To ListOfFiles.Count - 1
                        Dim tFqn As String = ListOfFiles.Item(k)
                        Dim SS As String = tFqn + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode + "|" + ParentDir + "|" + ArchiveSkipBit
                        If tgtFolders.Contains(SS) Then
                            'Console.WriteLine("Duplicate: " + FQN)
                        Else
                            tgtFolders.Add(SS)
                        End If
                    Next
SkipThisOne:
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return isGood
    End Function

    ''' <summary>
    ''' xes the get content archive file folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFolders">a folders.</param>
    Public Sub xGetContentArchiveFileFolders(ByVal UID As String, ByRef aFolders As String())

        Dim S As String = " "
        S = S + " select FQN, IncludeSubDirs, DB_ID, VersionFiles, ckDisableDir, OcrDirectory, RetentionCode"
        S = S + " from Directory where UserID = '" + UID + "' or isSysDefault = 1 "
        S = S + " UNION ALL "
        S = S + " select subFQN as FQN, 'N' as IncludeSubDirs, 'na' AS DB_ID, VersionFiles, ckDisableDir, OcrDirectory, ' '  as RetentionCode "
        S = S + " from SubDir where UserID = '" + UID + "' or isSysDefault = 1 "
        S = S + " and subFQN not in (select FQN from Directory)"
        S = S + " ORDER BY FQN"

        ReDim aFolders(0)
        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim SUBFQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim VersionFiles As String = ""
        Dim DisableFolder As String = ""
        Dim OcrDirectory As String = ""
        Dim RetentionCode As String = ""

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    SUBFQN = RSData.GetValue(0).ToString
                    SUBFQN = UTIL.RemoveSingleQuotes(SUBFQN)
                    IncludeSubDirs = RSData.GetValue(1).ToString
                    DB_ID = RSData.GetValue(2).ToString
                    VersionFiles = RSData.GetValue(3).ToString
                    DisableFolder = RSData.GetValue(4).ToString
                    OcrDirectory = RSData.GetValue(5).ToString
                    RetentionCode = RSData.GetValue(6).ToString

                    If I = 0 Then
                        aFolders(0) = SUBFQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode
                    Else
                        ReDim Preserve aFolders(I)
                        aFolders(I) = SUBFQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + OcrDirectory + "|" + RetentionCode
                    End If
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

    End Sub

    ''' <summary>
    ''' Gets the content archive file folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFolders">a folders.</param>
    ''' <param name="DirPath">The dir path.</param>
    Public Sub GetContentArchiveFileFolders(ByVal UID As String, ByRef aFolders As String(), ByVal DirPath As String)

        Dim S As String = "Select     S.SUBFQN, D.IncludeSubDirs, D.DB_ID, D.VersionFiles, D.ckDisableDir, D.FQN"
        S = S + " FROM         Directory AS D FULL OUTER JOIN"
        S = S + "                       SubDir AS S ON D.UserID = S.UserID AND D.FQN = S.FQN"
        S = S + " WHERE     (D.UserID = '" + UID + "')"
        S = S + " ORDER BY S.SUBFQN"

        ReDim aFolders(0)
        Dim I As Integer = 0
        Dim DirFound As Boolean = False

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim SUBFQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim VersionFiles As String = ""
        Dim DisableFolder As String = ""
        Dim ParentDir As String = ""

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    SUBFQN = RSData.GetValue(0).ToString
                    SUBFQN = UTIL.RemoveSingleQuotes(SUBFQN)
                    IncludeSubDirs = RSData.GetValue(1).ToString
                    DB_ID = RSData.GetValue(2).ToString
                    VersionFiles = RSData.GetValue(3).ToString
                    DisableFolder = RSData.GetValue(4).ToString
                    ParentDir = RSData.GetValue(5).ToString
                    ParentDir = UTIL.RemoveSingleQuotes(ParentDir)
                    If UCase(SUBFQN).Equals(UCase(DirPath)) Then
                        aFolders(0) = SUBFQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder
                        DirFound = True
                        Exit Do
                    End If
                    If SUBFQN.Length = 0 And (UCase(ParentDir).Equals(UCase(DirPath))) Then
                        aFolders(0) = ParentDir + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder
                        DirFound = True
                        Exit Do
                    End If
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
            If Not DirFound Then
                aFolders(0) = DirPath + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder
            End If
        End Using

    End Sub

    ''' <summary>
    ''' Gets the quick archive file folders.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFolders">a folders.</param>
    ''' <param name="DirPath">The dir path.</param>
    Public Sub GetQuickArchiveFileFolders(ByVal UID As String, ByRef aFolders As String(), ByVal DirPath As String)

        Dim S As String = "Select     S.SUBFQN, D.IncludeSubDirs, D.DB_ID, D.VersionFiles, D.ckDisableDir, D.FQN, D.RetentionCode"
        S = S + " FROM         QuickDirectory AS D FULL OUTER JOIN"
        S = S + "                       SubDir AS S ON D.UserID = S.UserID AND D.FQN = S.FQN"
        S = S + " WHERE     (D.UserID = '" + UID + "')"
        S = S + " ORDER BY S.SUBFQN"

        ReDim aFolders(0)
        Dim I As Integer = 0
        Dim DirFound As Boolean = False

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim SUBFQN As String = ""
        Dim IncludeSubDirs As String = ""
        Dim DB_ID As String = ""
        Dim VersionFiles As String = ""
        Dim DisableFolder As String = ""
        Dim ParentDir As String = ""
        Dim RetentionCode As String = ""

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            I = 0
            If RSData.HasRows Then
                Do While RSData.Read()
                    SUBFQN = RSData.GetValue(0).ToString
                    SUBFQN = UTIL.RemoveSingleQuotes(SUBFQN)
                    IncludeSubDirs = RSData.GetValue(1).ToString
                    DB_ID = RSData.GetValue(2).ToString
                    VersionFiles = RSData.GetValue(3).ToString
                    DisableFolder = RSData.GetValue(4).ToString
                    ParentDir = RSData.GetValue(5).ToString
                    ParentDir = UTIL.RemoveSingleQuotes(ParentDir)
                    RetentionCode = RSData.GetValue(6).ToString
                    If UCase(SUBFQN).Equals(UCase(DirPath)) Then
                        aFolders(0) = SUBFQN + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + RetentionCode
                        DirFound = True
                        Exit Do
                    End If
                    If SUBFQN.Length = 0 And (UCase(ParentDir).Equals(UCase(DirPath))) Then
                        aFolders(0) = ParentDir + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder + "|" + RetentionCode
                        DirFound = True
                        Exit Do
                    End If
                    I = I + 1
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
            If Not DirFound Then
                aFolders(0) = DirPath + "|" + IncludeSubDirs + "|" + DB_ID + "|" + VersionFiles + "|" + DisableFolder
            End If
        End Using

    End Sub

    '     SELECT [ArchiveEmails]
    '      ,[RemoveAfterArchive]
    '      ,[SetAsDefaultFolder]
    '      ,[ArchiveAfterXDays]
    '      ,[RemoveAfterXDays]
    '      ,[RemoveXDays]
    '      ,[ArchiveXDays]
    '      ,[DB_ID]
    '  FROM [Email]
    'where UserID = 'wmiller'
    ''' <summary>
    ''' Gets the email folder parms.
    ''' </summary>
    ''' <param name="TopFolder">The top folder.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="ArchiveEmails">The archive emails.</param>
    ''' <param name="RemoveAfterArchive">The remove after archive.</param>
    ''' <param name="SetAsDefaultFolder">The set as default folder.</param>
    ''' <param name="ArchiveAfterXDays">The archive after x days.</param>
    ''' <param name="RemoveAfterXDays">The remove after x days.</param>
    ''' <param name="RemoveXDays">The remove x days.</param>
    ''' <param name="ArchiveXDays">The archive x days.</param>
    ''' <param name="DB_ID">The database identifier.</param>
    ''' <param name="ArchiveOnlyIfRead">The archive only if read.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function GetEmailFolderParms(ByVal TopFolder As String, ByVal UID As String, ByVal FolderName As String, ByRef ArchiveEmails As String, ByRef RemoveAfterArchive As String, ByRef SetAsDefaultFolder As String, ByRef ArchiveAfterXDays As String, ByRef RemoveAfterXDays As String, ByRef RemoveXDays As String, ByRef ArchiveXDays As String, ByRef DB_ID As String, ByRef ArchiveOnlyIfRead As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ArchiveEmails = ""
        RemoveAfterArchive = ""
        SetAsDefaultFolder = ""
        ArchiveAfterXDays = ""
        RemoveAfterXDays = ""
        RemoveXDays = ""
        ArchiveXDays = ""
        DB_ID = ""

        Dim BB As Boolean = False

        FolderName = UTIL.RemoveSingleQuotes(FolderName)

        '** Sometimes, the full name includeing the "|" is passed in -
        '** If so, just remove the string up to the "|" and fix it,
        '** and continue.

        If InStr(FolderName, "|", CompareMethod.Text) > 0 Then
            FolderName = Mid(FolderName, InStr(FolderName, "|", CompareMethod.Text) + 1)
        End If

        Dim S As String = "Select [ArchiveEmails]"
        S = S + " ,[RemoveAfterArchive]"
        S = S + " ,[SetAsDefaultFolder]"
        S = S + " ,[ArchiveAfterXDays]"
        S = S + " ,[RemoveAfterXDays]"
        S = S + " ,[RemoveXDays]"
        S = S + " ,[ArchiveXDays]"
        S = S + " ,[DB_ID], ArchiveOnlyIfRead "
        S = S + " from [EmailArchParms] "
        S = S + " where UserID = '" + UID + "' "
        S = S + " and  [FolderName] = '" + TopFolder + "|" + FolderName + "'"

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    BB = True
                    ArchiveEmails = RSData.GetValue(0).ToString
                    RemoveAfterArchive = RSData.GetValue(1).ToString
                    SetAsDefaultFolder = RSData.GetValue(2).ToString
                    ArchiveAfterXDays = RSData.GetValue(3).ToString
                    RemoveAfterXDays = RSData.GetValue(4).ToString
                    RemoveXDays = RSData.GetValue(5).ToString
                    ArchiveXDays = RSData.GetValue(6).ToString
                    DB_ID = RSData.GetValue(7).ToString
                    ArchiveOnlyIfRead = RSData.GetValue(8).ToString
                Loop
            Else
                LOG.WriteToArchiveLog("ERROR GetEmailFolderParms 100: - could not find: " + S)
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return BB
    End Function

    ''' <summary>
    ''' Gets the email subject.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetEmailSubject(ByVal EmailGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim Subject As String = ""

        Dim BB As Boolean = False

        Dim S As String = "Select [Subject]"
        S = S + " from [Email] "
        S = S + " where EmailGuid = '" + EmailGuid + "' "

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    BB = True
                    Subject = RSData.GetValue(0).ToString
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return Subject
    End Function

    ''' <summary>
    ''' Gets the email attachment unique identifier.
    ''' </summary>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="CrcHASH">The CRC hash.</param>
    ''' <returns>System.String.</returns>
    Function GetEmailAttachmentGuid(ByVal AttachmentName As String, CrcHASH As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim RowGuid As String = ""

        Dim BB As Boolean = False

        Dim SS As String = "select RowGuid from EmailAttachment where AttachmentName = '" + AttachmentName + "' and CRC = '" + CrcHASH + "'"

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(SS, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    BB = True
                    RowGuid = RSData.GetValue(0).ToString
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return RowGuid
    End Function

    ''' <summary>
    ''' Gets the email body.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetEmailBody(ByVal EmailGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim Subject As String = ""

        Dim BB As Boolean = False

        Dim S As String = "Select [Body]"
        S = S + " from [Email] "
        S = S + " where EmailGuid = '" + EmailGuid + "' "

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    BB = True
                    Subject = RSData.GetValue(0).ToString
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return Subject
    End Function

    ''' <summary>
    ''' Gets the document title.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetDocTitle(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim TitleFound As Boolean = False

        Dim Subject As String = ""

        Dim BB As Boolean = False

        Dim S As String = "Select [AttributeValue]     "
        S = S + "   FROM [SourceAttribute]"
        S = S + " where [AttributeName] like 'Title'"
        S = S + " and [SourceGuid] = '" + SourceGuid + "'"

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                TitleFound = True

                BB = True
                Subject = RSData.GetValue(0).ToString

            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using

        If TitleFound = False Then
            Subject = "No subject metadata found, document name is: " + GetDocFilename(SourceGuid)
        End If

        Return Subject
    End Function

    ''' <summary>
    ''' Gets the document filename.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetDocFilename(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim FileName As String = ""

        Dim BB As Boolean = False

        Dim S As String = "Select [SourceName] FROM  [DataSource] where [SourceGuid] = '" + SourceGuid + "'"

        Dim I As Integer = 0

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim DbConnStr As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If
            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                BB = True
                RSData.Read()
                FileName = RSData.GetValue(0).ToString
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        If BB = False Then
            FileName = "No file name supplied for this content."
        Else
            FileName = Environment.NewLine + FileName
        End If
        Return FileName
    End Function

    ''' <summary>
    ''' Adds the included filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="IncludeSubDirs">The include sub dirs.</param>
    ''' <returns>ArrayList.</returns>
    Public Function AddIncludedFiletypes(ByVal FQN As String, ByVal IncludeSubDirs As String) As ArrayList
        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim L As New ArrayList
        Dim L2 As New ArrayList
        Dim AllDirs(0) As String
        Dim tDir As String = ""
        If IsNothing(IncludeSubDirs) Then
            IncludeSubDirs = "Y"
        End If
        IncludeSubDirs = IncludeSubDirs.ToUpper
        If IncludeSubDirs.Equals("N") Then
            tDir = FQN
            L = GetIncludedFiletypes(tDir)
        Else
            AllDirs = FQN.Split(CChar("\"))
            For i As Integer = 0 To UBound(AllDirs)
                tDir = tDir + AllDirs(i)
                L2 = GetIncludedFiletypes(tDir)
                tDir = tDir + "\"
                For j As Integer = 0 To L2.Count - 1
                    L.Add(L2(j))
                Next
            Next
        End If
        Return L
    End Function

    ''' <summary>
    ''' Adds the excluded filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="IncludeSubDirs">The include sub dirs.</param>
    ''' <returns>ArrayList.</returns>
    Public Function AddExcludedFiletypes(ByVal FQN As String, ByVal IncludeSubDirs As String) As ArrayList

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim L As New ArrayList
        Dim L2 As New ArrayList
        Dim AllDirs(0) As String
        Dim tDir As String = ""
        IncludeSubDirs = IncludeSubDirs.ToUpper
        If IncludeSubDirs.Equals("N") Then
            tDir = FQN
            L = GetExcludedFiletypes(tDir)
        Else
            AllDirs = FQN.Split(CChar("\"))
            For i As Integer = 0 To UBound(AllDirs)
                tDir = tDir + AllDirs(i)
                L2 = Me.GetExcludedFiletypes(tDir)
                For j As Integer = 0 To L2.Count - 1
                    L.Add(L2(j))
                Next
            Next
        End If
        Return L
    End Function

    ''' <summary>
    ''' Gets all included filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="IncludeSubDirs">The include sub dirs.</param>
    ''' <returns>ArrayList.</returns>
    Public Function GetAllIncludedFiletypes(ByVal FQN As String, ByVal IncludeSubDirs As String) As ArrayList
        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim L2 As New ArrayList
        Dim L As New ArrayList
        Dim AllDirs(0) As String
        Dim tDir As String = ""
        Dim K As Integer = 0

        If IsNothing(IncludeSubDirs) Then
            IncludeSubDirs = "Y"
        End If

        IncludeSubDirs = IncludeSubDirs.ToUpper
        If IncludeSubDirs.Equals("N") Then
            tDir = FQN
            L = GetIncludedFiletypes(tDir)
        Else
            AllDirs = FQN.Split(CChar("\"))
            For i As Integer = 0 To UBound(AllDirs)
                tDir = tDir + AllDirs(i)
                L2 = GetIncludedFiletypes(tDir)
                For K = 0 To L2.Count - 1
                    L.Add(L2(K))
                Next
                tDir = tDir + "\"
            Next

        End If
        Return L
    End Function

    ''' <summary>
    ''' Gets all excluded filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="IncludeSubDirs">The include sub dirs.</param>
    ''' <returns>ArrayList.</returns>
    Public Function GetAllExcludedFiletypes(ByVal FQN As String, ByVal IncludeSubDirs As String) As ArrayList
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim L As New ArrayList
        Dim L1 As New ArrayList
        Dim AllDirs(0) As String
        Dim tDir As String = ""
        Dim J As Integer = 0

        If IsNothing(IncludeSubDirs) Then
            IncludeSubDirs = "Y"
        End If

        IncludeSubDirs = IncludeSubDirs.ToUpper
        If IncludeSubDirs.Equals("N") Then
            tDir = FQN
            L = GetExcludedFiletypes(tDir)
        Else
            AllDirs = FQN.Split(CChar("\"))
            For i As Integer = 0 To UBound(AllDirs)
                tDir = tDir + AllDirs(i)
                L1 = Me.GetExcludedFiletypes(tDir)
                For ij = 0 To L1.Count - 1
                    L.Add(L1(J))
                Next
                tDir = tDir + "\"
            Next
        End If
        Return L
    End Function

    ''' <summary>
    ''' Gets the included filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>ArrayList.</returns>
    Public Function GetIncludedFiletypes(ByVal FQN As String) As ArrayList

        Dim L As New ArrayList

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = ""

        If FQN.Length = 0 Then
            S = "Select distinct [ExtCode] FROM [IncludedFiles] order by [ExtCode]"
        Else
            FQN = UTIL.RemoveSingleQuotes(FQN)
            S = "Select [ExtCode] FROM [IncludedFiles] where FQN = '" + FQN + "' order by [ExtCode]"
        End If

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Dim IncludeExt As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    IncludeExt = RSData.GetValue(0).ToString
                    IncludeExt = UCase(IncludeExt)
                    IncludeExt = IncludeExt.Trim
                    If Mid(IncludeExt, 1, 1) = "." Then
                        IncludeExt = Mid(IncludeExt, 2)
                        IncludeExt = IncludeExt.Trim
                    End If
                    If Not L.Contains(IncludeExt) Then
                        L.Add(IncludeExt)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
            L.Sort()
        End Using
        Return L
    End Function

    ''' <summary>
    ''' Gets the included filetypes by user identifier.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function GetIncludedFiletypesByUserID(ByVal UserID As String) As String

        Dim ConnStr As String = getRepoConnStr()
        Dim xlist As String = ""
        Dim S As String = ""
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim IncludeExt As String = ""


        S = "select distinct lower(extcode) from IncludedFiles where UserID = '" + UserID + "' "

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    xlist += RSData.GetValue(0).ToString + ","
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
        End Using
        Return xlist
    End Function


    ''' <summary>
    ''' Gets the excluded filetypes.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>ArrayList.</returns>
    Public Function GetExcludedFiletypes(ByVal FQN As String) As ArrayList

        Dim L As New ArrayList

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = "Select [ExtCode] FROM [ExcludedFiles] where FQN = '" + FQN + "' order by [ExtCode]"

        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False
        Dim IncludeExt As String = ""

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    IncludeExt = RSData.GetValue(0).ToString
                    IncludeExt = UCase(IncludeExt)
                    IncludeExt = IncludeExt.Trim
                    If Mid(IncludeExt, 1, 1) = "." Then
                        IncludeExt = Mid(IncludeExt, 2)
                        IncludeExt = IncludeExt.Trim
                    End If
                    If Not L.Contains(IncludeExt) Then
                        L.Add(IncludeExt)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
            Conn.Close()
            Conn = Nothing
            L.Sort()
        End Using

        Return L

    End Function

    ''' <summary>
    ''' Adds the secondary sourcetype.
    ''' </summary>
    ''' <param name="Sourcetypecode">The sourcetypecode.</param>
    ''' <param name="Sourcetypedesc">The sourcetypedesc.</param>
    ''' <param name="Storeexternal">The storeexternal.</param>
    ''' <param name="Indexable">The indexable.</param>
    Sub AddSecondarySOURCETYPE(ByVal Sourcetypecode As String, ByVal Sourcetypedesc As String, ByVal Storeexternal As String, ByVal Indexable As String)
        Dim ST As New clsSOURCETYPE
        ST.setSourcetypecode(Sourcetypecode)
        ST.setSourcetypedesc(Sourcetypedesc)
        ST.setStoreexternal(Storeexternal)
        ST.setIndexable(Indexable)
        ST.Insert()
    End Sub

    ''' <summary>
    ''' Deletes the secondary sourcetype.
    ''' </summary>
    ''' <param name="Sourcetypecode">The sourcetypecode.</param>
    Sub delSecondarySOURCETYPE(ByVal Sourcetypecode As String)
        Dim ST As New clsSOURCETYPE
        ST.setSourcetypecode(Sourcetypecode)
        Dim WhereClause As String = "Where SourceTypeCode = '" + Sourcetypecode + "'"
        ST.Delete(WhereClause)
    End Sub

    ''' <summary>
    ''' Finds all table indexes.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <returns>Array.</returns>
    Function FindAllTableIndexes(ByVal TBL As String) As Array
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SL As New SortedList
        Dim S As String = ""
        S = S + " select distinct si.name"
        S = S + " from sys.indexes si"
        S = S + " inner join sys.index_columns ic on si.object_id = ic.object_id and si.index_id = ic.index_id"
        S = S + " inner join information_schema.tables st on object_name(si.object_id) = st.table_name"
        S = S + " inner join information_schema.columns sc on ic.column_id = sc.ordinal_position and sc.table_name = st.table_name"
        S = S + " where si.name Is Not null And si.index_id > 0 And si.is_hypothetical = 0 "
        S = S + " and sc.table_name = '" + TBL + "'"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim IndexName As String = ""

        Dim TblIndexes(0) As String

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                IndexName = RSData.GetValue(0).ToString
                II = UBound(TblIndexes) + 1
                ReDim Preserve TblIndexes(II)
                TblIndexes(II) = IndexName
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        Return TblIndexes

    End Function

    ''' <summary>
    ''' Finds all index cols.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="IdxName">Name of the index.</param>
    ''' <returns>Array.</returns>
    Function FindAllIndexCols(ByVal TBL As String, ByVal IdxName As String) As Array
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SL As New SortedList
        Dim S As String = ""
        S = S + " select distinct sc.table_name,si.name,si.type_desc,sc.column_name"
        S = S + " from sys.indexes si"
        S = S + " inner join sys.index_columns ic on si.object_id = ic.object_id and si.index_id = ic.index_id"
        S = S + " inner join information_schema.tables st on object_name(si.object_id) = st.table_name"
        S = S + " inner join information_schema.columns sc on ic.column_id = sc.ordinal_position and sc.table_name = st.table_name"
        S = S + " where si.name Is Not null And si.index_id > 0 And si.is_hypothetical = 0 "
        S = S + " and sc.table_name = '" + TBL + "'"
        S = S + " and name = '" + IdxName + "'"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim ColName As String = ""

        Dim IndexColumns(0) As String

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                ColName = RSData.GetValue(3).ToString
                ColName = TBL + "|" + ColName
                II = UBound(IndexColumns) + 1
                ReDim Preserve IndexColumns(II)
                IndexColumns(II) = ColName
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        Return IndexColumns

    End Function

    ''' <summary>
    ''' Gets the type of the column data.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="ColName">Name of the col.</param>
    ''' <returns>System.String.</returns>
    Function getColumnDataType(ByVal TBL As String, ByVal ColName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SL As New SortedList
        Dim S As String = ""
        S = S + " SELECT table_name, column_name, is_nullable, data_type, character_maximum_length"
        S = S + " FROM information_schema.columns "
        S = S + " where  table_name = '" + TBL + "'"
        S = S + " AND column_name = '" + ColName + "'"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim DataType As String = ""
        Dim IsNullable As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                IsNullable = RSData.GetValue(2).ToString
                DataType = RSData.GetValue(3).ToString
                DataType = DataType + "|" + IsNullable
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        Return DataType

    End Function

    ''' <summary>
    ''' Gets the row by key.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="WC">The wc.</param>
    ''' <returns>SqlDataReader.</returns>
    Public Function GetRowByKey(ByVal TBL As String, ByVal WC As String) As SqlDataReader
        Try
            Dim Auth As String = ""
            Dim s As String = "Select * from " + TBL + " " + WC
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                Auth = rsData.GetValue(0).ToString
                Return rsData
            Else
                Return Nothing
            End If
        Catch ex As Exception
            ' xTrace(12330, "clsDataBase:GetRowByKey" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetRowByKey : 3963 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetRowByKey : 3931 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetRowByKey : 3945 : ", ex)
            Return Nothing
        End Try

    End Function

    ''' <summary>
    ''' Cks the arch email folder.
    ''' </summary>
    ''' <param name="KeyFolder">The key folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckArchEmailFolder(ByVal KeyFolder As String, ByVal UserID As String) As Integer

        Dim b As Boolean = True
        Dim S As String = "Select count(*) "
        S = S + "   FROM [EmailFolder]"
        S = S + " where [SelectedForArchive] = 'Y'"
        S = S + " and FolderName ='" + KeyFolder + "'"
        S = S + " and UserID ='" + UserID + "'"
        Dim i As Integer = 0
        Dim tQuery As String = ""

        'Dim i As Integer
        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the arch email folder identifier by folder.
    ''' </summary>
    ''' <param name="KeyFolder">The key folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getArchEmailFolderIDByFolder(ByVal KeyFolder As String, ByVal UserID As String) As String

        Dim b As Boolean = True
        Dim S As String = "Select FolderID "
        S = S + "   FROM [EmailFolder]"
        S = S + " where [SelectedForArchive] = 'Y'"
        S = S + " and FolderName ='" + KeyFolder + "'"
        S = S + " and UserID ='" + UserID + "'"
        Dim i As Integer = 0
        Dim tQuery As String = ""

        'Dim i As Integer
        Dim xint As String = ""

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            Try
                xint = RSData.GetValue(0).ToString
            Catch ex As Exception
                xint = ""
            End Try

            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return xint

    End Function

    ''' <summary>
    ''' Cks the arch child email folder.
    ''' </summary>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckArchChildEmailFolder(ByVal FolderID As String, ByVal UserID As String) As Integer

        Dim b As Boolean = True
        Dim S As String = "Select COUNT(*) from EmailFolder "
        S = S + " where FolderID = '" + FolderID + "'"
        S = S + " and UserID = '" + UserID + "'"
        Dim i As Integer = 0
        Dim tQuery As String = ""

        'Dim i As Integer
        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the arch email folder retention code.
    ''' </summary>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getArchEmailFolderRetentionCode(ByVal FolderID As String, ByVal UserID As String) As String
        Dim rCode As String = ""
        Dim b As Boolean = True
        Dim S As String = "Select RetentionCode "
        S = S + "   FROM [EmailFolder]"
        S = S + " where "
        S = S + " FolderID ='" + FolderID + "'"
        S = S + " and UserID ='" + UserID + "'"
        Dim i As Integer = 0
        Dim tQuery As String = ""

        'Dim i As Integer
        Dim cnt As Integer = -1

        Using gConn

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            rCode = RSData.GetValue(0).ToString
            RSData.Close()
            RSData = Nothing
            command.Connection.Close()
            command = Nothing
        End Using

        Return rCode

    End Function

    ''' <summary>
    ''' is the count.
    ''' </summary>
    ''' <param name="Tbl">The table.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function iCount(ByVal Tbl As String, ByVal WhereClause As String) As Boolean
        Dim b As Boolean = True
        Dim SQL As String = "Select count(*) from " + Tbl + " " + WhereClause
        Dim i As Integer = 0

        i = iGetRowCount(SQL)
        If i = 0 Then
            b = False
        End If
        Return b
    End Function

    ''' <summary>
    ''' is the get row count.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iGetRowCount(ByVal TBL As String, ByVal WhereClause As String) As Integer

        Dim cnt As Integer = -1

        Try
            Dim tQuery As String = ""
            Dim s As String = ""

            s = "Select count(*) as CNT from " + TBL + " " + WhereClause

            Using gConn

                Dim RSData As SqlDataReader = Nothing

                Dim CS As String = getRepoConnStr()
                Dim CONN As New SqlConnection(CS)
                CONN.Open()
                Dim command As New SqlCommand(s, CONN)
                RSData = command.ExecuteReader()

                RSData.Read()
                cnt = RSData.GetInt32(0)

                If Not RSData.IsClosed Then
                    RSData.Close()
                End If
                RSData = Nothing
                command.Dispose()
                command = Nothing

                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
                CONN.Dispose()
            End Using
        Catch ex As Exception
            ' xTrace(12335, "clsDataBase:iGetRowCount" + ex.Message)
            'messagebox.show("Error 3932.11: " , ex)
            If ddebug Then Debug.Print("Error .11: ", ex)
            Console.WriteLine("Error 3932.11.11: ", ex)
            cnt = 0
            LOG.WriteToArchiveLog("clsDatabaseARCH : iGetRowCount : 4010 : ", ex)
        End Try

        Return cnt

    End Function

    ''' <summary>
    ''' is the get row count.
    ''' </summary>
    ''' <param name="TBL">The table.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="ConnectionStr">The connection string.</param>
    ''' <returns>System.Int32.</returns>
    Public Function iGetRowCount(ByVal TBL As String, ByVal WhereClause As String, ByVal ConnectionStr As String) As Integer

        Dim cnt As Integer = -1

        Dim tConn As New SqlConnection(ConnectionStr)
        If tConn.State = ConnectionState.Closed Then
            tConn.Open()
        End If

        Try
            Dim tQuery As String = ""
            Dim s As String = ""

            s = "Select count(*) as CNT from " + TBL + " " + WhereClause

            Using tConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(12335, "clsDataBase:iGetRowCount" + ex.Message)
            'messagebox.show("Error 3932.11: " , ex)
            If ddebug Then Debug.Print("Error 3932.11.12: ", ex)
            Console.WriteLine("Error 3932.11.12: ", ex)
            cnt = 0
            LOG.WriteToArchiveLog("clsDatabaseARCH : iGetRowCount : 4010 : ", ex)
        End Try
        If tConn.State = ConnectionState.Open Then
            tConn.Close()
        End If

        tConn = Nothing
        Return cnt

    End Function

    ''' <summary>
    ''' Archives the email.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FqnEmailImage">The FQN email image.</param>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="SUBJECT">The subject.</param>
    ''' <param name="SentTO">The sent to.</param>
    ''' <param name="Body">The body.</param>
    ''' <param name="Bcc">The BCC.</param>
    ''' <param name="BillingInformation">The billing information.</param>
    ''' <param name="CC">The cc.</param>
    ''' <param name="Companies">The companies.</param>
    ''' <param name="CreationTime">The creation time.</param>
    ''' <param name="ReadReceiptRequested">The read receipt requested.</param>
    ''' <param name="ReceivedByName">Name of the received by.</param>
    ''' <param name="ReceivedTime">The received time.</param>
    ''' <param name="AllRecipients">All recipients.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="SenderEmailAddress">The sender email address.</param>
    ''' <param name="SenderName">Name of the sender.</param>
    ''' <param name="Sensitivity">The sensitivity.</param>
    ''' <param name="SentOn">The sent on.</param>
    ''' <param name="MsgSize">Size of the MSG.</param>
    ''' <param name="DeferredDeliveryTime">The deferred delivery time.</param>
    ''' <param name="EntryID">The entry identifier.</param>
    ''' <param name="ExpiryTime">The expiry time.</param>
    ''' <param name="LastModificationTime">The last modification time.</param>
    ''' <param name="ShortSubj">The short subj.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="OriginalFolder">The original folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ArchiveEmail(ByVal UID As String, ByVal FqnEmailImage As String, ByVal EmailGuid As String, ByVal SUBJECT As String, ByVal SentTO As String, ByVal Body As String, ByVal Bcc As String, ByVal BillingInformation As String, ByVal CC As String, ByVal Companies As String, ByVal CreationTime As DateTime, ByVal ReadReceiptRequested As String, ByVal ReceivedByName As String, ByVal ReceivedTime As DateTime, ByVal AllRecipients As String, ByVal UserID As String, ByVal SenderEmailAddress As String, ByVal SenderName As String, ByVal Sensitivity As String, ByVal SentOn As DateTime, ByVal MsgSize As String, ByVal DeferredDeliveryTime As DateTime, ByVal EntryID As String, ByVal ExpiryTime As DateTime, ByVal LastModificationTime As DateTime, ByVal ShortSubj As String, ByVal SourceTypeCode As String, ByVal OriginalFolder As String) As Boolean
        Dim ID As Integer = 13345
        FqnEmailImage = UTIL.RemoveSingleQuotes(FqnEmailImage)
        Dim B As Boolean = False

        EmailGuid = UTIL.RemoveSingleQuotes(EmailGuid)
        SUBJECT = UTIL.RemoveSingleQuotes(SUBJECT)
        SentTO = UTIL.RemoveSingleQuotes(SentTO)
        Body = UTIL.RemoveSingleQuotes(Body)
        Bcc = UTIL.RemoveSingleQuotes(Bcc)
        BillingInformation = UTIL.RemoveSingleQuotes(BillingInformation)
        CC = UTIL.RemoveSingleQuotes(CC)
        Companies = UTIL.RemoveSingleQuotes(Companies)
        CreationTime = CDate(UTIL.RemoveSingleQuotes(CreationTime.ToString))
        ReadReceiptRequested = UTIL.RemoveSingleQuotes(ReadReceiptRequested)
        ReceivedByName = UTIL.RemoveSingleQuotes(ReceivedByName)
        ReceivedTime = CDate(UTIL.RemoveSingleQuotes(ReceivedTime.ToString))
        AllRecipients = UTIL.RemoveSingleQuotes(AllRecipients)
        UserID = UTIL.RemoveSingleQuotes(UserID)
        SenderEmailAddress = UTIL.RemoveSingleQuotes(SenderEmailAddress)
        SenderName = UTIL.RemoveSingleQuotes(SenderName)
        Sensitivity = UTIL.RemoveSingleQuotes(Sensitivity)
        SentOn = CDate(UTIL.RemoveSingleQuotes(SentOn.ToString))
        MsgSize = UTIL.RemoveSingleQuotes(MsgSize)
        DeferredDeliveryTime = CDate(UTIL.RemoveSingleQuotes(DeferredDeliveryTime.ToString))
        EntryID = UTIL.RemoveSingleQuotes(EntryID)
        ExpiryTime = CDate(UTIL.RemoveSingleQuotes(ExpiryTime.ToString))
        LastModificationTime = CDate(UTIL.RemoveSingleQuotes(LastModificationTime.ToString))

        Try

            Dim EmailBinary() As Byte = CF.FileToByte(FqnEmailImage)

            Dim OriginalSize As Integer = EmailBinary.Length

            EmailBinary = COMP.CompressBuffer(EmailBinary)

            Dim CompressedSize As Integer = EmailBinary.Length
            Dim RC As Boolean = False
            Dim rMsg As String = ""
            Dim TransmissionStartTime As Date = Now
            Dim txEndTime As Date = Now

            'Dim ProxyArchive As New SVCCLCArchive.Service1Client
            'B = ProxyArchive.ArchiveEmail(gGateWayID, ID, UID, FqnEmailImage, EmailGuid, SUBJECT, SentTO, Body, Bcc, BillingInformation, CC, Companies, CreationTime, ReadReceiptRequested, ReceivedByName, ReceivedTime, AllRecipients, UserID, SenderEmailAddress, SenderName, Sensitivity, SentOn, MsgSize, DeferredDeliveryTime, EntryID, ExpiryTime, LastModificationTime, ShortSubj, SourceTypeCode, OriginalFolder, EmailBinary, OriginalSize, CompressedSize, RC, rMsg, TransmissionStartTime, txEndTime)
            MessageBox.Show("Get Connection String Here")
            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand("EmailInsProc", connection)
                    command.CommandType = CommandType.StoredProcedure

                    command.Parameters.Add(New SqlParameter("@EmailGuid", EmailGuid))
                    command.Parameters.Add(New SqlParameter("@SUBJECT", SUBJECT))
                    command.Parameters.Add(New SqlParameter("@SentTO", SentTO))
                    command.Parameters.Add(New SqlParameter("@Body", Body))
                    command.Parameters.Add(New SqlParameter("@Bcc", Bcc))
                    command.Parameters.Add(New SqlParameter("@BillingInformation", BillingInformation))
                    command.Parameters.Add(New SqlParameter("@CC", CC))
                    command.Parameters.Add(New SqlParameter("@Companies", Companies))
                    command.Parameters.Add(New SqlParameter("@CreationTime", CreationTime))
                    command.Parameters.Add(New SqlParameter("@ReadReceiptRequested", ReadReceiptRequested))
                    command.Parameters.Add(New SqlParameter("@ReceivedByName", ReceivedByName))
                    command.Parameters.Add(New SqlParameter("@ReceivedTime", ReceivedTime))
                    command.Parameters.Add(New SqlParameter("@AllRecipients", AllRecipients))
                    command.Parameters.Add(New SqlParameter("@UserID", UserID))
                    command.Parameters.Add(New SqlParameter("@SenderEmailAddress", SenderEmailAddress))
                    command.Parameters.Add(New SqlParameter("@SenderName", SenderName))
                    command.Parameters.Add(New SqlParameter("@Sensitivity", Sensitivity))
                    command.Parameters.Add(New SqlParameter("@SentOn", SentOn))
                    command.Parameters.Add(New SqlParameter("@MsgSize", MsgSize))
                    command.Parameters.Add(New SqlParameter("@DeferredDeliveryTime", DeferredDeliveryTime))
                    command.Parameters.Add(New SqlParameter("@EntryID", EntryID))
                    command.Parameters.Add(New SqlParameter("@ExpiryTime", ExpiryTime))
                    command.Parameters.Add(New SqlParameter("@LastModificationTime", LastModificationTime))
                    command.Parameters.Add(New SqlParameter("@EmailImage", EmailBinary))
                    command.Parameters.Add(New SqlParameter("@ShortSubj", ShortSubj))
                    command.Parameters.Add(New SqlParameter("@SourceTypeCode", SourceTypeCode))
                    command.Parameters.Add(New SqlParameter("@OriginalFolder", OriginalFolder))

                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    connection.Dispose()
                    command.Dispose()
                End Using
            End Using
        Catch ex As Exception
            ' xTrace(12340, "clsDataBase:ArchiveEmail" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            'Debug.Print(ex.StackTrace)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH :  : 4076 : ", ex)
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Inserts the email binary.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="tGuid">The t unique identifier.</param>
    Public Sub InsertEmailBinary(ByVal FQN As String, ByVal tGuid As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        ' Read a bitmap contents in a stream
        Dim fs As FileStream = New FileStream(FQN, FileMode.OpenOrCreate, FileAccess.Read)
        Dim rawData() As Byte = New Byte(CInt(fs.Length)) {}
        fs.Read(rawData, 0, System.Convert.ToInt32(fs.Length))
        fs.Close()
        ' Construct a SQL string and a connection object
        Dim S As String = " "
        S = S + " select * "
        S = S + " FROM  [Email]"
        S = S + " where [EmailGuid] = '" + tGuid + "'"

        CloseConn()
        CkConn()

        ' Open connection
        If gConn.State <> ConnectionState.Open Then
            gConn.Open()
        End If
        ' Create a data adapter and data set
        'Dim CMD As New SqlCommand(S, gConn)
        'Dim da As New SqlDataAdapter(CMD)
        'Dim ds As New Data.DataSet

        Dim con As New SqlConnection(getRepoConnStr())
        Dim da As New SqlDataAdapter(S, con)
        Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
        Dim ds As New System.Data.DataSet

        da.Fill(ds, "Emails")
        Dim myRow As System.Data.DataRow
        myRow = ds.Tables("Emails").Rows(0)

        myRow("EmailImage") = rawData
        ds.AcceptChanges()

        MyCB = Nothing
        ds = Nothing
        da = Nothing

        con.Close()
        con = Nothing

    End Sub

    ''' <summary>
    ''' Applies the cc.
    ''' </summary>
    Sub ApplyCC()
        Dim L As New List(Of String)
        Dim RECIPS As New clsRECIPIENTS
        Dim SL As New SortedList
        Dim S As String = " SELECT [EmailGuid]     "
        S = S + " ,[CC]      "
        S = S + " FROM  [Email]"
        S = S + " where CC Is Not null "
        S = S + " and len(cc) > 0 "

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim CC As String = ""
        Dim EmailGuid As String = ""

        SL.Clear()

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                EmailGuid = RSData.GetValue(0).ToString
                CC = RSData.GetValue(1).ToString
                If Not CC Is Nothing Then
                    SL.Clear()
                    If CC.Trim.Length > 0 Then
                        Dim A(0) As String
                        If InStr(1, CC, ";") > 0 Then
                            A = Split(CC, ";")
                        Else
                            A(0) = CC
                        End If
                        For KK As Integer = 0 To UBound(A)
                            Dim SKEY As String = A(KK)
                            If Not SKEY Is Nothing Then
                                Dim BX As Boolean = SL.ContainsKey(SKEY)
                                If Not BX Then
                                    SL.Add(SKEY, SKEY)
                                End If
                            End If
                        Next
                    End If
                    For KK As Integer = 0 To SL.Count - 1
                        Dim Addr As String = CStr(SL.GetKey(KK))

                        RECIPS.setEmailguid(EmailGuid)
                        RECIPS.setRecipient(Addr)

                        Dim BX As Integer = RECIPS.cnt_PK32A(EmailGuid, Addr)
                        If BX = 0 Then
                            RECIPS.setTyperecp("RECIP")
                            RECIPS.Insert()
                        Else
                            RECIPS.setTyperecp("CC")
                            Dim SS As String = "UPDATE  [Recipients]"
                            SS = SS + " SET [TypeRecp] = 'CC'"
                            SS = SS + " WHERE EmailGuid = '" + EmailGuid + "' "
                            SS = SS + " and Recipient = '" + Addr + "'"
                            L.Add(SS)
                        End If

                    Next
                End If
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        For II = 0 To L.Count - 1
            S = L.Item(II).ToString
            Dim bb As Boolean = ExecuteSqlNewConn(S, False)
            If Not bb Then
                If ddebug Then Debug.Print("ERROR: " + S)
            End If
        Next

    End Sub

    ''' <summary>
    ''' Builds all recips.
    ''' </summary>
    Sub BuildAllRecips()
        Dim L As New List(Of String)
        Dim RECIPS As New clsRECIPIENTS
        Dim SL As New SortedList
        Dim S As String = " SELECT [EmailGuid] ,[Recipient] ,[TypeRecp] FROM  [Recipients] order by EmailGuid "

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim CC As String = ""
        Dim EmailGuid As String = ""
        Dim Recipient As String = ""
        Dim TypeRecp As String = ""
        Dim CurrGuid As String = ""
        Dim PrevGuid As String = ""
        Dim AllRecipients As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                EmailGuid = RSData.GetValue(0).ToString
                Recipient = RSData.GetValue(1).ToString
                TypeRecp = RSData.GetValue(2).ToString
                If II = 1 Then
                    PrevGuid = EmailGuid
                End If
                If Not EmailGuid.Equals(PrevGuid) Then
                    Dim SS As String = "UPDATE  [Email]"
                    SS = SS + " SET [AllRecipients] = '" + Mid(AllRecipients, 2) + "'"
                    SS = SS + " WHERE EmailGuid = '" + EmailGuid + "' "
                    L.Add(SS)
                    AllRecipients = ""
                    AllRecipients = AllRecipients + ";" + Recipient
                Else
                    AllRecipients = AllRecipients + ";" + Recipient
                End If
                PrevGuid = EmailGuid
                frmMain.SB.Text = "Recips: " + II.ToString
                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        For II = 0 To L.Count - 1
            S = L.Item(II).ToString
            Dim bb As Boolean = ExecuteSqlNewConn(S, False)
            If Not bb Then
                If ddebug Then Debug.Print("ERROR: " + S)
            End If
            frmMain.SB.Text = "Applying Recips: " + II.ToString
            Application.DoEvents()
        Next

    End Sub

    ''' <summary>
    ''' Builds all missing data.
    ''' </summary>
    Sub BuildAllMissingData()
        Dim L As New List(Of String)
        Dim RECIPS As New clsRECIPIENTS
        Dim SL As New SortedList
        Dim S As String = " SELECT SourceGuid, FQN FROM DataSource "

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim CC As String = ""
        Dim SourceGuid As String = ""
        Dim FQN = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                SourceGuid = RSData.GetValue(0).ToString
                FQN = RSData.GetValue(1).ToString
                FQN = DMA.GetFilePath(FQN)

                Dim SS As String = "UPDATE [DataSource] "
                SS = SS + " SET [FileDirectory] = '" + FQN + "'"
                SS = SS + " WHERE SourceGuid = '" + SourceGuid + "' "
                L.Add(SS)

                frmMain.SB.Text = "Files Read: " + II.ToString
                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        For II = 0 To L.Count - 1
            S = L.Item(II).ToString
            Dim bb As Boolean = ExecuteSqlNewConn(S, False)
            If Not bb Then
                If ddebug Then Debug.Print("ERROR: " + S)
            End If
            frmMain.SB.Text = "Applying Files: " + II.ToString
            Application.DoEvents()
        Next

    End Sub

    ''' <summary>
    ''' Builds all c cs.
    ''' </summary>
    Sub BuildAllCCs()
        Dim L As New List(Of String)
        Dim RECIPS As New clsRECIPIENTS
        Dim SL As New SortedList
        Dim S As String = " SELECT [EmailGuid] ,[Recipient] ,[TypeRecp] FROM  [Recipients] where TypeRecp = 'CC' order by EmailGuid "

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim CC As String = ""
        Dim EmailGuid As String = ""
        Dim Recipient As String = ""
        Dim TypeRecp As String = ""
        Dim CurrGuid As String = ""
        Dim PrevGuid As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                EmailGuid = RSData.GetValue(0).ToString
                Recipient = RSData.GetValue(1).ToString
                TypeRecp = RSData.GetValue(2).ToString
                If II = 1 Then
                    PrevGuid = EmailGuid
                End If
                If Not EmailGuid.Equals(PrevGuid) Then
                    Dim SS As String = "UPDATE  [Email]"
                    SS = SS + " SET [CC] = '" + Mid(CC, 2) + "'"
                    SS = SS + " WHERE EmailGuid = '" + EmailGuid + "' "
                    L.Add(SS)
                    CC = ""
                    CC = CC + ";" + Recipient
                Else
                    CC = CC + ";" + Recipient
                End If
                PrevGuid = EmailGuid
                frmMain.SB.Text = "CC: " + II.ToString
                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        For II = 0 To L.Count - 1
            S = L.Item(II).ToString
            Dim bb As Boolean = ExecuteSqlNewConn(S, False)
            If Not bb Then
                If ddebug Then Debug.Print("ERROR: " + S)
            End If
            frmMain.SB.Text = "Applying CC: " + II.ToString
            Application.DoEvents()
        Next

    End Sub

    ''' <summary>
    ''' Gets the excluded emails.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    Sub getExcludedEmails(ByVal UserID As String)
        Dim L As New List(Of String)
        Dim RECIPS As New clsRECIPIENTS
        Dim SL As New SortedList
        Dim S As String = " SELECT [FromEmailAddr] FROM  [ExcludeFrom] where  Userid = '" + gCurrUserGuidID + "' "

        zeroizeExcludedEmailAddr()

        Dim b As Boolean = True
        Dim Email As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Email = RSData.GetValue(0).ToString
                AddExcludedEmailAddr(Email)
                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' Gets the directory parms.
    ''' </summary>
    ''' <param name="A">a.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function getDirectoryParms(ByRef A As String(), ByVal FQN As String, ByVal UserID As String) As Boolean

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = False
        ReDim A(0)
        Dim IncludeSubDirs As String = ""
        Dim VersionFiles As String = ""
        Dim ckMetaData As String = ""
        Dim NumberOfDirs As Integer = 0
        Dim CurrDir As Integer = 0
        Dim I As Integer = 0
        Dim OcrDirectory As String = ""
        Dim OcrPdf As String = ""
        Dim RetentionCode As String = ""
        Dim ckPublic As String = ""

        For I = 1 To FQN.Length
            Dim ch As String = Mid(FQN, I, 1)
            If ch = "\" Then
                NumberOfDirs += 1
            End If
        Next
        CurrDir = NumberOfDirs
        Dim DIRS As String() = Split(FQN, "\")
REDO:
        Dim CurrFqn As String = ""
        For I = 0 To CurrDir
            If I = 0 Then
                CurrFqn = DIRS(0)
            Else
                CurrFqn = CurrFqn + "\" + DIRS(I)
            End If
        Next

        Try
            Dim rsData As SqlDataReader = Nothing
            Dim S As String = ""
            S = S + " SELECT [UserID]" + Environment.NewLine
            S = S + " ,[IncludeSubDirs]" + Environment.NewLine
            S = S + " ,[FQN]" + Environment.NewLine
            S = S + " ,[DB_ID]" + Environment.NewLine
            S = S + " ,[VersionFiles]" + Environment.NewLine
            S = S + " ,[ckMetaData] " + Environment.NewLine
            S = S + " ,OcrDirectory " + Environment.NewLine
            S = S + " ,RetentionCode" + Environment.NewLine
            S = S + " ,OcrPdf" + Environment.NewLine
            S = S + " ,ckPublic" + Environment.NewLine
            S = S + " FROM [Directory]" + Environment.NewLine
            S = S + " where fqn = '" + CurrFqn + "' and Userid = '" + UserID + "'"

            Dim CS As String = getRepoConnStr()

            Dim CONN As New SqlConnection(CS)
            CONN.Open()

            setConnStr()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()

            If rsData.HasRows Then
                Do While rsData.Read()
                    B = True
                    IncludeSubDirs = rsData.GetValue(1).ToString
                    VersionFiles = rsData.GetValue(4).ToString
                    ckMetaData = rsData.GetValue(5).ToString
                    OcrDirectory = rsData.GetValue(6).ToString
                    RetentionCode = rsData.GetValue(7).ToString
                    OcrPdf = rsData.GetValue(8).ToString
                    ckPublic = rsData.GetValue(9).ToString
                    ReDim A(7)
                    A(0) = IncludeSubDirs
                    A(1) = VersionFiles
                    A(2) = ckMetaData
                    A(3) = OcrDirectory
                    A(4) = RetentionCode
                    A(5) = OcrPdf
                    A(6) = ckPublic
                Loop
            End If
            rsData.Close()
            rsData = Nothing

            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            ' xTrace(12341, "clsDataBase:getDirectoryParms" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : getDirectoryParms : 4390 : ", ex)
        End Try
        If B Then
            Return True
        Else
            ReDim A(7)
            A(0) = IncludeSubDirs
            A(1) = VersionFiles
            A(2) = ckMetaData
            A(3) = OcrDirectory
            If RetentionCode.Length = 0 Then
                RetentionCode = getFirstRetentionCode()
            End If
            A(4) = RetentionCode
            A(5) = OcrPdf
            A(6) = ckPublic
            If CurrDir = 1 Then
                Return False
            Else
                CurrDir = CurrDir - 1
                If CurrDir <= 0 Then
                    A(0) = "N"   'IncludeSubDirs
                    A(1) = "Y"   'VersionFiles
                    A(2) = "N"   'ckMetaData
                    A(3) = "Y"   'OcrDirectory
                    A(4) = getFirstRetentionCode()
                    A(5) = "Y"   'OcrPdf
                    A(6) = "N"   'OcrPdf
                    Return False
                Else
                    GoTo REDO
                End If

            End If
        End If
    End Function

    ''' <summary>
    ''' Gets the first retention code.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getFirstRetentionCode() As String
        Dim rCode As String = ""
        Dim S As String = "Select RetentionCode "
        S = S + " FROM [Retention]"
        Dim I As Integer = 0
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            If RSData.HasRows Then
                RSData.Read()
                rCode = RSData.GetValue(0).ToString
            End If

            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            ' xTrace(12341, "clsDataBase:getFirstRetentionCode" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getFirstRetentionCode : 4419 : ", ex)
        End Try
        Return rCode
    End Function

    ''' <summary>
    ''' Gets the next document version NBR.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getNextDocVersionNbr(ByVal Userid As String, ByVal FQN As String) As Integer
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = "Select max([VersionNbr]) "
        S = S + " FROM DataSource"
        S = S + " where fqn = '" + FQN + "'"
        S = S + " and [DataSourceOwnerUserID] = '" + Userid + "'"
        Dim I As Integer = 0
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                I = CInt(RSData.GetValue(0).ToString)
            End If
            RSData.Close()
            RSData = Nothing
            Return I + 1
        Catch ex As Exception
            ' xTrace(12341, "clsDataBase:getNextDocVersionNbr" + ex.Message)
            I = -1
            LOG.WriteToArchiveLog("clsDatabaseARCH : getNextDocVersionNbr : 4419 : ", ex)
        End Try
        Return I
    End Function

    ''' <summary>
    ''' Deletes the name of the document by.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function DeleteDocumentByName(ByVal Userid As String, ByVal FQN As String, ByVal SourceGuid As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim b As Boolean = False

        Dim S As String = "delete "

        S = S + " FROM DataSource"
        S = S + " where fqn = '" + FQN + "'"
        S = S + " and [DataSourceOwnerUserID] = '" + Userid + "' or SourceGuid = '" + SourceGuid + "'"

        Try
            b = ExecuteSqlNewConn(S, False)
            Return b
        Catch ex As Exception
            ' xTrace(12345, "clsDataBase:DeleteDocumentByName" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteDocumentByName : 4429 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteDocumentByName : 4402 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteDocumentByName : 4417 : ", ex)
            Return b
        End Try

        'S = " delete FROM DataSource"
        'S = S + " where SourceGuid = '" + SourceGuid  + "'"

        'Try
        '    b = ExecuteSqlNewConn(S,false)
        '    Return b
        'Catch ex As Exception
        ' if ddebug then    Debug.Print(ex.Message)
        '    Return b
        'End Try

    End Function

    ''' <summary>
    ''' Deletes the document by unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function DeleteDocumentByGuid(ByVal SourceGuid As String) As Boolean
        Dim SHIST As New clsSEARCHHISTORY
        Dim b As Boolean = False

        Dim S As String = "delete "

        S = S + " FROM DataSource"
        S = S + " where SourceGuid = '" + SourceGuid + "'"
        Dim I As Integer = 0
        Try
            b = ExecuteSqlNewConn(S, False)
            S = "DELETE FROM [SourceAttribute] WHERE SourceGuid = '" + SourceGuid + "' "
            b = ExecuteSqlNewConn(S, False)

            SHIST.setCalledfrom("clsDatabaseARCH:DeleteDocumentByGuid")
            SHIST.setEndtime(Now.ToString)
            SHIST.setReturnedrows("1")
            SHIST.setTypesearch("Delete")
            SHIST.setStarttime(Now.ToString)
            SHIST.setSearchdate(Now.ToString)
            SHIST.setSearchsql(S)
            SHIST.setUserid(gCurrUserGuidID)
            b = SHIST.Insert
            If Not b Then
                Console.WriteLine("Error 1943.244 - Failed to save history of search.")
            End If
            b = True
        Catch ex As Exception
            ' xTrace(12345, "clsDataBase:DeleteDocumentByGuid" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteDocumentByGuid : 4438 : ", ex)
            b = False
        End Try

        SHIST = Nothing
        Return b
    End Function

    ''' <summary>
    ''' Determines whether [has document been updated] [the specified userid].
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if [has document been updated] [the specified userid]; otherwise, <c>false</c>.</returns>
    Public Function hasDocumentBeenUpdated(ByVal Userid As String, ByVal FQN As String) As Boolean
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim b As Boolean = False

        Dim S As String = "delete "

        S = S + " FROM DataSource"
        S = S + " where fqn = '" + FQN + "'"
        S = S + " and [DataSourceOwnerUserID] = '" + Userid + "'"
        Dim I As Integer = 0
        Try
            b = ExecuteSqlNewConn(S, False)
            Return b
        Catch ex As Exception
            ' xTrace(12345, "clsDataBase:hasDocumentBeenUpdated" + ex.Message)
            If ddebug Then Debug.Print(ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : hasDocumentBeenUpdated : 4449 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : hasDocumentBeenUpdated : 4424 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : hasDocumentBeenUpdated : 4441 : ", ex)
            Return b
        End Try

    End Function

    ''' <summary>
    ''' Updates the size of the document.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="fSize">Size of the f.</param>
    Public Sub UpdateDocSize(ByVal DocGuid As String, ByVal fSize As String)
        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [FileLength] = " + fSize
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File Size for GUID '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the size of the document.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="fSize">Size of the f.</param>
    Public Sub UpdateDocSize(ByVal FQN As String, ByVal UID As String, ByVal fSize As String)

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [FileLength] = " + fSize
        S = S + "  WHERE [DataSourceOwnerUserID] = '" + UID + "' and FQN = '" + FQN + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File Size for FQN '" + FQN + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the RSS link FLG to true.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    Public Sub UpdateRssLinkFlgToTrue(ByVal DocGuid As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [RssLinkFlg] = 1 "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File UpdateWebLinkFlgToTrue Feed '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the web link FLG to true.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    Public Sub UpdateWebLinkFlgToTrue(ByVal DocGuid As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [isWebPage] = 'Y' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File UpdateWebLinkFlgToTrue Feed '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the source CRC.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="CRC">The CRC.</param>
    Public Sub UpdateSourceCRC(SourceGuid As String, CRC As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [CRC] = convert(nvarchar(100), " + CRC + "), "
        S = S + "  [ImageHash] = convert(nvarchar(100), " + CRC + ") "
        S = S + "  WHERE [SourceGuid] = '" + SourceGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File UpdateSourceCRC Feed '" + SourceGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the content description.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="Description">The description.</param>
    Public Sub UpdateContentDescription(ByVal DocGuid As String, Description As String)

        Dim sDescription As String = Description.Replace("'", "''")

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [Description] = '" + Description + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File UpdateContentDescription '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the content key words.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="KeyWords">The key words.</param>
    Public Sub UpdateContentKeyWords(ByVal DocGuid As String, KeyWords As String)

        Dim sKeyWords As String = KeyWords.Replace("'", "''")
        If sKeyWords.Length > 1999 Then
            sKeyWords = sKeyWords.Substring(0, 1999)
        End If
        sKeyWords = sKeyWords.Trim
        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [KeyWords] = '" + sKeyWords + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File UpdateContentKeyWords '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the web page URL reference.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="PageUrl">The page URL.</param>
    Public Sub UpdateWebPageUrlRef(ByVal DocGuid As String, PageUrl As String)

        Dim sPageUrl As String = PageUrl.Replace("'", "''")

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [PageUrl] = '" + sPageUrl + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update WebPage reference Feed '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the web page hash.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="URLHash">The URL hash.</param>
    Public Sub UpdateWebPageHash(ByVal DocGuid As String, URLHash As String)

        Dim sURLHash As String = URLHash.Replace("'", "''")

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [URLHash] = '" + sURLHash + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update WebPage URL HASH: '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the web page publish date.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="WebPagePublishDate">The web page publish date.</param>
    Public Sub UpdateWebPagePublishDate(ByVal DocGuid As String, WebPagePublishDate As String)

        Dim sWebPagePublishDate As String = WebPagePublishDate.Replace("'", "''")

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [WebPagePublishDate] = '" + sWebPagePublishDate + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed UpdateWebPagePublishDate '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the retention code.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    Public Sub UpdateRetentionCode(ByVal SourceGuid As String, ByVal RetentionCode As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [RetentionCode] = '" + RetentionCode + "' "
        S = S + "  WHERE [SourceGuid] = '" + SourceGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File RetentionCode '" + RetentionCode + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the document FQN.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    Public Sub UpdateDocFqn(ByVal DocGuid As String, ByVal FQN As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [FQN] = '" + FQN + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File FQN '" + FQN + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the document CRC.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="CRC">The CRC.</param>
    Public Sub UpdateDocCrc(ByVal DocGuid As String, ByVal CRC As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [CRC] = convert(nvarchar(100), " + CRC + ") "
        S = S + "  set [ImageHash] = convert(nvarchar(100), " + CRC + ") "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToSaveSql("Failed to update File FQN '" + CRC + "'.")
        End If

    End Sub

    ''' <summary>
    ''' xes the update all document CRC.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="CRC">The CRC.</param>
    Public Sub xUpdateAllDocCrc(ByVal FQN As String, ByVal CRC As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [CRC] = convert(nvarchar(100), " + CRC + ") "
        S = S + "  set [ImageHash] = convert(nvarchar(100), " + CRC + ") "
        S = S + "  WHERE [FQN] = '" + FQN + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToSaveSql("Failed to update File FQN '" + CRC + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the type of the document original file.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="OriginalFileType">Type of the original file.</param>
    Public Sub UpdateDocOriginalFileType(ByVal DocGuid As String, ByVal OriginalFileType As String)
        OriginalFileType = UTIL.RemoveSingleQuotes(OriginalFileType)
        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [OriginalFileType] = '" + OriginalFileType + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update OriginalFileType '" + OriginalFileType + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the zip file indicator.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="cZipFile">if set to <c>true</c> [c zip file].</param>
    Public Sub UpdateZipFileIndicator(ByVal DocGuid As String, ByVal cZipFile As Boolean)

        Dim C As String = ""
        If cZipFile Then
            C = "Y"
        Else
            C = "N"
        End If

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [IsZipFile] = '" + C + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("ERROR 285.34.2 Failed to update ZIPFILE flag: '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the email indicator.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    Public Sub UpdateEmailIndicator(ByVal DocGuid As String, ByVal EmailGuid As String)
        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [EmailGuid] = '" + EmailGuid + "', isEmailAttachment = 1 "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR 285.34.2 UpdateEmailIndicator: Failed to update EMAIL flag: '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the zip file owner unique identifier.
    ''' </summary>
    ''' <param name="ParentGuid">The parent unique identifier.</param>
    ''' <param name="ZipFileGuid">The zip file unique identifier.</param>
    ''' <param name="ZipFileFQN">The zip file FQN.</param>
    Public Sub UpdateZipFileOwnerGuid(ByVal ParentGuid As String, ByVal ZipFileGuid As String, ByVal ZipFileFQN As String)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [ZipFileGuid] = '" + ParentGuid + "', ZipFileFQN = '" + ZipFileFQN + "', isContainedWithinZipFile = 'Y', ParentGuid = '" + ParentGuid + "'  "
        S = S + "  WHERE [SourceGuid] = '" + ZipFileGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("ERROR 2858.34.2 Failed to update ZIPFILE FQN: '" + ZipFileGuid + "'.")
        End If

        S = "Update DataSource set isZipFile = 'Y' where SourceGuid = '" + ParentGuid + "' "
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR 2858.34.3 Failed to update ZIPFILE FQN: '" + ParentGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the is contained within zip file.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    Public Sub UpdateIsContainedWithinZipFile(ByVal DocGuid As String)

        Dim C As String = ""

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [isContainedWithinZipFile] = 'Y' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("ERROR 285.34.21 Failed to update ZIPFILE flag: '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Updates the document dir.
    ''' </summary>
    ''' <param name="DocGuid">The document unique identifier.</param>
    ''' <param name="DocDir">The document dir.</param>
    Public Sub UpdateDocDir(ByVal DocGuid As String, ByVal DocDir As String)

        DocDir = UTIL.RemoveSingleQuotes(DocDir)
        DocDir = DMA.GetFilePath(DocDir)

        Dim S As String = ""
        S = S + "  UPDATE [DataSource]"
        S = S + "  set [FileDirectory] = '" + DocDir + "' "
        S = S + "  WHERE [SourceGuid] = '" + DocGuid + "'"

        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("Failed to update File Size for GUID '" + DocGuid + "'.")
        End If

    End Sub

    ''' <summary>
    ''' Deletes the data source and attrs.
    ''' </summary>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function DeleteDataSourceAndAttrs(ByVal WhereClause As String) As Boolean
        Dim s As String = ""
        Dim B As Boolean = False
        s = "delete from SourceAttribute where [SourceGuid] in (SELECT [SourceGuid] FROM DataSource " + WhereClause + ")"
        B = ExecuteSqlNewConn(s, False)
        If B Then
            s = "delete from datasource " + WhereClause
            B = ExecuteSqlNewConn(s, False)
        Else
            B = False
        End If
        Return B
    End Function

    ''' <summary>
    ''' Gets the process file as ext.
    ''' </summary>
    ''' <param name="FileExt">The file ext.</param>
    ''' <returns>System.String.</returns>
    Public Function getProcessFileAsExt(ByVal FileExt As String) As String
        If FileExt.Trim.Length = 0 Then
            Return ".UKN"
        End If
        Dim NexExt As String = ""
        Dim ProcessExtCode As String = ""
        Dim S As String = "Select [ExtCode]"
        S = S + " ,[ProcessExtCode]"
        S = S + " FROM  [ProcessFileAs]"
        S = S + " where ExtCode = '" + FileExt + "'"

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

        If RSData.HasRows Then
            RSData.Read()
            NexExt = RSData.GetValue(0).ToString
            ProcessExtCode = RSData.GetValue(1).ToString
        Else
            NexExt = Nothing
        End If
        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        Return ProcessExtCode
    End Function

    ''' <summary>
    ''' Sets the document public flag by owner dir.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="PublicFlag">if set to <c>true</c> [public flag].</param>
    ''' <param name="bDisableDir">if set to <c>true</c> [b disable dir].</param>
    ''' <param name="OcrDirectory">The ocr directory.</param>
    Sub SetDocumentPublicFlagByOwnerDir(ByVal FQN As String, ByVal PublicFlag As Boolean, ByVal bDisableDir As Boolean, ByVal OcrDirectory As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim UID As String = gCurrUserGuidID

        Dim S As String = ""
        Dim sFlag As String = ""
        'Dim iFlag  = ""
        Dim B As Boolean
        Dim DisableDir As String = ""

        If PublicFlag Then
            sFlag = "Y"
            'iFlag  = "1"
        Else
            sFlag = "N"
            'iFlag  = "0"
        End If
        If bDisableDir Then
            DisableDir = "Y"
        Else
            DisableDir = "N"
        End If

        Dim SS As String = ""

        '*******************************************************
        S = "update [Directory] set [ckPublic] = '" + sFlag + "', ckDisableDir = '" + DisableDir + "' where Userid = '" + UID + "' and [FQN] = '" + FQN + "'"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DIRECTORY table.")
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            LOG.WriteToArchiveLog("Info 01 : SetDocPubFlg: " + S)
        End If

        S = "update [Directory] set [ckPublic] = '" + sFlag + "', ckDisableDir = '" + DisableDir + "' where Userid = '" + UID + "' and [FQN] = '" + FQN + "'"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DIRECTORY table.")
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            LOG.WriteToArchiveLog("Info 02 : SetDocPubFlg: " + S)
        End If

        S = "update [Directory] set [OcrDirectory] = '" + OcrDirectory + "' where Userid = '" + UID + "' and [FQN] = '" + FQN + "'"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DIRECTORY table.")
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            LOG.WriteToArchiveLog("Info 03 : SetDocPubFlg: " + S)
        End If

        '*******************************************************
        S = "update [SubDir] set ckPublic = '" + sFlag + "', ckDisableDir = '" + DisableDir + "' where Userid = '" + UID + "' "
        S = S + " and ([FQN] = '" + FQN + "' or [SUBFQN] = '" + FQN + "')"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in SUBDIR table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            If ddebug Then LOG.WriteToArchiveLog("Info 04 : SetDocPubFlg: " + S)
        End If

        S = "update [SubDir] set ckPublic = '" + sFlag + "', ckDisableDir = '" + DisableDir + "' where Userid = '" + UID + "' "
        S = S + " and ([FQN] = '" + FQN + "' or [SUBFQN] = '" + FQN + "')"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in SUBDIR table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            If ddebug Then LOG.WriteToArchiveLog("Info 05 : SetDocPubFlg: " + S)
        End If
        '*******************************************************
        S = "update [DataSource] set [isPublic] = '" + sFlag + "'"
        S = S + " where FileDirectory = '" + FQN + "'"
        S = S + " and DataSourceOwnerUserID = '" + UID + "'"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DataSource table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            If ddebug Then LOG.WriteToArchiveLog("Info 06 : SetDocPubFlg: " + S)
        End If

        S = "update [DataSource] set [isPublic] = '" + sFlag + "'"
        S = S + " where FileDirectory = '" + FQN + "'"
        S = S + " and DataSourceOwnerUserID = '" + UID + "'"
        SS = SS + Environment.NewLine + Environment.NewLine + S
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DataSource table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        Else
            If ddebug Then LOG.WriteToArchiveLog("Info 07 : SetDocPubFlg: " + S)
        End If

    End Sub

    ''' <summary>
    ''' Sets the document public flag.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="PublicFlag">if set to <c>true</c> [public flag].</param>
    Sub SetDocumentPublicFlag(ByVal UID As String, ByVal FQN As String, ByVal PublicFlag As Boolean)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = ""
        Dim sFlag As String = ""
        Dim iFlag As String = ""
        Dim B As Boolean
        Dim DisableDir As String = ""

        If PublicFlag Then
            sFlag = "Y"
            'iFlag  = "1"
        Else
            sFlag = "N"
            'iFlag  = "0"
        End If

        S = "update [Directory] set [ckPublic] = '" + sFlag + "' where Userid = '" + UID + "' and [FQN] = '" + FQN + "'"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DIRECTORY table.")
            ' xTrace(93925, "clsDataBase:SetDocumentPublicFlag", S)
        End If

        S = "update [SubDir] set ckPublic = '" + sFlag + "' where Userid = '" + UID + "' "
        S = S + " and ([FQN] = '" + FQN + "' or [SUBFQN] = '" + FQN + "')"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in SUBDIR table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        End If

        S = "update [DataSource] set [isPublic] = '" + sFlag + "'"
        S = S + " where FileDirectory = '" + FQN + "'"
        S = S + " and DataSourceOwnerUserID = '" + UID + "'"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DataSource table.")
            ' xTrace(93926, "clsDataBase:SetDocumentPublicFlag", S)
        End If

    End Sub

    ''' <summary>
    ''' Cks the master already defined.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <returns>System.Int32.</returns>
    Function ckMasterAlreadyDefined(ByVal SourceName As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim con As New SqlConnection(getRepoConnStr())
        con.Open()
        'Dim command As New SqlCommand(s, con)
        Dim RSData As SqlDataReader = Nothing

        Dim cnt As Integer = -1

        Try
            Dim tQuery As String = ""

            Dim S As String = "Select COUNT(*) from DataSource where SourceName = '" + SourceName + "' and isMaster ='Y'"

            Using con
                RSData = SqlQry(S, con)
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
            End Using
        Catch ex As Exception
            ' xTrace(12360, "clsDataBase:ckMasterAlreadyDefined" + ex.Message)
            Console.WriteLine("Error ckMasterAlreadyDefined 3932.11.14: ", ex)
            cnt = 0
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckMasterAlreadyDefined : 5163 : ", ex)
        Finally
            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            'command.Connection.Close()
            'command = Nothing
            If con.State = ConnectionState.Open Then
                con.Close()
            End If
            con = Nothing

        End Try

        Return cnt

    End Function

    ''' <summary>
    ''' Sets the document to master.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="MasterFlag">if set to <c>true</c> [master flag].</param>
    Sub SetDocumentToMaster(ByVal SourceGuid As String, ByVal MasterFlag As Boolean)

        Dim S As String = ""
        Dim sFlag As String = ""
        Dim iFlag As String = ""
        Dim B As Boolean
        Dim DisableDir As String = ""

        If MasterFlag Then
            sFlag = "Y"
            'iFlag  = "1"
        Else
            sFlag = "N"
            'iFlag  = "0"
        End If

        S = "update [DataSource] set [isMaster] = '" + sFlag + "'"
        S = S + " where SourceGuid = '" + SourceGuid + "'"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(93926, "clsDataBase:SetDocumentToMaster", "Failed to set public flag in DataSource table.")
            ' xTrace(93926, "clsDataBase:SetDocumentToMaster", S)
        End If

    End Sub

    ''' <summary>
    ''' Sets the document public flag.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="isPublic">if set to <c>true</c> [is public].</param>
    Sub SetDocumentPublicFlag(ByVal SourceGuid As String, ByVal isPublic As Boolean)

        Dim S As String = ""
        Dim sFlag As String = ""
        Dim iFlag As String = ""
        Dim B As Boolean
        Dim DisableDir As String = ""

        If isPublic Then
            sFlag = "Y"
            'iFlag  = "1"
        Else
            sFlag = "N"
            'iFlag  = "0"
        End If

        S = "update [DataSource] set [isPublic] = '" + sFlag + "'"
        S = S + " where SourceGuid = '" + SourceGuid + "'"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(939288, "clsDataBase:SetDocumentPublicFlag", "Failed to set public flag in DataSource table.")
            ' xTrace(939288, "clsDataBase:SetDocumentPublicFlag", S)
        End If

    End Sub

    ''' <summary>
    ''' Sets the email public flag.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="isPublic">if set to <c>true</c> [is public].</param>
    Sub SetEmailPublicFlag(ByVal EmailGuid As String, ByVal isPublic As Boolean)

        Dim S As String = ""
        Dim sFlag As String = ""
        Dim iFlag As String = ""
        Dim B As Boolean
        Dim DisableDir As String = ""

        If isPublic Then
            sFlag = "Y"
            'iFlag  = "1"
        Else
            sFlag = "N"
            'iFlag  = "0"
        End If

        S = "update [Email] set [isPublic] = '" + sFlag + "'"
        S = S + " where EmailGuid = '" + EmailGuid + "'"
        B = ExecuteSqlNewConn(S, False)
        If Not B Then
            ' xTrace(939288, "clsDataBase:SetEmailPublicFlag", "Failed to set public flag in Email table.")
            ' xTrace(939288, "clsDataBase:SetEmailPublicFlag", S)
        End If

    End Sub

    ''' <summary>
    ''' Adds the image using dataset.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SrcTable">The source table.</param>
    Sub addImageUsingDataset(ByVal S As String, ByVal FQN As String, ByVal SrcTable As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        'Dim da As New SqlDataAdapter("Select SourceImage From SourceImage where SourceGuid = 'SourceGuid' and DataSourceOwnerUserID = 'DataSourceOwnerUserID'", gConn)
        'FQN = "C:\winnt\Gone Fishing.BMP"
        CloseConn()
        CkConn()

        Dim da As New SqlDataAdapter(S, gConn)
        Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
        Dim ds As New DataSet()

        da.MissingSchemaAction = MissingSchemaAction.AddWithKey

        Dim fs As New FileStream(FQN, FileMode.OpenOrCreate, FileAccess.Read)
        Dim MyData(CInt(fs.Length)) As Byte
        fs.Read(MyData, 0, CInt(fs.Length))
        fs.Close()
        gConn.Open()
        da.Fill(ds, SrcTable)
        Dim myRow As DataRow

        myRow = ds.Tables(SrcTable).NewRow()
        myRow("SourceImage") = MyData

        ds.Tables(SrcTable).Rows.Add(myRow)
        da.Update(ds, SrcTable)

        fs = Nothing
        MyCB = Nothing
        ds = Nothing
        da = Nothing

        gConn.Close()
        gConn = Nothing
        ' If gRunUnattended = False Then MessageBox.Show("Image saved to database")
    End Sub

    ''' <summary>
    ''' Updates the image using dataset.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SrcTable">The source table.</param>
    Sub updateImageUsingDataset(ByVal S As String, ByVal FQN As String, ByVal SrcTable As String)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        'Dim da As New SqlDataAdapter("Select SourceImage From SourceImage where SourceGuid = 'SourceGuid' and DataSourceOwnerUserID = 'DataSourceOwnerUserID'", gConn)
        'FQN = "C:\winnt\Gone Fishing.BMP"
        CloseConn()
        CkConn()

        Dim da As New SqlDataAdapter(S, gConn)
        Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
        Dim ds As New DataSet()

        da.MissingSchemaAction = MissingSchemaAction.AddWithKey

        Dim fs As New FileStream(FQN, FileMode.OpenOrCreate, FileAccess.Read)
        Dim MyData(CInt(fs.Length)) As Byte
        fs.Read(MyData, 0, CInt(fs.Length))
        fs.Close()
        gConn.Open()
        da.Fill(ds, SrcTable)
        Dim myRow As DataRow

        '.NewRow()
        myRow = ds.Tables(SrcTable).NewRow
        myRow("SourceImage") = MyData

        '.Add(myRow)
        ds.Tables("MyImages").Rows.Add(myRow)
        da.Update(ds, "MyImages")

        fs = Nothing
        MyCB = Nothing
        ds = Nothing
        da = Nothing

        gConn.Close()
        gConn = Nothing
        ' If gRunUnattended = False Then MessageBox.Show("Image saved to database")
    End Sub

    ''' <summary>
    ''' Writes the image source data from database write to file.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="OverWrite">if set to <c>true</c> [over write].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function writeImageSourceDataFromDbWriteToFile(ByVal SourceGuid As String, ByVal FQN As String, ByVal OverWrite As Boolean) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = True
        Dim SourceTblName As String = "DataSource"
        Dim ImageFieldName As String = "SourceImage"

        Try
            Dim S As String = ""
            S = S + " SELECT "
            S = S + " [SourceImage]"
            S = S + " FROM  [DataSource]"
            S = S + " where [SourceGuid] = '" + SourceGuid + "'"

            Dim CN As New SqlConnection(getRepoConnStr())

            If CN.State = ConnectionState.Closed Then
                CN.Open()
            End If

            Dim da As New SqlDataAdapter(S, CN)
            Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
            Dim ds As New DataSet()

            da.Fill(ds, SourceTblName)
            Dim myRow As DataRow
            myRow = ds.Tables(SourceTblName).Rows(0)

            Dim MyData() As Byte
            MyData = CType(myRow(ImageFieldName), Byte())

            If MyData.Length = 0 Then
                Return False
            End If

            Dim K As Long
            K = UBound(MyData)
            Try
                Dim fs As New FileStream(FQN, FileMode.Create, FileAccess.Write)
                '** Liz and Dale try magic
                fs.Write(MyData, 0, CInt(K + 1))
                fs.Close()
                fs = Nothing
            Catch ex As Exception
                ' If gRunUnattended = False Then MessageBox.Show("No restore: ", ex)
                If ddebug Then Debug.Print(ex.Message)
                ' xTrace(CInt(58342.15), "clsDataBase:imageDataReadFromDbWriteToFile" + ex.Message)
                LOG.WriteToArchiveLog("clsDatabaseARCH : writeImageSourceDataFromDbWriteToFile : 4749 : " + ex.Message + Environment.NewLine + ex.StackTrace)
            End Try

            MyCB = Nothing
            ds = Nothing
            da = Nothing

            CN.Close()
            CN = Nothing
            GC.Collect()
        Catch ex As Exception
            Dim AppName As String = ex.Source
            ' xTrace(CInt(58342.1), "clsDataBase:imageDataReadFromDbWriteToFile" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : writeImageSourceDataFromDbWriteToFile : 4757 : ", ex)
        End Try
        Return B

    End Function

    ''' <summary>
    ''' Writes the attachment from database write to file.
    ''' </summary>
    ''' <param name="RowID">The row identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="OverWrite">if set to <c>true</c> [over write].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function writeAttachmentFromDbWriteToFile(ByVal RowID As String, ByVal FQN As String, ByVal OverWrite As Boolean) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim B As Boolean = True
        Dim SourceTblName As String = "EmailAttachment"
        Dim ImageFieldName As String = "Attachment"

        Try
            Dim S As String = ""
            S = S + " SELECT "
            S = S + " [Attachment]"
            S = S + " FROM  [EmailAttachment]"
            S = S + " where [RowID] = " + RowID

            Dim CN As New SqlConnection(getRepoConnStr())

            If CN.State = ConnectionState.Closed Then
                CN.Open()
            End If

            Dim da As New SqlDataAdapter(S, CN)
            Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
            Dim ds As New DataSet()

            da.Fill(ds, SourceTblName)
            Dim myRow As DataRow
            myRow = ds.Tables(SourceTblName).Rows(0)

            Dim MyData() As Byte
            MyData = CType(myRow(ImageFieldName), Byte())
            Dim K As Long
            K = UBound(MyData)
            Try
                If OverWrite Then
                    'If File.Exists(FQN) Then
                    '    File.Delete(FQN )
                    'End If
                Else
                    If File.Exists(FQN) Then
                        Return False
                    End If
                End If
                Dim fs As New FileStream(FQN, FileMode.Create, FileAccess.Write)
                '** Liz and Dale try magic
                fs.Write(MyData, 0, CInt(K + 1))
                fs.Close()
                fs = Nothing
            Catch ex As Exception
                If ddebug Then Debug.Print(ex.Message)
                ' xTrace(CInt(58342.15), "clsDataBase:imageDataReadFromDbWriteToFile" + ex.Message)
                LOG.WriteToArchiveLog("clsDatabaseARCH : writeAttachmentFromDbWriteToFile : 4795 : ", ex)
            End Try

            MyCB = Nothing
            ds = Nothing
            da = Nothing

            CN.Close()
            CN = Nothing
            GC.Collect()
        Catch ex As Exception
            Dim AppName As String = ex.Source
            ' xTrace(CInt(58342.1), "clsDataBase:imageDataReadFromDbWriteToFile" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : writeAttachmentFromDbWriteToFile : 4803 : ", ex)
        End Try
        Return B

    End Function

    ''' <summary>
    ''' xes the populate ComboBox.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="S">The s.</param>
    Sub xPopulateComboBox(ByRef CB As ComboBox, ByVal TblColName As String, ByVal S As String)
        Try
            CloseConn()
            CkConn()
            If gConn.State = ConnectionState.Closed Then
                gConn.Open()
            End If
            Dim DA As New SqlDataAdapter(S, gConn)
            Dim DS As New DataSet
            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
            Next
            If iRowCnt = 0 Then
                Return
            End If
            'Bind the DataTable to the ComboBox by setting the Combobox's DataSource property to the DataTable. To display the "Description" column in the Combobox's list, set the Combobox's DisplayMember property to the name of column. Likewise, to use the "Code" column as the value of an item in the Combobox set the ValueMember property.
            CB.DropDownStyle = ComboBoxStyle.DropDown
            CB.DataSource = dt
            CB.DisplayMember = TblColName
            CB.SelectedIndex = 0

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not gConn Is Nothing Then
                gConn.Close()
                gConn = Nothing
            End If
        Catch ex As Exception
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : xPopulateComboBox : 4841 : ", ex)
        Finally
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Gets the email restore FQN parms.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="Subject">The subject.</param>
    ''' <param name="CreationTime">The creation time.</param>
    ''' <param name="SentOn">The sent on.</param>
    ''' <param name="MsgSize">Size of the MSG.</param>
    Sub getEmailRestoreFqnParms(ByVal EmailGuid As String, ByRef Subject As String, ByRef CreationTime As String, ByRef SentOn As String, ByRef MsgSize As String)
        Dim S As String = ""
        S = S + " select Subject, CreationTime, SentOn, MsgSize, EmailGuid"
        S = S + " from Email "
        S = S + " where EmailGuid = '" + EmailGuid + "'"

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Subject = RSData.GetValue(0).ToString
                CreationTime = RSData.GetValue(1).ToString
                SentOn = RSData.GetValue(2).ToString
                MsgSize = RSData.GetValue(3).ToString
            Loop
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' Gets the name of the email file restore.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="WorkingDirectory">The working directory.</param>
    ''' <param name="Suffix">The suffix.</param>
    ''' <returns>System.String.</returns>
    Function getEmailFileRestoreName(ByVal EmailGuid As String, ByVal WorkingDirectory As String, ByVal Suffix As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SkipExistingFiles As Boolean = False
        Dim OverwriteExistingFiles As Boolean = False
        Dim doThisForAllFiles As Boolean = False
        Dim VersionFiles As Boolean = False

        Dim FQN As String
        Dim Subject As String = ""
        Dim SourceName As String = ""
        Dim CreationTime As String = ""
        Dim SentOn As String = ""
        Dim MsgSize As String = ""
        Dim K As Integer = 1

        getEmailRestoreFqnParms(EmailGuid, Subject, CreationTime, SentOn, MsgSize)
        If Subject.Trim.Length = 0 Then
            Subject = "NO SUBJECT"
        End If
        SourceName = Subject + "." + CreationTime + "." + SentOn + "." + MsgSize
        '** WDM 3/12/2010 SourceName  = DMA.CheckFileName(SourceName )
        UTIL.StripUnwantedChars(SourceName)

        SourceName += Suffix.ToUpper

        Dim CH As String = Mid(WorkingDirectory, WorkingDirectory.Trim.Length, 1)
        If CH.Equals("\") Then
        Else
            WorkingDirectory = WorkingDirectory + "\"
        End If

        FQN = WorkingDirectory + SourceName

        'Dim F As File
        If File.Exists(FQN) Then

            '** WDM This section to be incorporated at a later time
            'If doThisForAllFiles = True Then
            '    If SkipExistingFiles = True Then

            ' End If If OverwriteExistingFiles = True Then

            ' End If

            ' If VersionFiles = True Then

            '    End If
            'Else
            '    If SkipExistingFiles = True Then

            ' End If If OverwriteExistingFiles = True Then

            ' End If

            ' If VersionFiles = True Then

            '    End If
            'End If

            Do While File.Exists(FQN)
                K += 1

                Subject = Mid(Subject, 1, 80)
                Subject = Trim(Subject)
                SourceName = Subject + "." + CreationTime + "." + SentOn + "." + MsgSize + ".Ver" + K.ToString + Suffix
                SourceName = DMA.CheckFileName(SourceName)
                CH = Mid(WorkingDirectory, WorkingDirectory.Trim.Length, 1)
                If CH.Equals("\") Then
                Else
                    WorkingDirectory = WorkingDirectory + "\"
                End If
                SourceName = DMA.CheckFileName(SourceName)
                FQN = WorkingDirectory + SourceName
            Loop
        End If
        Return FQN
    End Function

    ''' <summary>
    ''' Writes the email from database to file.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="WorkingDirectory">The working directory.</param>
    ''' <param name="Suffix">The suffix.</param>
    ''' <param name="currFileSize">Size of the curr file.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function writeEmailFromDbToFile(ByVal EmailGuid As String, ByVal WorkingDirectory As String, ByVal Suffix As String, ByVal currFileSize As Double) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim FQN As String = ""

        FQN = getEmailFileRestoreName(EmailGuid, WorkingDirectory, Suffix)
        UTIL.RemoveDoubleSlashes(FQN)
        Dim B As Boolean = True

        'Dim SourceFqn  = DMA.CheckFileName(FQN)

        Dim SourceTblName As String = "Email"
        Dim ImageFieldName As String = "EmailImage"

        Try
            'CloseConn()
            CkConn()

            Dim S As String = ""
            S = S + " SELECT "
            S = S + " [EmailImage]"
            S = S + " FROM  [Email]"
            S = S + " where [EmailGuid] = '" + EmailGuid + "'"

            Dim NewConnStr As String = getRepoConnStr()
            UTIL.ExtendTimeoutBySize(NewConnStr, currFileSize)

            Dim CN As New SqlConnection(NewConnStr)

            If CN.State = ConnectionState.Closed Then
                CN.Open()
            End If

            Dim da As New SqlDataAdapter(S, CN)
            Dim MyCB As SqlCommandBuilder = New SqlCommandBuilder(da)
            Dim ds As New DataSet()

            da.Fill(ds, SourceTblName)
            Dim myRow As DataRow
            myRow = ds.Tables(SourceTblName).Rows(0)

            Dim MyData() As Byte
            MyData = CType(myRow(ImageFieldName), Byte())
            Dim K As Long
            K = UBound(MyData)

            Try
                Dim fs As New FileStream(FQN, FileMode.CreateNew, FileAccess.Write)
                fs.Write(MyData, 0, CInt(K + 1))
                fs.Close()
                fs = Nothing
            Catch ex As Exception
                If ddebug Then Debug.Print(ex.Message)
                ' xTrace(CInt(42342.15), "clsDataBase:writeEmailFromDbToFile" + ex.Message)
                LOG.WriteToArchiveLog("clsDatabaseARCH : writeEmailFromDbToFile : 4871 : ", ex)
                LOG.WriteToArchiveLog("clsDatabaseARCH : writeEmailFromDbToFile : FQN : 4871 : " + FQN)
            End Try

            MyCB = Nothing
            ds = Nothing
            da = Nothing

            CN.Close()
            CN = Nothing
            GC.Collect()
        Catch ex As Exception
            Dim AppName As String = ex.Source
            ' xTrace(CInt(42342.1), "clsDataBase:writeEmailFromDbToFile" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : writeEmailFromDbToFile : 4879 : ", ex)
        End Try
        Return B

    End Function

    ''' <summary>
    ''' Populates the ComboBox.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="S">The s.</param>
    Sub PopulateComboBox(ByRef CB As ComboBox, ByVal TblColName As String, ByVal S As String)

        CB.Items.Clear()

        Dim tConn As New SqlConnection(getRepoConnStr())
        Dim DA As New SqlDataAdapter(S, tConn)
        Dim DS As New DataSet

        Try

            If tConn.State = ConnectionState.Closed Then
                tConn.Open()
            End If

            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
                Dim tItem As String = drDSRow(0).ToString
                tItem = UTIL.RemoveSingleQuotes(tItem)
                CB.Items.Add(tItem)
            Next
            If iRowCnt = 0 Then
                Return
            End If
            'Bind the DataTable to the ComboBox by setting the Combobox's DataSource property to the DataTable. To display the "Description" column in the Combobox's list, set the Combobox's DisplayMember property to the name of column. Likewise, to use the "Code" column as the value of an item in the Combobox set the ValueMember property.
            CB.DropDownStyle = ComboBoxStyle.DropDown
            'CB.DataSource = dt
            CB.DisplayMember = TblColName

            Try
                If CB.Items.Count > 0 Then
                    CB.SelectedIndex = 0
                End If
            Catch ex As Exception

            End Try

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
        Catch ex As Exception
            ' xTrace(12350, "clsDataBase:PopulateComboBox" + ex.Message)
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : PopulateComboBox : 4928.b : ", ex)
        Finally
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Populates the ComboBox merge.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="S">The s.</param>
    Sub PopulateComboBoxMerge(ByRef CB As ComboBox, ByVal TblColName As String, ByVal S As String)

        Dim tConn As New SqlConnection(getRepoConnStr())
        Dim DA As New SqlDataAdapter(S, tConn)
        Dim DS As New DataSet

        Try

            If tConn.State = ConnectionState.Closed Then
                tConn.Open()
            End If

            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
                Dim tItem As String = drDSRow(0).ToString
                tItem = UTIL.RemoveSingleQuotes(tItem)
                Dim bAdd As Boolean = True
                For II As Integer = 0 To CB.Items.Count - 1
                    If CB.Items(II).ToString.Equals(tItem) Then
                        bAdd = False
                        Exit For
                    End If
                Next
                If bAdd = True Then
                    CB.Items.Add(tItem)
                End If
            Next
            If iRowCnt = 0 Then
                Return
            End If
            'Bind the DataTable to the ComboBox by setting the Combobox's DataSource property to the DataTable. To display the "Description" column in the Combobox's list, set the Combobox's DisplayMember property to the name of column. Likewise, to use the "Code" column as the value of an item in the Combobox set the ValueMember property.
            CB.DropDownStyle = ComboBoxStyle.DropDown
            'CB.DataSource = dt
            CB.DisplayMember = TblColName
            Try
                If CB.Items.Count > 0 Then
                    CB.SelectedIndex = 0
                End If
            Catch ex As Exception

            End Try

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
        Catch ex As Exception
            ' xTrace(12350, "clsDataBase:PopulateComboBox" + ex.Message)
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : PopulateComboBox : 4928.c : ", ex)
        Finally
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Populates the ListBox merge.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="S">The s.</param>
    Sub PopulateListBoxMerge(ByRef LB As ListBox, ByVal TblColName As String, ByVal S As String)

        Dim tConn As New SqlConnection(getRepoConnStr())
        Dim DA As New SqlDataAdapter(S, tConn)
        Dim DS As New DataSet

        Try

            If tConn.State = ConnectionState.Closed Then
                tConn.Open()
            End If

            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
                Dim tItem As String = drDSRow(0).ToString
                tItem = UTIL.RemoveSingleQuotes(tItem)
                Dim bAdd As Boolean = True
                For II As Integer = 0 To LB.Items.Count - 1
                    If LB.Items(II).ToString.Equals(tItem) Then
                        bAdd = False
                        Exit For
                    End If
                Next
                If bAdd = True Then
                    LB.Items.Add(tItem)
                End If
            Next
            If iRowCnt = 0 Then
                Return
            End If

            LB.DisplayMember = TblColName
            Try
                If LB.Items.Count > 0 Then
                    LB.SelectedIndex = 0
                End If
            Catch ex As Exception

            End Try

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
        Catch ex As Exception
            ' xTrace(12350, "clsDataBase:PopulateComboBox" + ex.Message)
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : PopulateComboBox : 4928.d : ", ex)
        Finally
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Populates the ListBox remove.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="S">The s.</param>
    Sub PopulateListBoxRemove(ByRef LB As ListBox, ByVal TblColName As String, ByVal S As String)

        Dim tConn As New SqlConnection(getRepoConnStr())
        Dim DA As New SqlDataAdapter(S, tConn)
        Dim DS As New DataSet

        Try

            If tConn.State = ConnectionState.Closed Then
                tConn.Open()
            End If

            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
                Dim tItem As String = drDSRow(0).ToString
                tItem = UTIL.RemoveSingleQuotes(tItem)
                Dim bAdd As Boolean = True
                For II As Integer = 0 To LB.Items.Count - 1
                    If LB.Items(II).ToString.Equals(tItem) Then
                        LB.Items.RemoveAt(II)
                        Exit For
                    End If
                Next
            Next
            If iRowCnt = 0 Then
                Return
            End If

            LB.DisplayMember = TblColName
            Try
                If LB.Items.Count > 0 Then
                    LB.SelectedIndex = 0
                End If
            Catch ex As Exception

            End Try

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
        Catch ex As Exception
            ' xTrace(12350, "clsDataBase:PopulateComboBox" + ex.Message)
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : PopulateComboBox : 4928.a : ", ex)
        Finally
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not tConn Is Nothing Then
                tConn.Close()
                tConn = Nothing
            End If
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Populates the ListBox.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    ''' <param name="TblColName">Name of the table col.</param>
    ''' <param name="SelectionSql">The selection SQL.</param>
    Sub PopulateListBox(ByRef LB As ListBox, ByVal TblColName As String, ByVal SelectionSql As String)
        Try
            LB.DataSource = Nothing
            LB.Items.Clear()
            CloseConn()
            CkConn()
            If gConn.State = ConnectionState.Closed Then
                gConn.Open()
            End If
            Dim DA As New SqlDataAdapter(SelectionSql, gConn)
            Dim DS As New DataSet
            DA.Fill(DS, TblColName)

            'Create and populate the DataTable to bind to the ComboBox:
            Dim dt As New DataTable
            dt.Columns.Add(TblColName, GetType(System.String))

            ' Populate the DataTable to bind to the Combobox.
            Dim drDSRow As DataRow
            Dim drNewRow As DataRow
            Dim iRowCnt As Integer = 0
            For Each drDSRow In DS.Tables(TblColName).Rows()
                drNewRow = dt.NewRow()
                drNewRow(TblColName) = drDSRow(TblColName)
                dt.Rows.Add(drNewRow)
                iRowCnt += 1
            Next
            If iRowCnt = 0 Then
                Return
            End If
            'Bind the DataTable to the ComboBox by setting the Combobox's DataSource property to the DataTable.
            'To display the "Description" column in the Combobox's list, set the Combobox's DisplayMember property
            'to the name of column. Likewise, to use the "Code" column as the value of an item in the Combobox set
            'the ValueMember property.
            LB.DataSource = dt
            LB.DisplayMember = TblColName
            LB.SelectedIndex = 0

            If Not DS Is Nothing Then
                DS = Nothing
            End If
            If Not DA Is Nothing Then
                DA = Nothing
            End If
            If Not gConn Is Nothing Then
                gConn.Close()
                gConn = Nothing
            End If
        Catch ex As Exception
            ' xTrace(12350, "clsDataBase:PopulateListBox" + ex.Message)
            If ddebug Then Debug.Print("Error 2194.23: ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : PopulateListBox : 4968 : ", ex)
        Finally
            GC.Collect()

        End Try
    End Sub

    ''' <summary>
    ''' Populates the user sl.
    ''' </summary>
    ''' <param name="SL">The sl.</param>
    Sub PopulateUserSL(ByRef SL As SortedList)
        SL.Clear()
        Dim S As String = "Select [UserName], [UserID]  FROM [Users] order by [UserName]"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim UserName As String = ""
        Dim UserID As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                UserName = RSData.GetValue(0).ToString
                UserID = RSData.GetValue(1).ToString
                SL.Add(UserID, UserName)
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' Gets the datasource parm.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getDatasourceParm(ByVal AttributeName As String, ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'Select AttributeValue
        '  FROM [SourceAttribute]
        'where AttributeName = 'Author'
        'and SourceGuid = '6ff1c120-66cd-4aac-b2ec-85dda9f48bc8'
        'go

        Dim S As String = ""
        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim UserName As String = ""
        Dim UserID As String = ""
        Dim ColVAl As String = ""

        S = "Select AttributeValue "
        S = S + " FROM [SourceAttribute]"
        S = S + " where AttributeName = '" + AttributeName + "'"
        S = S + " and SourceGuid = '" + SourceGuid + "'"

        'Dim ddebug As Boolean = False
        'Dim queryString As String = Sql
        'Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing
        Dim CN As New SqlConnection(getRepoConnStr())

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim command As New SqlCommand(S, CN)

        Try
            rsDataQry = command.ExecuteReader()
            If rsDataQry.HasRows Then
                Do While rsDataQry.Read()
                    ColVAl = rsDataQry.GetValue(0).ToString
                Loop
            Else
                ColVAl = ""
            End If
        Catch ex As Exception
            ' xTrace(1001, "clsDataBase:getDatasourceParm" + ex.Message)
            ' xTrace(1002, "clsDataBase:getDatasourceParm", ex.StackTrace)
            ' xTrace(1003, "clsDataBase:getDatasourceParm", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getDatasourceParm : 5019 : ", ex)
        End Try

        If CN.State = ConnectionState.Open Then
            CN.Close()
        End If

        CN = Nothing
        command.Dispose()
        command = Nothing
        rsDataQry.Close()
        rsDataQry = Nothing
        Return ColVAl

    End Function

    ''' <summary>
    ''' Gets the table col string.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.String.</returns>
    Function getTblColString(ByVal S As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'Select AttributeValue
        '  FROM [SourceAttribute]
        'where AttributeName = 'Author'
        'and SourceGuid = '6ff1c120-66cd-4aac-b2ec-85dda9f48bc8'
        'go

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim UserName As String = ""
        Dim UserID As String = ""
        Dim ColVAl As String = ""

        'Dim ddebug As Boolean = False
        'Dim queryString As String = Sql
        'Dim rc As Boolean = False
        Dim rsDataQry As SqlDataReader = Nothing
        Dim CN As New SqlConnection(getRepoConnStr())

        If CN.State = ConnectionState.Closed Then
            CN.Open()
        End If

        Dim command As New SqlCommand(S, CN)

        Try
            rsDataQry = command.ExecuteReader()
            If rsDataQry.HasRows Then
                Do While rsDataQry.Read()
                    ColVAl = rsDataQry.GetValue(0).ToString
                Loop
            Else
                ColVAl = ""
            End If
        Catch ex As Exception
            ' xTrace(1001, "clsDataBase:getTblColString" + ex.Message)
            ' xTrace(1002, "clsDataBase:getTblColString", ex.StackTrace)
            ' xTrace(1003, "clsDataBase:getTblColString", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getTblColString : 5019 : ", ex)
        End Try

        If CN.State = ConnectionState.Open Then
            CN.Close()
        End If

        CN = Nothing
        command.Dispose()
        command = Nothing
        rsDataQry.Close()
        rsDataQry = Nothing
        Return ColVAl

    End Function

    ''' <summary>
    ''' Gets the saved value.
    ''' </summary>
    ''' <param name="userid">The userid.</param>
    ''' <param name="SaveName">Name of the save.</param>
    ''' <param name="SaveTypeCode">The save type code.</param>
    ''' <param name="ValName">Name of the value.</param>
    ''' <returns>System.String.</returns>
    Function getSavedValue(ByVal userid As String, ByVal SaveName As String, ByVal SaveTypeCode As String, ByVal ValName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If
        Dim S As String = ""
        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim UserName As String = ""
        Dim ColVAl As String = ""

        S = S + " Select [ValName]"
        S = S + " ,[ValValue]"
        S = S + " FROM [SavedItems]"
        S = S + " where userid = '" + userid + "'"
        S = S + " and SaveName = '" + SaveName + "'"
        S = S + " and SaveTypeCode = '" + SaveTypeCode + "'"
        S = S + " and ValName = '" + ValName + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                ColVAl = RSData.GetValue(1).ToString
                ColVAl = ColVAl.Trim
                ColVAl = UTIL.RemoveSingleQuotes(ColVAl)
            Loop
        Else
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSavedValue : Error 0000 : Did not find library item: " + SaveName + " : " + SaveTypeCode + " : " + ValName)
            ColVAl = ""
        End If
        RSData.Close()
        RSData = Nothing

        If LCase(ColVAl).Equals("null") Then
            ColVAl = ""
        End If

        Return ColVAl

    End Function

    ''' <summary>
    ''' Gets the last successful archive date.
    ''' </summary>
    ''' <param name="ArchiveType">Type of the archive.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function getLastSuccessfulArchiveDate(ByVal ArchiveType As String, ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select  max(archiveEndDate)"
        S = S + " FROM  [ArchiveStats]"
        S = S + " where "
        S = S + " [ArchiveType] = '" + ArchiveType + "'"
        S = S + " and [UserID] = '" + UserID + "'"
        S = S + " and Status = 'Successful'"

        Dim ColVAl As String = ""

        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            Do While RSData.Read()
                ColVAl = RSData.GetValue(0).ToString
                ColVAl = ColVAl.Trim
                ColVAl = UTIL.RemoveSingleQuotes(ColVAl)
            Loop
        Else
            ColVAl = ""
        End If
        'RSData.Close()
        'RSData = Nothing

        If LCase(ColVAl).Equals("null") Then
            ColVAl = ""
        End If

        Dim d1 As Date

        If ColVAl.Trim.Length = 0 Then
            'd1 = CDate("01/01/1900")
            d1 = Nothing
        Else
            d1 = CDate(ColVAl)
        End If

        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        RSData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()

        Return CStr(d1)

    End Function

    ''' <summary>
    ''' Cks the user start up parameter.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="ValName">Name of the value.</param>
    ''' <returns>System.Int32.</returns>
    Function ckUserStartUpParameter(ByVal Userid As String, ByVal ValName As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        '        where [SaveName] = 'UserStartUpParameters'
        'and [SaveTypeCode] = 'StartUpParm'
        'and ValName = 'Temp Directory'
        'and userid = 'smiller'

        Dim S As String = ""
        S = S + " where [SaveName] = 'UserStartUpParameters'"
        S = S + " and [SaveTypeCode] = 'StartUpParm'"
        S = S + " and ValName = '" + ValName + "'"
        S = S + " and userid = '" + Userid + "'"
        Dim B As Integer = iGetRowCount("SavedItems", S)

        Return B

    End Function

    ''' <summary>
    ''' Gets the working directory.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <param name="ValName">Name of the value.</param>
    ''' <returns>System.String.</returns>
    Function getWorkingDirectory(ByVal Userid As String, ByVal ValName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim ColVAl As String = ""
        Dim S As String = ""

        Try
            S = S + "Select [ValValue]"
            S = S + " FROM [SavedItems]"
            S = S + " where [SaveName] = 'UserStartUpParameters'"
            S = S + " and [SaveTypeCode] = 'StartUpParm'"
            S = S + " and ValName = '" + ValName + "'"
            S = S + " and userid = '" + Userid + "'"

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    ColVAl = RSData.GetValue(0).ToString
                    ColVAl = ColVAl.Trim
                    ColVAl = UTIL.RemoveSingleQuotes(ColVAl)
                Loop
            Else
                ColVAl = ""
            End If
            RSData.Close()
            RSData = Nothing

            If LCase(ColVAl).Equals("null") Then
                ColVAl = ""
            End If

            If ValName = "CONTENT WORKING DIRECTORY" Then
                If ColVAl.Length > 0 Then
                    If Not System.IO.Directory.Exists(ColVAl) Then
                        ColVAl = System.IO.Path.GetTempPath()
                    End If
                End If
            ElseIf ValName = "EMAIL WORKING DIRECTORY" Then
                If ColVAl.Length > 0 Then
                    If Not System.IO.Directory.Exists(ColVAl) Then
                        ColVAl = System.IO.Path.GetTempPath()
                    End If
                End If
            ElseIf ValName = "DBARCH WARNING LEVEL" Then
                If ColVAl.Length = 0 Then
                    ColVAl = "250"
                End If
            ElseIf ValName = "DBARCH RETURN INCREMENT" Then
                If ColVAl.Length = 0 Then
                    ColVAl = "100"
                End If
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR clsDatabaseARCH:getWorkingDirectory 100 - " + ex.Message + Environment.NewLine + ex.StackTrace)
        End Try

        Return ColVAl

    End Function

    ''' <summary>
    ''' is the count NBR email attachments.
    ''' </summary>
    ''' <param name="EMailGuid">The e mail unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function iCountNbrEmailAttachments(ByVal EMailGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim con As New SqlConnection(getRepoConnStr())
        con.Open()
        'Dim command As New SqlCommand(s, con)
        Dim RSData As SqlDataReader = Nothing

        Dim cnt As Integer = -1

        Try
            Dim tQuery As String = ""
            Dim s As String = ""

            s = "Select count(*) as TheCount From EmailAttachment where EmailGuid = '" & EMailGuid & "'"

            Using con
                RSData = SqlQry(s, con)
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
            End Using
        Catch ex As Exception
            ' xTrace(12360, "clsDataBase:iCountNbrEmailAttachments" + ex.Message)
            If ddebug Then Debug.Print("Error 3932.11.13: ", ex)
            Console.WriteLine("Error 3932.11.13: ", ex)
            cnt = 0
            LOG.WriteToArchiveLog("clsDatabaseARCH : iCountNbrEmailAttachments : 5163 : ", ex)
        Finally
            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            'command.Connection.Close()
            'command = Nothing
            If con.State = ConnectionState.Open Then
                con.Close()
            End If
            con = Nothing

        End Try

        Return cnt

    End Function

    ''' <summary>
    ''' Defines the file ext.
    ''' </summary>
    ''' <param name="LB">The lb.</param>
    Sub DefineFileExt(ByRef LB As List(Of String))
        Dim ColVAl As String = ""
        Dim S As String = ""
        S = S + " SELECT distinct [OriginalFileType]"
        S = S + " FROM DataSource"
        S = S + " order by OriginalFileType"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                ColVAl = RSData.GetValue(0).ToString
                ColVAl = ColVAl.Trim
                ColVAl = UTIL.RemoveSingleQuotes(ColVAl)
                DMA.ListRegistryKeys(ColVAl, LB)
            Loop
        End If

    End Sub

    ''' <summary>
    ''' Updates the BLOB.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="ImageColumnName">Name of the image column.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function UpdateBlob(ByVal TblName As String, ByVal ImageColumnName As String, ByVal WhereClause As String, ByVal FQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim b As Boolean = False
        Try
            Dim ConnStr As String = getRepoConnStr()
            Dim connection As New SqlConnection(ConnStr)

            Dim command As New SqlCommand("UPDATE " + TblName + " SET " + ImageColumnName + " = @FileContents " + WhereClause, connection)
            command.Parameters.Add("@FileContents", SqlDbType.VarBinary).Value = IO.File.ReadAllBytes(FQN)
            connection.Open()
            command.ExecuteNonQuery()
            connection.Close()
            b = True
        Catch ex As Exception
            ' xTrace(12365, "clsDataBase:UpdateBlob" + ex.Message)
            b = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : UpdateBlob : 5190 : ", ex)
        End Try
        Return b
    End Function

    ''' <summary>
    ''' Rebuilds the fulltext catalog.
    ''' </summary>
    Sub RebuildFulltextCatalog()
        Dim S As String = ""
        S = "EXEC sp_fulltext_catalog 'ftCatalog', 'start_full' "
        ExecuteSqlNewConn(S, False)
        S = "EXEC sp_fulltext_catalog 'EMAIL_CATELOG', 'start_full' "
        ExecuteSqlNewConn(S, False)
    End Sub

    ''' <summary>
    ''' Determines whether the specified userid is admin.
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <returns><c>true</c> if the specified userid is admin; otherwise, <c>false</c>.</returns>
    Function isAdmin(ByVal Userid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False

        Dim ColVAl As String = ""
        Dim S As String = "Select [Admin] FROM [Users] where userid = '" + gCurrUserGuidID + "'"

        Dim RSData As SqlDataReader = Nothing
        'Dim CS  = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsdata= command.ExecuteReader()
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            RSData.Read()
            ColVAl = RSData.GetValue(0).ToString
            ColVAl = ColVAl.Trim
            If ColVAl.Equals("True") Then
                B = True
            End If
            If ColVAl.Equals("0") Then
                B = False
            End If
            If ColVAl.Equals("1") Then
                B = True
            End If
            If ColVAl.Equals("") Then
                B = False
            End If
            If ColVAl.Equals("Y") Then
                B = True
            End If
            If ColVAl.Equals("N") Then
                B = False
            End If
            If ColVAl.Equals("A") Then
                B = True
            End If
            If ColVAl.Equals("S") Then
                B = True
            End If
            If ColVAl.Equals("G") Then
                B = False
            End If
        End If

        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        RSData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()

        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is global searcher] [the specified userid].
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <returns><c>true</c> if [is global searcher] [the specified userid]; otherwise, <c>false</c>.</returns>
    Function isGlobalSearcher(ByVal Userid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False

        Dim ColVAl As String = ""
        Dim S As String = "Select [Admin] FROM [Users] where userid = '" + Userid + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            RSData.Read()
            ColVAl = RSData.GetValue(0).ToString
            ColVAl = ColVAl.Trim
            If ColVAl.Equals("G") Or ColVAl.Equals("A") Or ColVAl.Equals("S") Then
                B = True
            End If
        End If
        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is super admin] [the specified userid].
    ''' </summary>
    ''' <param name="Userid">The userid.</param>
    ''' <returns><c>true</c> if [is super admin] [the specified userid]; otherwise, <c>false</c>.</returns>
    Function isSuperAdmin(ByVal Userid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False

        Dim ColVAl As String = ""
        Dim S As String = "Select [Admin] FROM [Users] where userid = '" + Userid + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            RSData.Read()
            ColVAl = RSData.GetValue(0).ToString
            ColVAl = ColVAl.Trim
            If ColVAl.Equals("S") Then
                B = True
            End If
        End If
        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is image file] [the specified t file type].
    ''' </summary>
    ''' <param name="tFileType">Type of the t file.</param>
    ''' <returns><c>true</c> if [is image file] [the specified t file type]; otherwise, <c>false</c>.</returns>
    Function isImageFile(ByVal tFileType As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If InStr(tFileType, "\") > 0 Then
            tFileType = DMA.getFileExtension(tFileType)
        End If

        Dim B As Boolean = False

        B = ckOcrNeeded(tFileType)
        If B Then
            Return True
        End If

        Dim I As Integer = 0
        Dim S As String = "Select count(*) FROM [ImageTypeCodes] where [ImageTypeCode] = '" + tFileType + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            RSData.Read()
            I = RSData.GetInt32(0)
            If I > 0 Then
                B = True
            Else
                B = False
            End If
        End If
        Return B
    End Function

    ''' <summary>
    ''' Gets the size of the email.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function getEmailSize(ByVal EmailGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim I As Integer = 0
        Dim B As Boolean = False
        Dim S As String = "Select msgsize from Email where EmailGuid = '" + EmailGuid + "'"
        Dim RSData As SqlDataReader = Nothing

        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                I = RSData.GetInt32(0)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("getEmailSize - Warning: email - no msgsize found: ", ex)
            I = 0
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try

        Return I
    End Function

    ''' <summary>
    ''' Gets the dir unique identifier.
    ''' </summary>
    ''' <param name="DirFQN">The dir FQN.</param>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <returns>System.String.</returns>
    Function getDirGuid(ByVal DirFQN As String, ByVal MachineName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        DirFQN = UTIL.RemoveSingleQuotes(DirFQN)

        Dim B As Boolean = False
        Dim tGuid As String = ""
        Dim S As String = ""
        S = " SELECT [DirGuid] FROM [DirectoryGuids] where [DirFQN]   = '" + DirFQN + "' "

        Dim RSData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tGuid = RSData.GetValue(0).ToString
            Else
                tGuid = Guid.NewGuid.ToString
                S = "Insert into DirectoryGuids (DirFQN,DirGuid) values ('" + DirFQN + "','" + tGuid + "') "
                Dim BB As Boolean = ExecuteSqlNewConn(90106, S)
                If BB = False Then
                    tGuid = ""
                End If
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getDirGuid - : ", ex)
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try
        Return tGuid
    End Function

    ''' <summary>
    ''' Gets the dir listener name by unique identifier.
    ''' </summary>
    ''' <param name="DirGuid">The dir unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getDirListenerNameByGuid(ByVal DirGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim DirName As String = ""
        Dim S As String = ""
        S = " SELECT [DirFqn] FROM [DirectoryGuids] where [DirGuid]   = '" + DirGuid + "' "

        Dim RSData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                DirName = RSData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getDirListenerNameByGuid - Warning: : ", ex)
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try
        Return DirName
    End Function

    ''' <summary>
    ''' Gets the description.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getDescription(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim sData As String = ""
        Dim S As String = "Select Description from DataSource where SourceGuid = '" + SourceGuid + "'"
        Dim RSData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

            If RSData.HasRows Then
                RSData.Read()
                sData = RSData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("getDocSize - Warning: email - no msgsize found: ", ex)
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try

        sData = UTIL.RemoveSingleQuotes(sData)

        Return sData
    End Function

    ''' <summary>
    ''' Gets the sd cols.
    ''' </summary>
    ''' <param name="ConnstrName">Name of the connstr.</param>
    ''' <param name="TableName">Name of the table.</param>
    ''' <returns>System.String.</returns>
    Function getSdCols(ByVal ConnstrName As String, ByVal TableName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ConnstrName = UTIL.RemoveSingleQuotes(ConnstrName)
        TableName = UTIL.RemoveSingleQuotes(TableName)

        Dim B As Boolean = False
        Dim sData As String = ""
        Dim S As String = "Select [SelectedColumns] FROM [ConnectionStringsSaved] where ConnstrName  = '" + ConnstrName + "' and TableName = '" + TableName + "' "
        Dim RSData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                sData = RSData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("getDocSize - Warning: email - no msgsize found: ", ex)
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try

        sData = UTIL.RemoveSingleQuotes(sData)

        Return sData
    End Function

    ''' <summary>
    ''' Refactors the userid.
    ''' </summary>
    ''' <param name="FromUserid">From userid.</param>
    ''' <param name="ToUserid">Converts to userid.</param>
    ''' <returns>System.String.</returns>
    Function RefactorUserid(ByVal FromUserid As String, ByVal ToUserid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim Msg As String = ""

        Dim myConnection As New SqlConnection("Data Source=localhost;Initial Catalog=Northwind;uid=sa;pwd=sa;")
        myConnection.Open()

        Dim myTrans = myConnection.BeginTransaction()
        Dim myCommand As New SqlCommand()
        myCommand.Connection = myConnection
        myCommand.Transaction = myTrans
        Try
            myCommand.CommandText = "Insert into Region (RegionID, RegionDescription) VALUES (100, 'Description')"
            myCommand.ExecuteNonQuery()
            myCommand.CommandText = "delete * from Region where RegionID=101"
            myCommand.ExecuteNonQuery()
            myTrans.Commit()
            Msg = "The userid was successfully changed from " + FromUserid + " to " + ToUserid + " throughout the entire repository for both content and emails."
        Catch ep As Exception
            myTrans.Rollback()
            Msg = "ERROR: The userid Failed to change from " + FromUserid + " to " + ToUserid + ". All transactions rolled back to original state."
            LOG.WriteToArchiveLog("clsDatabaseARCH : RefactorUserid : 5255 : " + ep.Message)
        Finally
            myConnection.Close()

        End Try
        Return Msg
    End Function

    ''' <summary>
    ''' Gets the pw.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.String.</returns>
    Function getPw(ByVal UID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim ColVAl As String = ""
        Dim S As String = "Select [UserPassword] FROM  [Users] where UserID = '" + UID + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        'CS = ENC.AES256DecryptString(CS)

        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            RSData.Read()
            ColVAl = RSData.GetValue(0).ToString
            ColVAl = ColVAl.Trim
        End If
        Return ColVAl
    End Function

    ''' <summary>
    ''' is the content of the count user.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.Int32.</returns>
    Function iCountUserContent(ByVal UID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from DataSource where DataSourceOwnerUserID = '" + UID + "'"

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(12370, "clsDataBase:iCountUserContent" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : iCountUserContent : 5280 : ", ex)
        End Try

        Return cnt
    End Function

    ''' <summary>
    ''' is the count user emails.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.Int32.</returns>
    Function iCountUserEmails(ByVal UID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from email where Userid = '" + UID + "'"

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(12371, "clsDataBase:iCountUserEmails" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : iCountUserEmails : 5296 : ", ex)
        End Try

        Return cnt
    End Function

    ''' <summary>
    ''' Saves the error MSG.
    ''' </summary>
    ''' <param name="ErrMsg">The error MSG.</param>
    ''' <param name="ErrStack">The error stack.</param>
    ''' <param name="IDNBR">The idnbr.</param>
    ''' <param name="ConnectiveGuid">The connective unique identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function SaveErrMsg(ByVal ErrMsg As String, ByVal ErrStack As String, ByVal IDNBR As String, ByVal ConnectiveGuid As String) As String

        Dim DBARCH As New clsDatabaseARCH
        Dim rc As String = ""
        Dim SQL As String = ""

        Dim ConnectionString As String = getRepoConnStr()
        Dim CN As New SqlConnection(ConnectionString)

        Try
            If CN.State = ConnectionState.Closed Then
                CN.Open()
            End If

            ErrMsg = UTIL.RemoveSingleQuotes(ErrMsg)
            ErrStack = UTIL.RemoveSingleQuotes(ErrStack)

            Dim S As String = "INSERT INTO [RuntimeErrors] "
            S = S + "([ErrorMsg]"
            S = S + ",[StackTrace]"
            S = S + ",IdNbr, ConnectiveGuid, Userid)"
            S = S + "VALUES "
            S = S + "('" + ErrMsg + "'"
            S = S + ",'" + ErrStack + "'"
            S = S + ",'" + IDNBR + "' "
            S = S + ",'" + ConnectiveGuid + "' "
            S = S + ",'" + gCurrUserGuidID + "')"

            Using CN
                Dim dbCmd As SqlCommand = CN.CreateCommand()
                dbCmd.Connection = CN
                Try
                    dbCmd.CommandText = S
                    dbCmd.ExecuteNonQuery()
                    ' Attempt to commit the transaction.
                    'transaction.Commit()

                    'Dim debug As Boolean = True
                    'If debug Then
                    '    Console.WriteLine("Successful execution: " + environment.NewLine + S )
                    'End If
                    rc = CStr(True)
                Catch ex As Exception
                    rc = "SaveErrMsg" + Environment.NewLine + ex.Message + Environment.NewLine + Environment.NewLine + ex.StackTrace
                    LOG.WriteToArchiveLog("clsDatabaseARCH : SaveErrMsg : 5325 : ", ex)
                End Try
                If CN.State = Data.ConnectionState.Open Then
                    CN.Close()
                End If
                If Not CN Is Nothing Then
                    CN = Nothing
                End If
                If dbCmd Is Nothing Then
                    dbCmd = Nothing
                End If
            End Using
        Catch ex As Exception
            rc = "SaveErrMsg" + Environment.NewLine + ex.Message + Environment.NewLine + Environment.NewLine + ex.StackTrace
            LOG.WriteToArchiveLog("clsDatabaseARCH : SaveErrMsg : 5336 : ", ex)
        End Try

        'If CN.State = Data.ConnectionState.Open Then
        '    CN.Close()
        'End If
        'If Not CN Is Nothing Then
        '    CN = Nothing
        'End If

        Return rc

    End Function

    ''' <summary>
    ''' Gets the missing vaules.
    ''' </summary>
    ''' <param name="tGuid">The t unique identifier.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="LastWriteTime">The last write time.</param>
    ''' <param name="RetentionExpirationDate">The retention expiration date.</param>
    ''' <param name="IsPublic">The is public.</param>
    Sub getMissingVaules(ByVal tGuid As String, ByRef VersionNbr As String, ByRef LastAccessDate As String, ByRef LastWriteTime As String, ByRef RetentionExpirationDate As String, ByRef IsPublic As String)
        Dim S As String = " SELECt  [VersionNbr]"
        S = S + " ,[LastAccessDate]      "
        S = S + " ,[LastWriteTime]"
        S = S + " ,[RetentionExpirationDate]"
        S = S + " ,[IsPublic]"
        S = S + " FROM DataSource"
        S = S + " where [SourceGuid] = '" + tGuid + "' "

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                VersionNbr = RSData.GetValue(0).ToString
                LastAccessDate = RSData.GetValue(1).ToString
                LastWriteTime = RSData.GetValue(2).ToString
                RetentionExpirationDate = RSData.GetValue(3).ToString
                IsPublic = RSData.GetValue(4).ToString
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(9001, "clsDataBase:getMissingVaules" + ex.Message)
            ' xTrace(9002, "clsDataBase:getMissingVaules", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getMissingVaules : 5363 : ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the missing email vaules.
    ''' </summary>
    ''' <param name="tGuid">The t unique identifier.</param>
    ''' <param name="RetentionExpirationDate">The retention expiration date.</param>
    ''' <param name="IsPublic">The is public.</param>
    Sub getMissingEmailVaules(ByVal tGuid As String, ByRef RetentionExpirationDate As String, ByRef IsPublic As String)
        Dim S As String = " SELECT [isPublic],[RetentionExpirationDate] FROM [Email] where [EmailGuid] = '" + tGuid + "'"

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                IsPublic = RSData.GetValue(0).ToString
                RetentionExpirationDate = RSData.GetValue(1).ToString
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(92301, "clsDataBase:getMissingEmailVaules" + ex.Message)
            ' xTrace(92302, "clsDataBase:getMissingEmailVaules", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getMissingEmailVaules : 5381 : ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the meta data.
    ''' </summary>
    ''' <param name="tGuid">The t unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getMetaData(ByVal tGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        S = S + " SELECT [AttributeValue], [AttributeName] "
        S = S + " FROM  [SourceAttribute]"
        S = S + " where [SourceGuid] = '" + tGuid + "' "
        S = S + " order by [AttributeName]"

        Dim Msg As String = ""

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read
                        Dim AttributeValue As String = RSData.GetValue(0).ToString + " ... " + Environment.NewLine
                        Dim AttributeName As String = RSData.GetValue(1).ToString + " ... " + Environment.NewLine
                        Msg += AttributeName + ":" + AttributeValue + Environment.NewLine
                    Loop
                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(10101, "clsDataBase:getMetaData" + ex.Message)
            ' xTrace(10102, "clsDataBase:getMetaData", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getMetaData : 5406 : ", ex)
        End Try
        Return Msg
    End Function

    ''' <summary>
    ''' Gets the system parm.
    ''' </summary>
    ''' <param name="SysParm">The system parm.</param>
    ''' <returns>System.String.</returns>
    Function getSystemParm(ByVal SysParm As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        SysParm = UTIL.RemoveSingleQuotes(SysParm)

        Dim S As String = ""
        S = S + " SELECT [SysParmVal] FROM [SystemParms] where [SysParm] = '" + SysParm + "' "

        Dim SystemParameter As String = ""

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read
                        SystemParameter = RSData.GetValue(0).ToString
                    Loop
                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(10101, "clsDataBase:getSystemParm" + ex.Message)
            ' xTrace(10102, "clsDataBase:getSystemParm", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSystemParm : 5406 : ", ex)
        End Try
        Return SystemParameter
    End Function

    ''' <summary>
    ''' Gets the user parm.
    ''' </summary>
    ''' <param name="UserParm">The user parm.</param>
    ''' <returns>System.String.</returns>
    Function getUserParm(ByVal UserParm As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If gCurrUserGuidID.Length = 0 Then
            Return "0"
        End If
        UserParm = UTIL.RemoveSingleQuotes(UserParm)

        Dim S As String = "Select ParmValue from [RunParms] where Parm = '" + UserParm + "' and userid = '" + gCurrUserGuidID + "'"
        Dim SystemParameter As String = ""

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read
                        SystemParameter = RSData.GetValue(0).ToString
                    Loop
                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(10101, "clsDataBase:getUserParm" + ex.Message)
            ' xTrace(10102, "clsDataBase:getUserParm", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserParm : 5406 : ", ex)
        End Try
        Return SystemParameter
    End Function

    ''' <summary>
    ''' Gets the user parm.
    ''' </summary>
    ''' <param name="UserParm">The user parm.</param>
    ''' <param name="DefaultValue">The default value.</param>
    ''' <returns>System.String.</returns>
    Function getUserParm(ByVal UserParm As String, ByVal DefaultValue As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If gCurrUserGuidID.Length = 0 Then
            Return "0"
        End If
        UserParm = UTIL.RemoveSingleQuotes(UserParm)

        Dim S As String = "Select ParmValue from [RunParms] where Parm = '" + UserParm + "' and userid = '" + gCurrUserGuidID + "'"
        Dim SystemParameter As String = ""

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read
                        SystemParameter = RSData.GetValue(0).ToString
                    Loop
                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            ' xTrace(10101, "clsDataBase:getUserParm" + ex.Message)
            ' xTrace(10102, "clsDataBase:getUserParm", S)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserParm : 5406 : ", ex)
        End Try
        Return SystemParameter
    End Function

    ''' <summary>
    ''' Gets the content columns.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SL">The sl.</param>
    Sub getContentColumns(ByVal SourceGuid As String, ByRef SL As SortedList)
        Dim S As String = ""
        S = S + " SELECT  "
        S = S + " [CreateDate]()"
        S = S + " ,[SourceName]"
        S = S + " ,[SourceTypeCode]"
        S = S + " ,[FQN]"
        S = S + " ,[VersionNbr]"
        S = S + " ,[LastAccessDate]"
        S = S + " ,[FileLength]"
        S = S + " ,[LastWriteTime]"
        S = S + " ,[UserID]"
        S = S + " ,[DataSourceOwnerUserID]"
        S = S + " ,[isPublic]"
        S = S + " ,[FileDirectory]"
        S = S + " ,[OriginalFileType]"
        S = S + " ,[RetentionExpirationDate]"
        S = S + " ,[IsPublicPreviousState]"
        S = S + " ,[isAvailable]"
        S = S + " ,[isContainedWithinZipFile]"
        S = S + " ,[ZipFileGuid]"
        S = S + " ,[IsZipFile]"
        S = S + " ,[DataVerified]"
        S = S + " FROM([DataSource])"
        S = S + " where [SourceGuid] = '" + SourceGuid + "'"

        CloseConn()
        CkConn()

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        SL.Clear()
        If RSData.HasRows Then
            Do While RSData.Read()
                SL.Clear()
                Dim iCols As Integer = RSData.FieldCount - 1
                For iCols = 0 To RSData.FieldCount - 1
                    FillSortedList(RSData, iCols, SL)
                Next
            Loop
        Else
            SL.Clear()
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the email columns.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SL">The sl.</param>
    Sub getEmailColumns(ByVal SourceGuid As String, ByRef SL As SortedList)
        Dim S As String = ""
        S = S + " SELECT  "
        S = S + " [EmailGuid]"
        S = S + " ,[SUBJECT]"
        S = S + " ,[SentTO]"
        S = S + " ,[Body]"
        S = S + " ,[Bcc]"
        S = S + " ,[BillingInformation]"
        S = S + " ,[CC]"
        S = S + " ,[Companies]"
        S = S + " ,[CreationTime]"
        S = S + " ,[ReadReceiptRequested]"
        S = S + " ,[ReceivedByName]"
        S = S + " ,[ReceivedTime]"
        S = S + " ,[AllRecipients]"
        S = S + " ,[UserID]"
        S = S + " ,[SenderEmailAddress]"
        S = S + " ,[SenderName]"
        S = S + " ,[Sensitivity]"
        S = S + " ,[SentOn]"
        S = S + " ,[MsgSize]"
        S = S + " ,[DeferredDeliveryTime]"
        S = S + " ,[EntryID]"
        S = S + " ,[ExpiryTime]"
        S = S + " ,[LastModificationTime]"
        S = S + " ,[EmailImage]"
        S = S + " ,[Accounts]"
        S = S + " ,[RowID]"
        S = S + " ,[ShortSubj]"
        S = S + " ,[SourceTypeCode]"
        S = S + " ,[OriginalFolder]"
        S = S + " ,[StoreID]"
        S = S + " ,[isPublic]"
        S = S + " ,[RetentionExpirationDate]"
        S = S + " ,[IsPublicPreviousState]"
        S = S + " ,[isAvailable]"
        S = S + " FROM  [Email]"
        S = S + " where [EmailGuid] = '" + SourceGuid + "'"

        CloseConn()
        CkConn()

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        SL.Clear()
        If RSData.HasRows Then
            Do While RSData.Read()
                SL.Clear()
                Dim iCols As Integer = RSData.FieldCount - 1
                For iCols = 0 To RSData.FieldCount - 1
                    FillSortedList(RSData, iCols, SL)
                Next
            Loop
        Else
            SL.Clear()
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Fills the sorted list.
    ''' </summary>
    ''' <param name="RSData">The rs data.</param>
    ''' <param name="iRow">The i row.</param>
    ''' <param name="SL">The sl.</param>
    Sub FillSortedList(ByVal RSData As SqlDataReader, ByVal iRow As Integer, ByRef SL As SortedList)
        Dim cName As String = RSData.GetName(iRow).ToString
        Try
            Dim tColValue As String = RSData.GetValue(0).ToString
            SL.Add(cName, tColValue)
        Catch ex As Exception
            Dim tColValue As String = ""
            SL.Add(cName, tColValue)
            LOG.WriteToArchiveLog("clsDatabaseARCH : FillSortedList : 5508 : ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the unique identifier by FQN.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <returns>System.String.</returns>
    Function GetGuidByFqn(ByVal FQN As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = "Select top 1 SourceGuid from 
                                DataSource where FQN = '" + FQN + "' and machineid = '" + gMachineID + "' and UserID = '" + gCurrLoginID + "' order by VersionNbr desc "
        CloseConn()
        CkConn()
        Dim xGuid As String = ""

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

        If rsData.HasRows Then
            rsData.Read()
            xGuid = rsData.GetValue(0).ToString
        Else
            xGuid = ""
        End If

        rsData.Close()
        rsData = Nothing

        Return xGuid

    End Function

    ''' <summary>
    ''' Gets the unique identifier by URL.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>System.String.</returns>
    Function GetGuidByURL(ByVal FQN As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = "Select  SourceGuid FROM DataSource where FQN = '" + FQN + "' "
        CloseConn()
        CkConn()
        Dim xGuid As String = ""

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()

        If rsData.HasRows Then
            rsData.Read()
            xGuid = rsData.GetValue(0).ToString
        Else
            xGuid = ""
        End If

        rsData.Close()
        rsData = Nothing

        Return xGuid

    End Function

    ''' <summary>
    ''' Gets the name of the library owner by.
    ''' </summary>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <returns>System.String.</returns>
    Function GetLibOwnerByName(ByVal LibraryName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If InStr(LibraryName, "''") > 0 Then
        Else
            LibraryName = UTIL.RemoveSingleQuotes(LibraryName)
        End If

        Dim S As String = "Select UserID from Library where LibraryName = '" + LibraryName + "' "
        CloseConn()
        CkConn()
        Dim xGuid As String = ""

        Dim rsData As SqlDataReader = Nothing
        Dim b As Boolean = False

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        rsData = command.ExecuteReader()

        If rsData.HasRows Then
            rsData.Read()
            xGuid = rsData.GetValue(0).ToString
        Else
            xGuid = ""
        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()

        Return xGuid

    End Function

    ''' <summary>
    ''' Adds the document source description.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="Description">The description.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function addDocSourceDescription(ByVal SourceGuid As String, ByVal Description As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Description = UTIL.RemoveSingleQuotes(Description)
        Dim S As String = ""
        S = "UPDATE [DataSource] set Description = '" + Description + "' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        Return b
    End Function

    'Function addDocSourceError(ByVal SourceGuid , ByVal Notes ) As Boolean
    '    Notes = UTIL.RemoveSingleQuotes(Notes)
    '    Dim S  = ""
    '    S  = "UPDATE [DataSource] set Notes = '" + Notes + "' where SourceGuid = '" + SourceGuid + "'"
    '    Dim b As Boolean = ExecuteSqlNewConn(S, False)
    '    Return b
    'End Function

    ''' <summary>
    ''' Adds the document source key words.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="KeyWords">The key words.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function addDocSourceKeyWords(ByVal SourceGuid As String, ByVal KeyWords As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        KeyWords = UTIL.RemoveSingleQuotes(KeyWords)
        Dim S As String = ""
        S = "UPDATE [DataSource] set KeyWords = '" + KeyWords + "' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        Return b
    End Function

    ''' <summary>
    ''' Updates the meta data.
    ''' </summary>
    ''' <param name="Author">The author.</param>
    ''' <param name="Description">The description.</param>
    ''' <param name="Keywords">The keywords.</param>
    ''' <param name="QuickRefIdNbr">The quick reference identifier NBR.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="MetadataTag">The metadata tag.</param>
    ''' <param name="MetadataValue">The metadata value.</param>
    ''' <param name="Library">The library.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function UpdateMetaData(ByVal Author As String, ByVal Description As String, ByVal Keywords As String, ByVal QuickRefIdNbr As String, ByVal FQN As String, ByVal MetadataTag As String, ByVal MetadataValue As String, ByVal Library As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        MetadataTag = UTIL.RemoveSingleQuotes(MetadataTag)
        MetadataValue = UTIL.RemoveSingleQuotes(MetadataValue)
        Library = UTIL.RemoveSingleQuotes(Library)

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Author = UTIL.RemoveSingleQuotes(Author)
        Description = UTIL.RemoveSingleQuotes(Description)
        Keywords = UTIL.RemoveSingleQuotes(Keywords)
        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim S As String = ""

        S = "update QuickRefItems set Author = '" + Author
        S = S + "', Description = '" + Description
        S = S + "', Keywords = '" + Keywords
        S = S + "', MetadataTag = '" + MetadataTag
        S = S + "', MetadataValue = '" + MetadataValue
        S = S + "', Library = '" + Library
        S = S + "' where QuickRefIdNbr = " + QuickRefIdNbr
        S = S + " and FQN = '" + FQN.ToString + "'"

        Dim b As Boolean = ExecuteSqlNewConn(S, False)

        Return b

    End Function

    ''' <summary>
    ''' Loads the process dates.
    ''' </summary>
    Sub LoadProcessDates()

        Dim S As String = ""
        S = S + " select OriginalFolder, max(CreationTime) as MaxDate "
        S = S + " FROM EMAIL "
        S = S + " group by OriginalFolder"

        Dim OriginalFolder As String = ""
        Dim MaxDate As Date = Now

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        UTIL.setConnectionStringTimeout(CStr(600))
        Dim CONN As New SqlConnection(CS)

        Try
            CloseConn()
            CkConn()

            slProcessDates.Clear()

            'RSData = SqlQryNo'Session(S)
            CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

            If RSData.HasRows Then
                Do While RSData.Read()
                    OriginalFolder = RSData.GetValue(0).ToString
                    MaxDate = CDate(RSData.GetValue(1).ToString)
                    addEmailProcessDate(OriginalFolder, MaxDate)
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: LoadProcessDates 100 - ", ex)
        Finally
            If RSData IsNot Nothing Then
                If Not RSData.IsClosed Then
                    RSData.Close()
                End If
                RSData = Nothing

            End If
            If CONN IsNot Nothing Then
                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
            End If
            RSData = Nothing
            CONN.Dispose()
            'Command = Nothing
        End Try

    End Sub

    'select LibraryName FROM LibDirectory where DirectoryName = 'c:\temp'
    ''' <summary>
    ''' Gets the library dirs.
    ''' </summary>
    ''' <param name="DirectoryName">Name of the directory.</param>
    ''' <param name="L">The l.</param>
    Sub getLibDirs(ByVal DirectoryName As String, ByRef L As List(Of String))

        L.Clear()
        DirectoryName = UTIL.RemoveSingleQuotes(DirectoryName)

        Dim S As String = "Select LibraryName FROM LibDirectory where DirectoryName = '" + DirectoryName + "'"

        CloseConn()
        CkConn()

        slProcessDates.Clear()

        Dim LibraryName As String = ""

        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

        If RSData.HasRows Then
            Do While RSData.Read()
                LibraryName = RSData.GetValue(0).ToString
                LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

                If Not L.Contains(LibraryName) Then
                    L.Add(LibraryName)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' Gets the source unique identifier by FQN.
    ''' </summary>
    ''' <param name="fqn">The FQN.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function getSourceGuidByFqn(ByVal fqn As String, ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        fqn = UTIL.RemoveSingleQuotes(fqn)
        Try
            Dim S As String = " SELECT top 1 SourceGuid FROM DataSource where FQN = '" + fqn + "' AND DataSourceOwnerUserID = '" + UserID + "' order by VersionNbr desc"
            Dim SourceGuid As String = ""

            Dim CS As String = getRepoConnStr()
            Dim RSData As SqlDataReader = Nothing
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            If RSData.HasRows Then
                Do While RSData.Read()
                    SourceGuid = RSData.GetValue(0).ToString
                Loop
            End If

            RSData.Close()
            RSData = Nothing

            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()

            Return SourceGuid
        Catch ex As Exception
            Me.xTrace(23456, "getSourceGuidByFqn", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSourceGuidByFqn : 5593 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSourceGuidByFqn : 5585 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSourceGuidByFqn : 5603 : ", ex)
            Return Nothing
        End Try

    End Function

    ''' <summary>
    ''' Gets the source unique identifier by sourcename CRC.
    ''' </summary>
    ''' <param name="Sourcename">The sourcename.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns>System.String.</returns>
    Function getSourceGuidBySourcenameCRC(ByVal Sourcename As String, ByVal CRC As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim sGuid As String = ""
        Try
            Sourcename = UTIL.RemoveSingleQuotes(Sourcename)

            Dim S As String = "Select  SourceGuid FROM DataSource where SourceName = '" + Sourcename + "' and CRC = " + CRC + " "
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                sGuid = rsData.GetString(0)
            End If

            rsData.Close()
        Catch ex As Exception
            ' xTrace(12311, "clsDataBase:getCountDataSourceFiles" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCountDataSourceFiles : 2174 : ", ex)
        End Try
        Return sGuid

    End Function

    ''' <summary>
    ''' Gets the source name by unique identifier.
    ''' </summary>
    ''' <param name="RowGuid">The row unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getSourceNameByGuid(ByVal RowGuid As String) As String
        Dim TD As New Dictionary(Of String, String)
        Dim SourceName As String = ""
        Dim sGuid As String = ""
        Try
            Dim S As String = "select top 1 SourceName, SourceTypeCode, OriginalFileType from DataSource where RowGuid = '" + RowGuid + "'"
            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            Using CONN
                CONN.Open()
                Dim command As New SqlCommand(S, CONN)
                Using command
                    Using rsData
                        rsData = command.ExecuteReader()
                        If rsData.HasRows Then
                            rsData.Read()
                            SourceName = rsData.GetString(0)
                            SourceTypeCode = rsData.GetString(1)
                            OriginalFileType = rsData.GetString(2)
                            SourceName = SourceName + "|" + SourceTypeCode + "|" + OriginalFileType
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getSourceNameByGuid : 2174 : " + ex.Message)
        End Try
        Return SourceName

    End Function

    ''' <summary>
    ''' Loads the entry identifier by user identifier.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub LoadEntryIdByUserID(ByRef L As SortedList)

        Dim S As String = "Select EmailIdentifier from email where UserID = '" + gCurrUserGuidID + "' "
        L.Clear()

        CloseConn()
        CkConn()
        Dim I As Integer = 0

        Dim RSData As SqlDataReader = Nothing
        RSData = Me.SqlQryNewConn(S)
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim EmailIdentifier As String = RSData.GetValue(0).ToString
                I += 1
                If I Mod 10 = 0 Then
                    frmMain.SB.Text = "ID# " + I.ToString
                    frmMain.SB.Refresh()
                End If
                'Dim II As Integer = L.IndexOfKey(EntryId)
                If Not L.ContainsKey(EmailIdentifier) Then
                    L.Add(EmailIdentifier, I)
                Else
                    If ddebug Then Debug.Print("Dup found")
                End If
                Application.DoEvents()
            Loop
        Else
            L.Clear()
        End If
        frmMain.PB1.Value = 0
        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        frmMain.SB.Text = ""
    End Sub

    ''' <summary>
    ''' Gets the count store identifier by folder.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function getCountStoreIdByFolder() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim iCnt As Integer = 0
        Dim S As String = "Select count(*) from email where Userid = '" + gCurrUserGuidID + "'"

        CloseConn()
        CkConn()

        Dim I As Integer = 0

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        RSData = Me.SqlQryNewConn(S)
        If RSData Is Nothing Then
            Return 0
        End If
        If RSData.HasRows Then
            Do While RSData.Read()
                iCnt = RSData.GetInt32(0)
            Loop
        End If

        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        Return iCnt
    End Function

    ''' <summary>
    ''' Gets the group users.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <param name="GroupList">The group list.</param>
    Sub getGroupUsers(ByVal GroupName As String, ByRef GroupList As ArrayList)

        If InStr(GroupName, "''") > 0 Then
        Else
            GroupName = UTIL.RemoveSingleQuotes(GroupName)
        End If

        Dim S As String = "Select [UserID] FROM  [GroupUsers] where [GroupName] = '" + GroupName + "' "
        CloseConn()
        CkConn()
        Dim I As Integer = 0

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        RSData = Me.SqlQryNewConn(S)
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim UserID As String = RSData.GetValue(0).ToString
                GroupList.Add(UserID)
            Loop
        End If

        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
    End Sub

    ''' <summary>
    ''' Updates the archive flag.
    ''' </summary>
    ''' <param name="ParentFolder">The parent folder.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFlag">a flag.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateArchiveFlag(ByVal ParentFolder As String, ByVal UID As String, ByVal aFlag As String, ByVal FolderName As String) As Boolean
        Dim b As Boolean = False
        Dim s As String = ""

        s = s + " update EmailFolder set "
        s = s + "SelectedForArchive = '" + aFlag + "'" + " where UserID = '" + UID + "' and FolderName = '" + FolderName + "' and ParentFolderName = '" + ParentFolder + "' "

        Return ExecuteSqlNewConn(s, False)
    End Function

    ''' <summary>
    ''' Deletes the email archive folder.
    ''' </summary>
    ''' <param name="ParentFolder">The parent folder.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="aFlag">a flag.</param>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function DeleteEmailArchiveFolder(ByVal ParentFolder As String, ByVal UID As String, ByVal aFlag As String, ByVal FolderName As String) As Boolean
        Dim b As Boolean = False
        Dim s As String = ""

        Dim ConcatParName As String = ParentFolder + "|" + FolderName

        s = s + " delete from EmailFolder "
        's = s + " where UserID = '" + UID + "' and FolderName = '" + FolderName + "' and ParentFolderName = '" + ParentFolder  + "' "
        s = s + " where UserID = '" + UID + "' and FolderName = '" + FolderName + "' "

        Return ExecuteSqlNewConn(s, False)
    End Function

    'Public Function getFolderNameById(ByVal FolderID ) As String
    '    Dim b As Boolean = True
    '    Dim S As String = ""
    '    S = "Select [FolderName]      "
    '    S = S + " FROM [EmailFolder]"
    '    S = S + " where [FolderID] = '" + FolderID + "'"
    '    Dim i As Integer = 0
    '    Dim id  = ""

    ' Dim rsData As SqlDataReader = Nothing

    '    Dim CS  = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsdata= command.ExecuteReader()
    '    If rsData.HasRows Then
    '        rsData.Read()
    '        id = rsData.GetValue(0).ToString
    '    Else
    '        id = ""
    '    End If
    '    rsData.Close()
    '    rsData = Nothing
    '    Return id
    'End Function
    ''' <summary>
    ''' Gets the parent folder name by identifier.
    ''' </summary>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getParentFolderNameById(ByVal FolderID As String) As String
        Dim b As Boolean = True
        Dim S As String = ""
        S = "Select [ParentFolderName]      "
        S = S + " FROM [EmailFolder]"
        S = S + " where [FolderID] = '" + FolderID + "'"
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If
        rsData.Close()
        rsData = Nothing
        Return id
    End Function

    ''' <summary>
    ''' Gets the archive folder ids.
    ''' </summary>
    ''' <param name="DGV">The DGV.</param>
    Public Sub getArchiveFolderIds(ByRef DGV As DataGridView)

        Dim SA As New SortedList(Of String, String)
        Try
            Dim b As Boolean = True
            Dim S As String = ""

            S = "Select FileDirectory, FolderName, FolderID, storeid from EmailFolder where SelectedForArchive = 'Y' and UserID = '" + gCurrUserGuidID + "'"
            Dim cNames As String = "FileDirectory, FolderName, FolderID, storeid"
            Dim A As String() = cNames.Split(CChar(","))
            Dim DGX As New clsDataGrid
            DGX.PopulateDataGrid(S, DGV, A)
            DGX = Nothing
            Dim II As Integer = DGV.Rows.Count
            LOG.WriteToArchiveLog("NOTICE: DGX Rowcount = " + II.ToString + " : " + S)
            Return
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getArchiveFolderIds 100 - : ", ex)
            SA = Nothing
        End Try

        DGV = Nothing

    End Sub

    ''' <summary>
    ''' Removes the group user.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function RemoveGroupUser(ByVal GroupName As String, ByVal UserID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = True
        Dim SqlList As New ArrayList
        Try
            Dim S As String = " SELECT     GroupUsers.GroupName, GroupLibraryAccess.LibraryName, GroupUsers.UserID "
            S = S + " FROM         GroupUsers INNER JOIN"
            S = S + "                       GroupLibraryAccess ON GroupUsers.GroupName = GroupLibraryAccess.GroupName"
            S = S + " where GroupUsers.groupName = '" + GroupName + "'"
            S = S + " and GroupUsers.UserID = '" + UserID + "'"
            S = S + " group by GroupUsers.GroupName, GroupLibraryAccess.LibraryName, GroupUsers.UserID "

            Dim LibraryName As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    LibraryName = RSData.GetValue(1).ToString

                    S = "delete from libraryusers where libraryname = '" + LibraryName + "' and UserID = '" + UserID + "'"
                    SqlList.Add(S)

                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing

            For i As Integer = 0 To SqlList.Count - 1
                S = SqlList.Item(i).ToString
                Dim BB As Boolean = Me.ExecuteSqlNewConn(S, False)
            Next

            SqlList.Clear()
            SqlList = Nothing
            GC.Collect()

            Return B
        Catch ex As Exception
            Me.xTrace(CInt(23.456), "getSourceGuidByFqn", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : RemoveGroupUser : 5704 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : RemoveGroupUser : 5697 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : RemoveGroupUser : 5716 : ", ex)
            Return False
        End Try
    End Function

    ''' <summary>
    ''' Gets the name of the group owner unique identifier by group.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <returns>System.String.</returns>
    Function getGroupOwnerGuidByGroupName(ByVal GroupName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If InStr(GroupName, "''") > 0 Then
        Else
            GroupName = UTIL.RemoveSingleQuotes(GroupName)
        End If

        Try
            Dim S As String = "Select [GroupOwnerUserID] ,[GroupName] FROM  [UserGroup] where GroupName = '" + GroupName + "'"
            Dim SourceGuid As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    SourceGuid = RSData.GetValue(0).ToString
                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing

            Return SourceGuid
        Catch ex As Exception
            Me.xTrace(23456, "getSourceGuidByFqn", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getGroupOwnerGuidByGroupName : 5718 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getGroupOwnerGuidByGroupName : 5712 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getGroupOwnerGuidByGroupName : 5732 : ", ex)
            Return Nothing
        End Try

    End Function

    ''' <summary>
    ''' Gets the user email addr by user identifier.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function getUserEmailAddrByUserID(ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select EmailAddress FROM Users where UserID = '" + UserID + "'"
            Dim SourceGuid As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    SourceGuid = RSData.GetValue(0).ToString
                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            Return SourceGuid
        Catch ex As Exception
            Me.xTrace(23, "getUserEmailAddrByUserID", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserEmailAddrByUserID : 5732 : ", ex)
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Gets the user name by email addr.
    ''' </summary>
    ''' <param name="EmailAddress">The email address.</param>
    ''' <returns>System.String.</returns>
    Function getUserNameByEmailAddr(ByVal EmailAddress As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select UserName FROM email where EmailAddress = '" + EmailAddress + "'"
            Dim SourceGuid As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    SourceGuid = RSData.GetValue(0).ToString
                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing

            Return SourceGuid
        Catch ex As Exception
            Me.xTrace(2334, "getUserNameByEmailAddr", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserNameByEmailAddr : 5746 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserNameByEmailAddr : 5742 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getUserNameByEmailAddr : 5764 : ", ex)
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Loads the reassign history.
    ''' </summary>
    ''' <param name="OldUid">The old uid.</param>
    ''' <param name="NewUid">Creates new uid.</param>
    ''' <param name="UserArray">The user array.</param>
    Sub loadReassignHistory(ByVal OldUid As String, ByVal NewUid As String, ByRef UserArray As ArrayList)
        UserArray.Clear()
        Dim S As String = "  SELECT [UserID]"
        S = S + " ,[UserName]"
        S = S + " ,[EmailAddress]"
        S = S + " ,[UserPassword]"
        S = S + " ,[Admin]"
        S = S + " ,[isActive]"
        S = S + " ,[UserLoginID]"
        S = S + " from users WHERE (Users.UserID = '" + OldUid + "') "
        Dim SourceGuid As String = ""
        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        Dim II As Integer = 0
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                Dim UserID As String = RSData.GetValue(0).ToString
                Dim UserName As String = RSData.GetValue(1).ToString
                Dim EmailAddress As String = RSData.GetValue(2).ToString
                Dim UserPassword As String = RSData.GetValue(3).ToString
                Dim Admin As String = RSData.GetValue(4).ToString
                Dim isActive As String = RSData.GetValue(5).ToString
                Dim UserLoginID As String = RSData.GetValue(6).ToString

                UserArray.Add(UserID)
                UserArray.Add(UserName)
                UserArray.Add(EmailAddress)
                UserArray.Add(UserPassword)
                UserArray.Add(Admin)
                UserArray.Add(isActive)
                UserArray.Add(UserLoginID)

                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        S = "  SELECT [UserID]"
        S = S + " ,[UserName]"
        S = S + " ,[EmailAddress]"
        S = S + " ,[UserPassword]"
        S = S + " ,[Admin]"
        S = S + " ,[isActive]"
        S = S + " ,[UserLoginID]"
        S = S + " from users WHERE Users.UserID = '" + NewUid + "' "
        SourceGuid = ""

        CS = getRepoConnStr() : CONN = New SqlConnection(CS) : CONN.Open() : command = New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        II = 0
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                Dim UserID As String = RSData.GetValue(0).ToString
                Dim UserName As String = RSData.GetValue(1).ToString
                Dim EmailAddress As String = RSData.GetValue(2).ToString
                Dim UserPassword As String = RSData.GetValue(3).ToString
                Dim Admin As String = RSData.GetValue(4).ToString
                Dim isActive As String = RSData.GetValue(5).ToString
                Dim UserLoginID As String = RSData.GetValue(6).ToString

                UserArray.Add(UserID)
                UserArray.Add(UserName)
                UserArray.Add(EmailAddress)
                UserArray.Add(UserPassword)
                UserArray.Add(Admin)
                UserArray.Add(isActive)
                UserArray.Add(UserLoginID)

                Application.DoEvents()
            Loop
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' xes the get XRT.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function xGetXrt() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim iMax As Integer = GetMaxLicenseID()
        Try
            Dim S As String = "Select Agreement FROM  License where LicenseID = " + iMax.ToString
            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    tCnt = RSData.GetValue(0).ToString
                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing

            Return tCnt
        Catch ex As Exception
            Me.xTrace(2334, "getUserNameByEmailAddr", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : xGetXrt : 5829 : ", ex)
            Return ""
        End Try
    End Function

    'Function GetCurrMachineCnt() As Integer
    '    Try
    '        Dim S As String  = "Select count(*) FROM [Machine]"
    '        Dim tCnt  = ""
    '        Dim RSData As SqlDataReader = Nothing
    '        Dim CS  = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsdata= command.ExecuteReader()
    '        If RSData.HasRows Then
    '            RSData.Read()
    '            tCnt  = RSData.GetValue(0).ToString
    '            Application.DoEvents()
    '        Else
    '            tCnt = 0
    '        End If

    ' RSData.Close() RSData = Nothing

    '        Return cint(tCnt )
    '    Catch ex As Exception
    '        Me.xTrace(2334, "getUserNameByEmailAddr" , ex.Message.ToString)
    '        Return -1
    '    End Try
    'End Function

    'SELECT max([LicenseID]) FROM  [License]
    ''' <summary>
    ''' Gets the maximum license identifier.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function GetMaxLicenseID() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tCnt As String = ""
        Try
            Dim S As String = "Select max([LicenseID]) FROM [License]"

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tCnt = "0"
            End If

            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            Me.xTrace(2334, "getUserNameByEmailAddr", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetMaxLicenseID : 5844 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetMaxLicenseID : 5842 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetMaxLicenseID : 5866 : ", ex)
            tCnt = "-1"
        End Try
        Return CInt(CInt(tCnt))
    End Function

    ''' <summary>
    ''' Licenses the exists.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function LicenseExists() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = False
        Dim CS As String = ""
        CS = getRepoConnStr()

        Try

            Me.CloseConn()
            CkConn()
            Dim s As String = "Select count(*) from License "
            Dim Cnt As Integer
            Dim rsData As SqlDataReader = Nothing

            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(s, CONN)
            rsData = command.ExecuteReader()

            rsData.Read()
            Cnt = rsData.GetInt32(0)
            If Cnt > 0 Then
                b = True
            Else
                b = False
            End If
            rsData.Close()
            rsData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: LicenseExists - ", ex)
            Dim Msg As String = "License validation error:" + Environment.NewLine
            Msg += "A license could not be found for the product." + Environment.NewLine
            Msg += ex.Message + Environment.NewLine
            Msg += CS + Environment.NewLine + Environment.NewLine
            Msg += "This message is on the clipboard if needed for debug."
            MessageBox.Show(Msg)
            Clipboard.Clear()
            Clipboard.SetText(Msg)
            b = False
        End Try

        Return b
    End Function

    ''' <summary>
    ''' Gets the license last version.
    ''' </summary>
    Sub getLicenseLastVersion()

    End Sub

    ''' <summary>
    ''' Gets the XRT.
    ''' </summary>
    ''' <param name="CustomerName">Name of the customer.</param>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="dDebug">The d debug.</param>
    ''' <returns>System.String.</returns>
    Function GetXrt(CustomerName As String, CustomerID As String, Optional dDebug As Integer = 0) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If gLicense.Length > 0 Then
            Return gLicense
        End If

        Dim S As String = "Select [License] from [dbo].[License] where CustomerID = '" + CustomerID + "' "
        Try

            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getLicenseConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    S = RSData.GetValue(0).ToString
                    Application.DoEvents()
                Loop
            End If
            RSData.Close()
            RSData = Nothing
            gLicense = S

            Return S
        Catch ex As Exception
            Me.xTrace(2334, "GetXrt", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetXrt : 5874 : ", ex)
            S = ""
            Return S
        End Try
    End Function

    ''' <summary>
    ''' Gets the curr machine count.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function GetCurrMachineCnt() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select count(*) FROM [Machine]"
            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tCnt = CStr(0)
            End If

            RSData.Close()
            RSData = Nothing

            Return CInt(CInt(tCnt))
        Catch ex As Exception
            Me.xTrace(2334, "GetCurrMachineCnt", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetCurrMachineCnt : 5889 : ", ex)
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' Gets the NBR users.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function GetNbrUsers() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select count(*) from Users "
            Dim tCnt As Integer
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetInt32(0)
                tCnt = tCnt - 1
                Application.DoEvents()
            Else
                tCnt = 0
            End If

            RSData.Close()
            RSData = Nothing

            Return tCnt
        Catch ex As Exception
            Me.xTrace(2334, "GetNbrMachine", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetNbrMachine : 5904 : ", ex)
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' Gets the NBR machine.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function GetNbrMachine() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select count(*) from MachineRegistered "
            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tCnt = CStr(0)
            End If

            RSData.Close()
            RSData = Nothing

            Return CInt(tCnt)
        Catch ex As Exception
            Me.xTrace(2334, "GetNbrMachine", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetNbrMachine : 5904 : ", ex)
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' Gets the NBR machine.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <returns>System.Int32.</returns>
    Function GetNbrMachine(ByVal MachineName As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select COUNT(Distinct MachineName) from machine "
            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tCnt = CStr(0)
            End If

            RSData.Close()
            RSData = Nothing

            Return CInt(tCnt)
        Catch ex As Exception
            Me.xTrace(2334, "GetNbrMachine", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetNbrMachine : 5904 : ", ex)
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' Gets the curr user count.
    ''' </summary>
    ''' <returns>System.Int32.</returns>
    Function GetCurrUserCnt() As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select count(*) FROM [Users]"
            Dim tCnt As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tCnt = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tCnt = CStr(0)
            End If

            RSData.Close()
            RSData = Nothing

            Return CInt(tCnt)
        Catch ex As Exception
            Me.xTrace(2334, "GetCurrUserCnt", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetCurrUserCnt : 5904 : ", ex)
            Return -1
        End Try
    End Function

    ''' <summary>
    ''' Saves the license cut and paste.
    ''' </summary>
    ''' <param name="LS">The ls.</param>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function saveLicenseCutAndPaste(ByVal LS As String, ByVal CustomerID As String, ByVal MachineID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from License where CustomerID = '" + CustomerID + "' and MachineID = '" + MachineID + "' "
        Dim iCnt As Integer = iCount(S)
        Dim sLic As String = ""

        If iCnt = 0 Then
            sLic = sLic + "INSERT INTO [License]"
            sLic = sLic + "([Agreement]"
            sLic = sLic + ",[VersionNbr]"
            sLic = sLic + ",[ActivationDate]"
            sLic = sLic + ",[InstallDate]"
            sLic = sLic + ",[CustomerID]"
            sLic = sLic + ",[CustomerName]"
            sLic = sLic + ",[XrtNxr1], MachineID)"
            sLic = sLic + "VALUES "
            sLic = sLic + "('" + LS + "'"
            sLic = sLic + ",1"
            sLic = sLic + ",GETDATE()"
            sLic = sLic + ",GETDATE()"
            sLic = sLic + ",'" + CustomerID + "'"
            sLic = sLic + ",'XX'"
            sLic = sLic + ",'XX', '" + MachineID + "')"
        Else
            sLic = sLic + " Update [License] "
            sLic = sLic + " set [Agreement] = '" + LS + "' "
            sLic = sLic + " where CustomerID = '" + CustomerID + "' and MachineID = '" + MachineID + "' "
        End If

        Dim B As Boolean = False
        B = ExecuteSqlNewConn(sLic, False)
        If Not B Then
            Clipboard.Clear()
            Clipboard.SetText(sLic)
            MessageBox.Show("The License did not APPLY - check the error log. Error 66.527 loading License Failed.")
        End If

        Return B
    End Function

    ''' <summary>
    ''' Gets the profile desc.
    ''' </summary>
    ''' <param name="ProfileName">Name of the profile.</param>
    ''' <returns>System.String.</returns>
    Function GetProfileDesc(ByVal ProfileName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            Dim S As String = "Select [ProfileDesc] FROM [LoadProfile] where [ProfileName] ='" + ProfileName + "'"
            Dim tVal As String = ""
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tVal = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tVal = ""
            End If

            RSData.Close()
            RSData = Nothing

            Return tVal
        Catch ex As Exception
            Me.xTrace(2334, "GetCurrUserCnt", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetProfileDesc : 5942 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetProfileDesc : 5945 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : GetProfileDesc : 5974 : ", ex)
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Gets the type of the attribute data.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    ''' <returns>System.String.</returns>
    Function getAttributeDataType(ByVal AttributeName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tVal As String = ""
        Dim S As String = "Select AttributeDataType FROM [Attributes] where AttributeName = '" + AttributeName + "'"
        Try
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tVal = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tVal = ""
            End If

            RSData.Close()
            RSData = Nothing

            Return tVal
        Catch ex As Exception
            Me.xTrace(2334, "getAttributeDataType", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getAttributeDataType : 5957 : ", ex)
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Gets the attribute allowed values.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    ''' <returns>System.String.</returns>
    Function getAttributeAllowedValues(ByVal AttributeName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim tVal As String = ""
        Dim S As String = "Select AllowedValues FROM [Attributes] where AttributeName = '" + AttributeName + "'"
        Try
            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                tVal = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tVal = ""
            End If

            RSData.Close()
            RSData = Nothing

            Return tVal
        Catch ex As Exception
            Me.xTrace(2334, "getAttributeDataType", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getAttributeDataType : 5957 : ", ex)
            Return ""
        End Try
    End Function

    ''' <summary>
    ''' Quoteses the required.
    ''' </summary>
    ''' <param name="DataType">Type of the data.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function QuotesRequired(ByVal DataType As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        DataType = UCase(DataType)

        Select Case DataType
            Case "INT"
                Return False
            Case "DATETIME"
                Return True
            Case "DECIMAL"
                Return False
            Case "FLOAT"
                Return False
            Case "VARCHAR"
                Return True
            Case "NVARCHAR"
                Return True
            Case "CHAR"
                Return True
            Case "NCHAR"
                Return True
            Case Else
                B = True
        End Select
        Return B
    End Function

    ''' <summary>
    ''' Gets the length of the data source image.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.Double.</returns>
    Function getDataSourceImageLength(ByVal SourceGuid As String) As Double
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select max(datalength(SourceImage)) from DataSource where SourceGuid = '" + SourceGuid + "'"
        Dim tVal As String = ""
        Dim NewCN As New SqlConnection(getRepoConnStr())
        If NewCN.State = ConnectionState.Closed Then
            NewCN.Open()
        End If
        Try
            Dim RSData As SqlDataReader = Nothing
            RSData = SqlQry(S, NewCN)
            If RSData.HasRows Then
                RSData.Read()
                tVal = RSData.GetValue(0).ToString
                Application.DoEvents()
            Else
                tVal = "0"
            End If

            RSData.Close()
            RSData = Nothing
            NewCN.Close()
            NewCN = Nothing

            Return CInt(tVal)
        Catch ex As Exception
            Me.xTrace(2334, "getDataSourceImageLength", ex.Message.ToString)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getDataSourceImageLength : 5992 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getDataSourceImageLength : 5997 : ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getDataSourceImageLength : 6028 : ", ex)
            Return 0
        End Try
    End Function

    ''' <summary>
    ''' Updates the curr archive stats.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    Sub UpdateCurrArchiveStats(ByVal FQN As String, ByVal SourceTypeCode As String)

        If gCurrentArchiveGuid.Trim.Length = 0 Then gCurrentArchiveGuid = Guid.NewGuid.ToString

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim ARCHHIST As New clsARCHIVEHIST
        Dim ARCHHISTTYPE As New clsARCHIVEHISTCONTENTTYPE

        If SourceTypeCode.Equals("MSG") Then
            If ddebug Then Debug.Print("Processing Folder: " + FQN)
        ElseIf SourceTypeCode.Equals("EML") Then
            If ddebug Then Debug.Print("Processing Folder: " + FQN)
        Else
            FQN = DMA.GetFilePath(FQN)
            FQN = UTIL.RemoveSingleQuotes(FQN)
        End If

        Dim iCnt As Integer = ARCHHIST.cnt_PK110(gCurrentArchiveGuid)
        If iCnt = 0 Then
            ARCHHIST.setUserguid(gCurrUserGuidID)
            ARCHHIST.setArchivedate(Now.ToString)
            ARCHHIST.setArchiveid(gCurrentArchiveGuid)
            ARCHHIST.setNbrfilesarchived(CStr(1))
            Dim BBB As Boolean = ARCHHIST.Insert()
            If Not BBB Then
                If ddebug Then Debug.Print("Error 22.921.3: Failed to update current archive data.")
            Else
                iCnt = ARCHHISTTYPE.cnt_PK111(gCurrentArchiveGuid, FQN, SourceTypeCode)
                If iCnt = 0 Then
                    ARCHHISTTYPE.setArchiveid(gCurrentArchiveGuid)
                    ARCHHISTTYPE.setDirectory(FQN)
                    ARCHHISTTYPE.setFiletype(SourceTypeCode)
                    ARCHHISTTYPE.setNbrfilesarchived(CStr(1))
                    Dim BBBB As Boolean = ARCHHISTTYPE.Insert
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3d: Failed to update current archive data.")
                    End If
                Else
                    Dim SS As String = "UPDATE [ArchiveHistContentType] SET "
                    SS = SS + " NbrFilesArchived = NbrFilesArchived + 1"
                    SS = SS + " WHERE [ArchiveID] = '" + gCurrentArchiveGuid + "'"
                    SS = SS + " and [Directory] = '" + FQN + "'"
                    SS = SS + " and [FileType] = '" + SourceTypeCode + "'"
                    Dim BBBB As Boolean = ExecuteSqlNewConn(SS, False)
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
                    End If
                End If
            End If
        Else
            Dim SS As String = "Update ArchiveHist set NbrFilesArchived = NbrFilesArchived + 1 where ArchiveID = '" + gCurrentArchiveGuid + "'"
            Dim BBB As Boolean = ExecuteSqlNewConn(SS, False)
            If Not BBB Then
                If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
            Else
                iCnt = ARCHHISTTYPE.cnt_PK111(gCurrentArchiveGuid, FQN, SourceTypeCode)
                If iCnt = 0 Then
                    ARCHHISTTYPE.setArchiveid(gCurrentArchiveGuid)
                    ARCHHISTTYPE.setDirectory(FQN)
                    ARCHHISTTYPE.setFiletype(SourceTypeCode)
                    ARCHHISTTYPE.setNbrfilesarchived(CStr(1))
                    Dim BBBB As Boolean = ARCHHISTTYPE.Insert
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3d: Failed to update current archive data.")
                    End If
                Else
                    SS = "UPDATE [ArchiveHistContentType] SET"
                    SS = SS + " NbrFilesArchived = NbrFilesArchived + 1"
                    SS = SS + " WHERE [ArchiveID] = '" + gCurrentArchiveGuid + "'"
                    SS = SS + " and [Directory] = '" + FQN + "'"
                    SS = SS + " and [FileType] = '" + SourceTypeCode + "'"
                    Dim BBBB As Boolean = ExecuteSqlNewConn(SS, False)
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
                    End If
                End If
            End If
        End If
    End Sub

    ''' <summary>
    ''' Updates the curr archive stats.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="ArchiveGuid">The archive unique identifier.</param>
    Sub UpdateCurrArchiveStats(ByVal FQN As String, ByVal SourceTypeCode As String, ByVal ArchiveGuid As String)

        If gCurrentArchiveGuid.Trim.Length = 0 Then gCurrentArchiveGuid = Guid.NewGuid.ToString

        FQN = UTIL.RemoveSingleQuotes(FQN)
        Dim ARCHHIST As New clsARCHIVEHIST
        Dim ARCHHISTTYPE As New clsARCHIVEHISTCONTENTTYPE

        If SourceTypeCode.Equals("MSG") Then
            If ddebug Then Debug.Print("Processing Folder: " + FQN)
        ElseIf SourceTypeCode.Equals("EML") Then
            If ddebug Then Debug.Print("Processing Folder: " + FQN)
        Else
            FQN = DMA.GetFilePath(FQN)
            FQN = UTIL.RemoveSingleQuotes(FQN)
        End If

        Dim iCnt As Integer = ARCHHIST.cnt_PK110(ArchiveGuid)
        If iCnt = 0 Then
            ARCHHIST.setUserguid(gCurrUserGuidID)
            ARCHHIST.setArchivedate(Now.ToString)
            ARCHHIST.setArchiveid(ArchiveGuid)
            ARCHHIST.setNbrfilesarchived(CStr(1))
            Dim BBB As Boolean = ARCHHIST.Insert()
            If Not BBB Then
                If ddebug Then Debug.Print("Error 22.921.3: Failed to update current archive data.")
            Else
                iCnt = ARCHHISTTYPE.cnt_PK111(ArchiveGuid, FQN, SourceTypeCode)
                If iCnt = 0 Then
                    ARCHHISTTYPE.setArchiveid(ArchiveGuid)
                    ARCHHISTTYPE.setDirectory(FQN)
                    ARCHHISTTYPE.setFiletype(SourceTypeCode)
                    ARCHHISTTYPE.setNbrfilesarchived(CStr(1))
                    Dim BBBB As Boolean = ARCHHISTTYPE.Insert
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3d: Failed to update current archive data.")
                    End If
                Else
                    Dim SS As String = "UPDATE [ArchiveHistContentType] SET "
                    SS = SS + " NbrFilesArchived = NbrFilesArchived + 1"
                    SS = SS + " WHERE [ArchiveID] = '" + ArchiveGuid + "'"
                    SS = SS + " and [Directory] = '" + FQN + "'"
                    SS = SS + " and [FileType] = '" + SourceTypeCode + "'"
                    Dim BBBB As Boolean = ExecuteSqlNewConn(SS, False)
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
                    End If
                End If
            End If
        Else
            Dim SS As String = "Update ArchiveHist set NbrFilesArchived = NbrFilesArchived + 1 where ArchiveID = '" + ArchiveGuid + "'"
            Dim BBB As Boolean = ExecuteSqlNewConn(SS, False)
            If Not BBB Then
                If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
            Else
                iCnt = ARCHHISTTYPE.cnt_PK111(ArchiveGuid, FQN, SourceTypeCode)
                If iCnt = 0 Then
                    ARCHHISTTYPE.setArchiveid(ArchiveGuid)
                    ARCHHISTTYPE.setDirectory(FQN)
                    ARCHHISTTYPE.setFiletype(SourceTypeCode)
                    ARCHHISTTYPE.setNbrfilesarchived(CStr(1))
                    Dim BBBB As Boolean = ARCHHISTTYPE.Insert
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3d: Failed to update current archive data.")
                    End If
                Else
                    SS = "UPDATE [ArchiveHistContentType] SET"
                    SS = SS + " NbrFilesArchived = NbrFilesArchived + 1"
                    SS = SS + " WHERE [ArchiveID] = '" + ArchiveGuid + "'"
                    SS = SS + " and [Directory] = '" + FQN + "'"
                    SS = SS + " and [FileType] = '" + SourceTypeCode + "'"
                    Dim BBBB As Boolean = ExecuteSqlNewConn(SS, False)
                    If Not BBBB Then
                        If ddebug Then Debug.Print("Error 22.921.3b: Failed to update current archive data.")
                    End If
                End If
            End If
        End If
    End Sub

    ''' <summary>
    ''' Now, we can get this data... So what, how do we pass it all back?
    ''' </summary>
    ''' <param name="FormName">Name of the form.</param>
    ''' <param name="slFormHelp">The sl form help.</param>
    Sub getFormHelpData(ByVal FormName As String, ByRef slFormHelp As SortedList(Of String, String))

        Try
            slFormHelp.Clear()
            Dim S As String = ""
            S = S + " SELECT [ScreenName]"
            S = S + " ,[HelpText]"
            S = S + " ,[WidgetName]"
            S = S + " FROM [HelpText]"
            S = S + " where ScreenName = '" + FormName + "' "
            S = S + " and [DisplayHelpText] <> 0 "

            Dim b As Boolean = True
            Dim i As Integer = 0
            Dim id As Integer = -1
            Dim II As Integer = 0
            Dim table_name As String = ""
            Dim column_name As String = ""
            Dim data_type As String = ""
            Dim character_maximum_length As String = ""

            Dim ScreenName As String = ""
            Dim HelpText As String = ""
            Dim WidgetName As String = ""
            Dim tKey As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    ScreenName = RSData.GetValue(0).ToString
                    HelpText = RSData.GetValue(1).ToString
                    WidgetName = RSData.GetValue(2).ToString
                    tKey = ScreenName + "," + WidgetName
                    b = slFormHelp.ContainsKey(tKey)
                    If b = False Then
                        slFormHelp.Add(tKey, HelpText)
                    End If
                Loop
            Else
                id = -1
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getFormHelpData : 6102 : ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the form tooltips.
    ''' </summary>
    ''' <param name="frm">The FRM.</param>
    ''' <param name="TT">The tt.</param>
    ''' <param name="setActive">if set to <c>true</c> [set active].</param>
    Sub getFormTooltips(ByRef frm As Form, ByRef TT As ToolTip, ByVal setActive As Boolean)

        Dim HELP As New clsHELPTEXT
        Dim slFormHelp As New SortedList(Of String, String)

        Dim FormName As String = frm.Name
        Dim WidgetName As String = ""
        Dim loControl As Control

        Dim lsTmp As String = ""
        Dim A As New ArrayList
        Dim SS As String = ""
        Dim ctlText As String = ""
        Dim ControlType As String = ""
        Dim HelpText As String = ""

        getFormHelpData(FormName, slFormHelp)

        For Each loControl In frm.Controls
            ctlText = loControl.Text
            WidgetName = loControl.Name
            Dim tKey As String = FormName + "," + WidgetName
            If slFormHelp.ContainsKey(tKey) Then
                '** Great - now what ??
                Dim iDx As Integer = slFormHelp.IndexOfKey(tKey)
                HelpText = slFormHelp.Values(iDx)
                TT.SetToolTip(loControl, HelpText)
                TT.Active = setActive
            End If
        Next loControl

    End Sub

    ''' <summary>
    ''' Marks the image copy for deletion.
    ''' </summary>
    ''' <param name="fqn">The FQN.</param>
    Public Sub MarkImageCopyForDeletion(ByVal fqn As String)
        fqn = UTIL.RemoveSingleQuotes(fqn)
        Dim B As Boolean = False
        Dim FTD As New clsFILESTODELETE
        Dim mName As String = DMA.GetCurrMachineName()

        FTD.setFqn(fqn)
        FTD.setMachinename(mName)
        FTD.setPendingdelete("Y")
        FTD.setUserid(gCurrUserGuidID)
        Dim iCnt As Integer = FTD.cnt_PK_FileToDelete(fqn, mName, gCurrUserGuidID)
        If iCnt > 0 Then
            Dim WC As String = FTD.wc_PK_FileToDelete(fqn, mName, gCurrUserGuidID)
            B = FTD.Update(WC)
        Else
            B = FTD.Insert
        End If
        If Not B Then
            If ddebug Then Debug.Print("Error on OCR 12.99.1")
            ' If gRunUnattended = False Then MessageBox.Show("Error on OCR 12.99.1")
            LOG.WriteToArchiveLog("Error on OCR 12.99.1 - " + fqn)
        End If
        FTD = Nothing
        GC.Collect()
    End Sub

    ''' <summary>
    ''' Deletes the marked image copy files.
    ''' </summary>
    Public Sub DeleteMarkedImageCopyFiles()

        Dim FileToDelete As New ArrayList
        Dim rsData As SqlDataReader = Nothing
        Dim mName As String = DMA.GetCurrMachineName()
        Dim FQN As String = ""
        Dim S As String = ""

        '** S = S + " SELECT [UserID],[MachineName],[FQN],[PendingDelete]"
        S = S + " SELECT [FQN] "
        S = S + " FROM [FilesToDelete] "
        S = S + " where MachineName = '" + mName + "'"

        Try
            Dim b As Boolean = True
            Dim i As Integer = 0
            Dim FileType As String = ""
            Dim II As Integer = 0
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    Application.DoEvents()
                    b = True
                    FQN = rsData.GetValue(0).ToString
                    FileToDelete.Add(FQN)
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteMarkedImageCopyFiles : 6168 : ", ex)
        End Try

        If Not rsData Is Nothing Then
            rsData.Close()
            rsData = Nothing
        End If

        Try
            For i As Integer = 0 To FileToDelete.Count - 1
                Application.DoEvents()
                FQN = FileToDelete(i).ToString
                Dim F As New FileInfo(FQN)
                If F.Exists Then
                    Try
                        F.Delete()
                    Catch ex As Exception
                        LOG.WriteToArchiveLog("NOTICE: DeleteMarkedImageCopyFiles : 6180.01 : ", ex)
                    End Try
                End If

                F = Nothing
                GC.Collect()
            Next
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : DeleteMarkedImageCopyFiles : 6180 : ", ex)
        End Try

        GC.Collect()

        S = "Delete from FilesToDelete where MachineName = '" + mName + "'"
        Dim BB = Me.ExecuteSqlNewConn(S, False)
        If Not BB Then
            If ddebug Then Debug.Print("Error Here")
        End If

    End Sub

    ''' <summary>
    ''' Sets the ocr attributes to pass.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub SetOcrAttributesToPass(ByVal SourceGuid As String)
        Dim S As String = "update DataSource set OcrPerformed = 'Y', isGraphic = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Sets the ocr attributes to fail.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub SetOcrAttributesToFail(ByVal SourceGuid As String)
        Dim S As String = "update DataSource set OcrPerformed = 'F', isGraphic = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Sets the ocr attributes to not performed.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub SetOcrAttributesToNotPerformed(ByVal SourceGuid As String)
        Dim S As String = "update DataSource set OcrPerformed = 'N', isGraphic = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    'GraphicContainsText
    ''' <summary>
    ''' Sets the image hidden text.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="ImageHiddenText">The image hidden text.</param>
    Sub SetImageHiddenText(ByVal SourceGuid As String, ByVal ImageHiddenText As String)

        ImageHiddenText = UTIL.RemoveSingleQuotes(ImageHiddenText)

        Dim S As String = "update DataSource set GraphicContainsText = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If

        S = "update DataSource set ImageHiddenText = '" + ImageHiddenText + "' where SourceGuid = '" + SourceGuid + "'"
        b = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Appends the image hidden text.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="ImageHiddenText">The image hidden text.</param>
    Sub AppendImageHiddenText(ByVal SourceGuid As String, ByVal ImageHiddenText As String)

        ImageHiddenText = UTIL.RemoveSingleQuotes(ImageHiddenText)

        Dim S As String = "update DataSource set GraphicContainsText = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If

        S = "update DataSource set ImageHiddenText = ImageHiddenText + '|' + '" + ImageHiddenText + "' where SourceGuid = '" + SourceGuid + "'"
        b = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Appends the ocr text.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="OcrText">The ocr text.</param>
    Sub AppendOcrText(ByVal SourceGuid As String, ByVal OcrText As String)
        Dim DTE As Date = Now

        LOG.WriteToTimerLog("clsDatabaseARCH", "AppendOcrText", "START")

        Dim ExistingOcrText As String = getOcrText(SourceGuid, "DOC", "")

        ExistingOcrText = ExistingOcrText + " " + OcrText

        OcrText = UTIL.RemoveSingleQuotes(ExistingOcrText)

        Dim S As String = "update DataSource set GraphicContainsText = 'Y' where SourceGuid = '" + SourceGuid + "'"
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If

        BlankOutSingleQuotes(OcrText)
        S = "update DataSource set OcrText = '" + OcrText + "' where SourceGuid = '" + SourceGuid + "'"
        b = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR text")
        End If
        LOG.WriteToTimerLog("clsDatabaseARCH", "AppendOcrText", "END", DTE)
    End Sub

    ''' <summary>
    ''' Appends the email ocr text.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="OcrText">The ocr text.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    Sub AppendEmailOcrText(ByVal EmailGuid As String, ByVal OcrText As String, ByVal AttachmentName As String)

        AttachmentName = AttachmentName.Replace("'", "''")

        Dim ExistingOcrText As String = getOcrText(EmailGuid, "EMAIL", AttachmentName)

        ExistingOcrText = ExistingOcrText + " " + OcrText

        OcrText = UTIL.RemoveSingleQuotes(ExistingOcrText)
        BlankOutSingleQuotes(OcrText)

        Dim S As String = "update EmailAttachment set OcrText = '" + OcrText + "' where EmailGuid = '" + EmailGuid + "' and AttachmentName = '" + AttachmentName + "' "
        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Blanks the out single quotes.
    ''' </summary>
    ''' <param name="sText">The s text.</param>
    Public Sub BlankOutSingleQuotes(ByRef sText As String)
        For i As Integer = 1 To sText.Length
            Dim CH As String = Mid(sText, i, 1)
            If CH.Equals("'") Then
                Mid(sText, i, 1) = "`"
            End If
        Next
    End Sub

    ''' <summary>
    ''' Sets the email ocr text.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="OcrText">The ocr text.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    Sub SetEmailOcrText(ByVal EmailGuid As String, ByVal OcrText As String, ByVal AttachmentName As String)
        AttachmentName = AttachmentName.Replace("'", "''")
        Try
            UTIL.CleanText(OcrText)
            OcrText = UTIL.ReplaceSingleQuotes(OcrText)
            Me.BlankOutSingleQuotes(OcrText)

            Dim S As String = "update EmailAttachment set OcrText = '" + OcrText.Trim + "' where EmailGuid = '" + EmailGuid + "' and AttachmentName = '" + AttachmentName + "'"
            Dim b As Boolean = ExecuteSqlNewConn(S, False)
            If Not b Then
                LOG.WriteToArchiveLog("ERROR: SetEmailOcrText 100 Failed to set Email OCR Attributes")
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: SetEmailOcrText 200 Failed to set Email OCR Attributes")
        End Try

    End Sub

    ''' <summary>
    ''' Concats the email body.
    ''' </summary>
    ''' <param name="BodyText">The body text.</param>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    Sub concatEmailBody(ByVal BodyText As String, ByVal EmailGuid As String)

        Try

            BodyText = BodyText + GetEmailBody(EmailGuid)

            UTIL.CleanText(BodyText)

            BodyText = BodyText.Replace("'", "`")

            Dim S As String = "update Email " + Environment.NewLine
            S += "set Body = '" + BodyText + "'" + Environment.NewLine
            S += " where EmailGuid = '" + EmailGuid + "'"
            Dim b As Boolean = ExecuteSqlNewConn(90107, S)

            If Not b Then
                LOG.WriteToArchiveLog("ERROR: concatEmailBody 100 Failed to set Email body")
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: concatEmailBody 200 Failed to set Email body")
        End Try

    End Sub

    ''' <summary>
    ''' Updates the attachment counts.
    ''' </summary>
    Sub UpdateAttachmentCounts()
        Dim S As String = "update Email "
        S = S + " set NbrAttachments = (select count(*) from EmailAttachment where Email.EmailGuid = EmailAttachment.EmailGuid)"
        'S = S + " WHERE NbrAttachments Is NULL "
        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("NOTICE: Failed to update the Attachment counts for Emails." + Environment.NewLine + S)
        End If
    End Sub

    ''' <summary>
    ''' Users the parm update.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ParmVal">The parm value.</param>
    Sub UserParmUpdate(ByVal ParmName As String, ByVal UserID As String, ByVal ParmVal As String)
        Dim iCnt As Integer = UserParmExists(ParmName, UserID)
        If iCnt = 0 Then
            Return
        End If

        ParmName = UTIL.RemoveSingleQuotes(ParmName)
        ParmVal = UTIL.RemoveSingleQuotes(ParmVal)
        'ParmName = UTIL.RemoveSingleQuotes(ParmName)

        Dim S As String = "UPDATE [UserCurrParm]"
        S = S + " SET ParmVal = '" + ParmVal + "'"
        S = S + " where UserID = '" + UserID + "'"
        S = S + " and ParmName = '" + ParmName + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            MessageBox.Show("UserParmUpdate failed.")
        End If
    End Sub

    ''' <summary>
    ''' Users the parm delete.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    Sub UserParmDelete(ByVal ParmName As String, ByVal UserID As String)
        Dim iCnt As Integer = UserParmExists(ParmName, UserID)
        If iCnt = 0 Then
            Return
        End If

        ParmName = UTIL.RemoveSingleQuotes(ParmName)
        'ParmVal = UTIL.RemoveSingleQuotes(ParmVal)
        'ParmName = UTIL.RemoveSingleQuotes(ParmName)

        Dim S As String = "delete from [UserCurrParm]"
        S = S + " where UserID = '" + UserID + "'"
        S = S + " and ParmName = '" + ParmName + "'"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            MessageBox.Show("UserParmDelete Failed.")
        End If
    End Sub

    ''' <summary>
    ''' Gets the active email folders.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>ArrayList.</returns>
    Function GetActiveEmailFolders(ByVal UserID As String) As ArrayList
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim A As New ArrayList
        Dim S As String = "Select distinct foldername from EmailArchParms where UserID = '" + UserID + "'"
        Dim RSData As SqlDataReader = Nothing
        Dim foldername As String = ""

        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    foldername = RSData.GetValue(0).ToString
                    If Not A.Contains(foldername) Then
                        A.Add(foldername)
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1a - ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1b - " + ex.StackTrace.ToString)
        End Try

        RSData.Close()
        RSData = Nothing
        Return A
    End Function

    ''' <summary>
    ''' Validates the curr user pw.
    ''' </summary>
    ''' <param name="EncPW">The enc pw.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ValidateCurrUserPW(ByVal EncPW As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from Users where UserID = '" + gCurrUserGuidID + "' and UserPassword = '" + EncPW + "' "
        Dim RSData As SqlDataReader = Nothing
        Dim foldername As String = ""
        Dim B As Boolean = False

        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim i As Integer = RSData.GetInt32(0)
                If i = 1 Then
                    B = True
                Else
                    B = False
                End If
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1a - ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1b - " + ex.StackTrace.ToString)
        End Try

        RSData.Close()
        RSData = Nothing
        GC.Collect()

        Return B
    End Function

    ''' <summary>
    ''' Gets the email retention code.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetEmailRetentionCode(ByVal FolderName As String, ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FolderName = UTIL.RemoveSingleQuotes(FolderName)

        Dim S As String = ""
        S = S + "Select RetentionCode from EmailFolder "
        S = S + "where FolderName = '" + FolderName + "' "
        S = S + "and UserID = '" + UserID + "'"

        Dim RSData As SqlDataReader = Nothing
        Dim rCode As String = ""
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    rCode = RSData.GetValue(0).ToString
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1a - ", ex)
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetActiveEmailFolders 300.23.1b - " + ex.StackTrace.ToString)
        End Try

        RSData.Close()
        RSData = Nothing
        Return rCode
    End Function

    ''' <summary>
    ''' Users the parm insert.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ParmVal">The parm value.</param>
    Sub UserParmInsert(ByVal ParmName As String, ByVal UserID As String, ByVal ParmVal As String)

        Dim iCnt As Integer = UserParmExists(ParmName, UserID)
        If iCnt > 0 Then
            Return
        End If

        ParmVal = UTIL.RemoveSingleQuotes(ParmVal)

        Dim S As String = "INSERT INTO [UserCurrParm]"
        S = S + " ([UserID]"
        S = S + " ,[ParmName]"
        S = S + " ,[ParmVal])"
        S = S + " VALUES "
        S = S + " ('" + UserID + "',"
        S = S + " '" + ParmName + "',"
        S = S + "'" + ParmVal + "')"

        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            MessageBox.Show("Failed UserParmInsert " + S)
        End If
    End Sub

    ''' <summary>
    ''' Users the parm insert update.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ParmVal">The parm value.</param>
    Sub UserParmInsertUpdate(ByVal ParmName As String, ByVal UserID As String, ByVal ParmVal As String)

        Dim iCnt As Integer = UserParmExists(ParmName, UserID)
        If iCnt > 0 Then
            UserParmUpdate(ParmName, UserID, ParmVal)
            Return
        End If
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ParmVal = UTIL.RemoveSingleQuotes(ParmVal)

        Dim S As String = "INSERT INTO [UserCurrParm]"
        S = S + " ([UserID]"
        S = S + " ,[ParmName]"
        S = S + " ,[ParmVal])"
        S = S + " VALUES "
        S = S + " ('" + UserID + "',"
        S = S + " '" + ParmName + "',"
        S = S + "'" + ParmVal + "')"

        Dim b As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not b Then
            MessageBox.Show("Failed UserParmInsert " + S)
        End If
    End Sub

    ''' <summary>
    ''' is the select count.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.Int32.</returns>
    Function iSelectCount(ByVal S As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Users the parm exists.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function UserParmExists(ByVal ParmName As String, ByVal UserID As String) As Integer
        Dim S As String = ""
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ParmName = UTIL.RemoveSingleQuotes(ParmName)
        'ParmVal = UTIL.RemoveSingleQuotes(ParmVal)
        'ParmName = UTIL.RemoveSingleQuotes(ParmName)

        S = S + " SELECT count(*)"
        S = S + " FROM [UserCurrParm]"
        S = S + " where UserID = '" + UserID + "'"
        S = S + " and ParmName = '" + ParmName + "'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Users the parm retrive.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function UserParmRetrive(ByVal ParmName As String, ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim iCnt As Integer = UserParmExists(ParmName, UserID)
        If iCnt = 0 Then
            Return ""
        End If

        ParmName = UTIL.RemoveSingleQuotes(ParmName)
        'ParmVal = UTIL.RemoveSingleQuotes(ParmVal)
        'ParmName = UTIL.RemoveSingleQuotes(ParmName)

        S = S + " SELECT [ParmVal]"
        S = S + " FROM [UserCurrParm]"
        S = S + " where UserID = '" + UserID + "'"
        S = S + " and ParmName = '" + ParmName + "'"

        CloseConn()
        CkConn()

        Dim sVal As String = ""
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            RSData.Read()
            Try
                If Not RSData.IsDBNull(0) Then
                    sVal = RSData.GetString(0)
                Else
                    sVal = ""
                End If
            Catch ex As Exception
                Me.xTrace(27000, "UserParmRetrive", ex.Message.ToString)
                sVal = ""
                LOG.WriteToArchiveLog("clsDatabaseARCH : UserParmRetrive : 6331 : ", ex)
            End Try
            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return sVal
    End Function

    ''' <summary>
    ''' Gets the help connection string.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getHelpConnStr() As String
        Dim bUseConfig As Boolean = True
        Dim HelpConnStr As String = ""
        HelpConnStr = System.Configuration.ConfigurationManager.AppSettings("HELP.DBARCH")
        Return HelpConnStr
    End Function

    ''' <summary>
    ''' Loads the user search history.
    ''' </summary>
    ''' <param name="MaxNbrSearches">The maximum NBR searches.</param>
    ''' <param name="Uid">The uid.</param>
    ''' <param name="Screen">The screen.</param>
    ''' <param name="SearchHistoryArrayList">The search history array list.</param>
    ''' <param name="NbrReturned">The NBR returned.</param>
    Sub LoadUserSearchHistory(ByVal MaxNbrSearches As Integer, ByVal Uid As String, ByVal Screen As String, ByRef SearchHistoryArrayList As ArrayList, ByRef NbrReturned As Integer)
        Try
            NbrReturned = 0
            SearchHistoryArrayList.Clear()
            Dim EntryID As Integer = -1
            Dim QryParms As String = ""
            Dim S As String = ""
            S = S + " SELECT top " + MaxNbrSearches.ToString + " [EntryID], QryParms "
            S = S + " FROM [SearhParmsHistory] "
            S = S + " where [UserID] = '" + Uid + "' "
            S = S + " and Screen = '" + Screen + "'"
            S = S + " order by [EntryID] DESC "
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    NbrReturned += 1
                    EntryID = RSData.GetInt32(0)
                    QryParms = RSData.GetValue(1).ToString
                    SearchHistoryArrayList.Add(QryParms)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("NOTICE: clsDatabaseARCH:LoadUserSearchHistory - Failed to load search history.")
        End Try
    End Sub

    ''' <summary>
    ''' Limits to existing recs.
    ''' </summary>
    ''' <param name="DGV">The DGV.</param>
    ''' <param name="UIDCellName">Name of the uid cell.</param>
    ''' <param name="GuidCellName">Name of the unique identifier cell.</param>
    ''' <param name="PB">The pb.</param>
    ''' <param name="DeleteAll">if set to <c>true</c> [delete all].</param>
    Sub LimitToExistingRecs(ByVal DGV As DataGridView, ByVal UIDCellName As String, ByVal GuidCellName As String, ByRef PB As ProgressBar, ByVal DeleteAll As Boolean)
        Dim ASG As New clsACTIVESEARCHGUIDS

        Dim DR As New DataGridViewRow
        If DeleteAll = True Then
            Dim S As String = "delete FROM ActiveSearchGuids where  UserID = '" + gCurrUserGuidID + "'"
            Dim B As Boolean = ExecuteSqlNewConn(S, False)
        End If

        Dim iRec As Integer = 0
        PB.Value = 0
        PB.Maximum = DGV.Rows.Count + 1
        Dim iCnt As Integer = 0
        For Each DR In DGV.Rows
            Try
                iCnt += 1
                PB.Value = iCnt
                PB.Refresh()
                Application.DoEvents()
                Dim TgtGuid As String = DR.Cells(GuidCellName).Value.ToString
                Dim TgtUserID As String = DR.Cells(UIDCellName).Value.ToString
                ASG.setDocguid(TgtGuid)
                ASG.setUserid(TgtUserID)
                Dim BB As Boolean = ASG.Insert()
                If BB Then
                    If ddebug Then LOG.WriteToTraceLog("clsDatabaseARCH:LimitingToExistingRecs SUCCESSFUL")
                Else
                    If ddebug Then LOG.WriteToTraceLog("clsDatabaseARCH:LimitingToExistingRecs FAILED '" + TgtGuid + "'")
                End If
            Catch ex As Exception
                Console.WriteLine(ex.Message)
            End Try
        Next
        PB.Value = 0
        ASG = Nothing
    End Sub

    ''' <summary>
    ''' Limits to existing recs.
    ''' </summary>
    ''' <param name="CurrentGuids">The current guids.</param>
    Sub LimitToExistingRecs(ByVal CurrentGuids As List(Of String))

        Dim ASG As New clsACTIVESEARCHGUIDS
        Dim S As String = "delete FROM ActiveSearchGuids where  UserID = '" + gCurrUserGuidID + "'"
        Dim B As Boolean = ExecuteSqlNewConn(S, False)

        Dim iRec As Integer = 0
        Dim iCnt As Integer = 0
        For iCnt = 0 To CurrentGuids.Count - 1
            Try
                Application.DoEvents()
                Dim TgtGuid As String = CurrentGuids(iCnt)
                Dim TgtUserID As String = gCurrUserGuidID
                ASG.setDocguid(TgtGuid)
                ASG.setUserid(TgtUserID)
                Dim BB As Boolean = ASG.Insert()
                If BB Then
                    If ddebug Then LOG.WriteToTraceLog("clsDatabaseARCH:LimitingToExistingRecs SUCCESSFUL")
                Else
                    If ddebug Then LOG.WriteToTraceLog("clsDatabaseARCH:LimitingToExistingRecs FAILED '" + TgtGuid + "'")
                End If
            Catch ex As Exception
                Console.WriteLine(ex.Message)
            End Try
        Next
        ASG = Nothing
    End Sub

    ''' <summary>
    ''' Gets the default thesaurus.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Public Function getDefaultThesaurus() As String
        'Dim EcmLibConnectionString As String = ""

        Dim DefaultThesaurus As String = ""
        Dim s As String = ""

        CloseConn()
        CkConn()

        Try
            Dim tQuery As String = ""
            s = "Select [SysParmVal] FROM [SystemParms] where [SysParm] = 'Default Thesaurus' "
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                DefaultThesaurus = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            '' xTrace(12335, "clsDataBase:iGetRowCount" + ex.Message)
            'messagebox.show("Error 3932.11: " , ex)
            If ddebug Then Debug.Print("Error 3932.11.10: CountOfThesauri ", ex)
            Console.WriteLine("Error 3932.11.10: getDefaultThesaurus", ex)
            DefaultThesaurus = ""
            LOG.WriteToArchiveLog("clsDB : getDefaultThesaurus : 100 : ", ex)
        End Try
        If Not gConn.State = ConnectionState.Closed Then
            gConn.Close()
        End If
        gConn = Nothing
        GC.Collect()
        Return DefaultThesaurus
    End Function

    ''' <summary>
    ''' Expands the inflection terms.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <returns>System.String.</returns>
    Function ExpandInflectionTerms(ByVal S As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim Msg As String = ""
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim S1 As String = RSData.GetValue(0).ToString
                    Dim S2 As String = RSData.GetValue(1).ToString
                    Msg = Msg + S1 + " : " + S2 + Environment.NewLine
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ExpandInflectionTerms : 100 : ", ex)
        End Try
        Return Msg
    End Function

    'SELECT COUNT(*) FROM [DB_UpdateHist] where [FixID] = 1 and Status = 'applied'
    ''' <summary>
    ''' Cks the database update.
    ''' </summary>
    ''' <param name="FixID">The fix identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function ckDbUpdate(ByVal FixID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select COUNT(*) FROM [DB_UpdateHist] where [FixID] = " + FixID + " and Status = 'applied'"
        Dim ii As Integer = 0
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    ii = RSData.GetInt32(0)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbUpdate : 100 : ", ex)
        End Try
        Return ii
    End Function

    ''' <summary>
    ''' Deletes the email by unique identifier.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    Sub DeleteEmailByGuid(ByVal EmailGuid As String)
        Dim SHIST As New clsSEARCHHISTORY

        Dim S As String = ""
        Dim B As Boolean = True

        S = "delete from Recipients where EmailGuid = '" + EmailGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13 - failed to delete Recipients = '" + EmailGuid + "'")
        Else
            LOG.WriteToArchiveLog("Notice 126.77.13 - Deleted Email Recipients = '" + EmailGuid + "'")
            SHIST.setCalledfrom("clsDatabaseARCH:DeleteEmailByGuid")
            SHIST.setEndtime(Now.ToString)
            SHIST.setReturnedrows("1")
            SHIST.setTypesearch("Delete")
            SHIST.setStarttime(Now.ToString)
            SHIST.setSearchdate(Now.ToString)
            SHIST.setSearchsql(S)
            SHIST.setUserid(gCurrUserGuidID)
            B = SHIST.Insert
            If Not B Then
                Console.WriteLine("Error 1943.244 - Failed to save history of search.")
            End If
        End If

        S = "delete from LibraryItems where SourceGuid = '" + EmailGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13a - failed to delete Library Items = '" + EmailGuid + "'")
        End If

        S = "delete from EmailAttachment where EmailGuid = '" + EmailGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13 - failed to delete EmailAttachment = '" + EmailGuid + "'")
        Else
            LOG.WriteToArchiveLog("Notice 126.77.13 - Deleted Email EmailAttachment = '" + EmailGuid + "'")
            SHIST.setCalledfrom("clsDatabaseARCH:DeleteEmailByGuid")
            SHIST.setEndtime(Now.ToString)
            SHIST.setReturnedrows("1")
            SHIST.setTypesearch("Delete")
            SHIST.setStarttime(Now.ToString)
            SHIST.setSearchdate(Now.ToString)
            SHIST.setSearchsql(S)
            SHIST.setUserid(gCurrUserGuidID)
            B = SHIST.Insert
            If Not B Then
                If gClipBoardActive = True Then Console.WriteLine("Error 1943.244 - Failed to save history of search.")
                LOG.WriteToArchiveLog("Notice 1943.244 - Failed to save history of search = '" + EmailGuid + "'")
            End If
        End If
        S = "delete from Email where EmailGuid = '" + EmailGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13 - failed to delete Email = '" + EmailGuid + "'")
        Else
            LOG.WriteToArchiveLog("Notice 1943.244 -  failed to delete Email = '" + EmailGuid + "'")
            SHIST.setCalledfrom("clsDatabaseARCH:DeleteEmailByGuid")
            SHIST.setEndtime(Now.ToString)
            SHIST.setReturnedrows("1")
            SHIST.setTypesearch("Delete")
            SHIST.setStarttime(Now.ToString)
            SHIST.setSearchdate(Now.ToString)
            SHIST.setSearchsql(S)
            SHIST.setUserid(gCurrUserGuidID)
            B = SHIST.Insert
            If Not B Then
                If gClipBoardActive = True Then Console.WriteLine("Error 1943.244 - Failed to save history of search.")
                LOG.WriteToArchiveLog("Error 1943.244 - Failed to save history of search." + EmailGuid + "'")
            End If
        End If

        SHIST = Nothing
    End Sub

    ''' <summary>
    ''' Deletes the source by unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub DeleteSourceByGuid(ByVal SourceGuid As String)
        Dim S As String = ""
        Dim B As Boolean = True

        S = "delete from SourceAttribute where SourceGuid = '" + SourceGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13 - failed to delete SourceAttribute = '" + SourceGuid + "'")
        End If
        S = "delete from DataSource  where SourceGuid = '" + SourceGuid + "'"
        B = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 126.77.13 - failed to delete DataSource = '" + SourceGuid + "'")
        End If
    End Sub

    ''' <summary>
    ''' Retentions the temporary zeroize.
    ''' </summary>
    Sub RetentionTempZeroize()
        Dim S As String = "DELETE FROM [RetentionTemp] WHERE UserID = '" + gCurrUserGuidID + "'"
        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 772.00.13 - failed to Zeroize RetentionTemp")
        End If
    End Sub

    ''' <summary>
    ''' Retentions the temporary insert.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="TypeContent">Content of the type.</param>
    Sub RetentionTempInsert(ByVal UserID As String, ByVal ContentGuid As String, ByVal TypeContent As String)

        Dim S As String = ""
        S = S + " INSERT INTO [RetentionTemp]"
        S = S + " ([UserID]"
        S = S + " ,[ContentGuid]"
        S = S + " ,[TypeContent])"
        S = S + " VALUES"
        S = S + " ('" + UserID + "'"
        S = S + " ,'" + ContentGuid + "'"
        S = S + " ,'" + TypeContent + "')"
        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("Error 772.00.13 - failed to Zeroize RetentionTemp")
        End If

    End Sub

    ''' <summary>
    ''' Retentions the type of the temporary count.
    ''' </summary>
    ''' <param name="TypeContent">Content of the type.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function RetentionTempCountType(ByVal TypeContent As String, ByVal UserID As String) As Integer

        Dim S As String = ""

        S = S + " SELECT COUNT(*) as iCnt"
        S = S + " FROM [RetentionTemp] "
        S = S + " where [TypeContent] = '" + TypeContent + "' and UserID = '" + UserID + "' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = 0
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Admins the exist.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function adminExist() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        S = S + " SELECT [UserID]"
        S = S + " ,[UserName]"
        S = S + " ,[EmailAddress]"
        S = S + " ,[UserPassword]"
        S = S + " ,[Admin]"
        S = S + " ,[isActive]"
        S = S + " ,[UserLoginID]"
        S = S + " FROM [Users]"
        S = S + " where UserLoginID = 'admin'"
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        Dim b As Boolean = False

        Using Conn
            If Conn.State = ConnectionState.Closed Then
                Conn.Open()
            End If

            Dim command As New SqlCommand(S, Conn)
            Dim RSData As SqlDataReader = Nothing
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
                Return True
            Else
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
                Conn.Close()
                Conn = Nothing
                S = ""
                S = S + "INSERT INTO [Users]"
                S = S + "([UserID]"
                S = S + ",[UserName]"
                S = S + ",[EmailAddress]"
                S = S + ",[UserPassword]"
                S = S + ",[Admin]"
                S = S + ",[isActive]"
                S = S + ",[UserLoginID])"
                S = S + "VALUES( "
                S = S + "'admin'"
                S = S + ",'administrator'"
                S = S + ",'NA'"
                S = S + ",'password'"
                S = S + ",'Y'"
                S = S + ",'Y'"
                S = S + ",'admin')"
                b = Me.ExecuteSqlNewConn(S, False)
                If Not b Then
                    MessageBox.Show("Failed to add the required ADMIN account. Add the account manually to allow login.")
                    Return False
                Else
                    MessageBox.Show("The ADMIN account has been created, you will have to login under ADMIN using the password 'password' to continue." + Environment.NewLine + "You must change the password or security will be compromised.")
                    Return False
                End If
            End If

        End Using
    End Function

    ''' <summary>
    ''' Licenses the version exist.
    ''' </summary>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function LicenseVersionExist(ByVal VersionNbr As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) FROM [License] where VersionNbr = " + VersionNbr
        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        If cnt = 0 Then
            Return False
        Else
            Return True
        End If

    End Function

    ''' <summary>
    ''' Gets the license data current.
    ''' </summary>
    ''' <param name="ExistingVersionNbr">The existing version NBR.</param>
    ''' <param name="ExistingActivationDate">The existing activation date.</param>
    ''' <param name="ExistingInstallDate">The existing install date.</param>
    ''' <param name="ExistingCustomerID">The existing customer identifier.</param>
    ''' <param name="ExistingCustomerName">Name of the existing customer.</param>
    ''' <param name="ExistingLicenseID">The existing license identifier.</param>
    ''' <param name="ExistingXrtNxr1">The existing XRT NXR1.</param>
    ''' <param name="ExistingServerIdentifier">The existing server identifier.</param>
    ''' <param name="ExistingSqlInstanceIdentifier">The existing SQL instance identifier.</param>
    Sub getLicenseDataCurrent(ByRef ExistingVersionNbr As String,
                       ByRef ExistingActivationDate As String,
                       ByRef ExistingInstallDate As String,
                       ByRef ExistingCustomerID As String,
                       ByRef ExistingCustomerName As String,
                       ByRef ExistingLicenseID As String,
                       ByRef ExistingXrtNxr1 As String,
                       ByRef ExistingServerIdentifier As String,
                       ByRef ExistingSqlInstanceIdentifier As String)

        Dim S As String = ""
        S = S + "Select [Agreement] "
        S = S + "      ,[VersionNbr] "
        S = S + "      ,[ActivationDate] "
        S = S + "      ,[InstallDate] "
        S = S + "      ,[CustomerID] "
        S = S + "      ,[CustomerName] "
        S = S + "      ,[LicenseID] "
        S = S + "      ,[XrtNxr1] "
        S = S + "      ,[SqlServerInstanceNameX] "
        S = S + "      ,[SqlServerMachineName] "
        S = S + "  FROM [License] "
        S = S + "  where VersionNbr = (select MAX(versionnbr) from License) "

        CloseConn()
        CkConn()

        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                ExistingVersionNbr = RSData.GetValue(0).ToString
                ExistingActivationDate = RSData.GetValue(0).ToString
                ExistingInstallDate = RSData.GetValue(0).ToString
                ExistingCustomerID = RSData.GetValue(0).ToString
                ExistingCustomerName = RSData.GetValue(0).ToString
                ExistingLicenseID = RSData.GetValue(0).ToString
                ExistingXrtNxr1 = RSData.GetValue(0).ToString
                ExistingServerIdentifier = RSData.GetValue(0).ToString
                ExistingSqlInstanceIdentifier = RSData.GetValue(0).ToString
            End If
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If

    End Sub

    ''' <summary>
    ''' Counts the quick reference items.
    ''' </summary>
    ''' <param name="QuickRefIdNbr">The quick reference identifier NBR.</param>
    ''' <returns>System.Int32.</returns>
    Function CountQuickRefItems(ByVal QuickRefIdNbr As Integer) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from QuickRefItems where QuickRefIdNbr = " + QuickRefIdNbr.ToString
        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If

        Return cnt

    End Function

    ''' <summary>
    ''' Gets the quick reference identifier.
    ''' </summary>
    ''' <param name="QuickRef">The quick reference.</param>
    ''' <returns>System.Int32.</returns>
    Function getQuickRefId(ByVal QuickRef As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select QuickRefIdNbr from QuickRef where QuickRefName = '" + QuickRef + "'"
        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                cnt = RSData.GetInt32(0)
            End If
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If

        Return cnt

    End Function

    ''' <summary>
    ''' Retrieves the search history.
    ''' </summary>
    ''' <param name="SearchHistoryArrayList">The search history array list.</param>
    Sub retrieveSearchHistory(ByVal SearchHistoryArrayList As ArrayList)

        SearchHistoryArrayList.Clear()
        Dim S As String = "Select top 25 * from SearchHistory where UserID = '" + gCurrUserGuidID + "' order by RowID desc "
        Dim ii As Integer = 0
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    ii = RSData.GetInt32(0)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbUpdate : 100 : ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Adds the missing CRC.
    ''' </summary>
    Sub AddMissingCrc()
        'SELECT FQN, SourceGuid FROM DataSource
        Dim S As String = "Select count(*) "
        S = S + " FROM DataSource "
        Dim WC As String = " where DataSource.SourceGuid not in (Select SourceGuid from SourceAttribute where AttributeName = 'CRC')"

        Dim iMax As Integer = iGetRowCount("DataSource", WC)

        S = "Select DataSource.FQN, DataSource.SourceGuid"
        S = S + " FROM DataSource "
        S = S + " where DataSource.SourceGuid not in ("
        S = S + " Select SourceGuid from SourceAttribute where AttributeName = 'CRC')"
        Dim ii As Integer = 0
        Dim FQN As String = ""
        Dim sGuid As String = ""
        ''FrmMDIMain.TSPB1.Maximum = iMax + 2

        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    ii += 1
                    ''FrmMDIMain.TSPB1.Value = ii
                    'If ii Mod 100 = 0 Then
                    '    frmreconMain.SB.Text = ii.ToString
                    '    ''FrmMDIMain.Refresh()
                    'End If
                    Application.DoEvents()
                    FQN = RSData.GetValue(0).ToString
                    sGuid = RSData.GetValue(1).ToString
                    'Dim F As File
                    If File.Exists(FQN) Then
                        Dim HexStr As String = ENC.GenerateSHA512HashFromFile(FQN)
                        InsertSrcAttrib(sGuid, "CRC", HexStr, "CONTENT")
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : ckDbUpdate : 100 : ", ex)
        End Try
        ''FrmMDIMain.TSPB1.Value = 0
    End Sub

    ''' <summary>
    ''' Inserts the source attribute.
    ''' </summary>
    ''' <param name="SGUID">The sguid.</param>
    ''' <param name="aName">a name.</param>
    ''' <param name="aVal">a value.</param>
    ''' <param name="OriginalFileType">Type of the original file.</param>
    Sub InsertSrcAttrib(ByVal SGUID As String, ByVal aName As String, ByVal aVal As String, ByVal OriginalFileType As String)
        Dim SRCATTR As New clsSOURCEATTRIBUTE
        SRCATTR.setSourceguid(SGUID)
        SRCATTR.setAttributename(aName)
        SRCATTR.setAttributevalue(aVal)
        SRCATTR.setDatasourceowneruserid(gCurrUserGuidID)
        SRCATTR.setSourcetypecode(OriginalFileType)
        SRCATTR.Insert()
        SRCATTR = Nothing
    End Sub

    'select count(*) from Attributes where AttributeName = 'XX'
    ''' <summary>
    ''' Attributes the exists.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    Sub AttributeExists(ByVal AttributeName As String)
        'SELECT FQN, SourceGuid FROM DataSource
        Dim S As String = "Select count(*) from Attributes where AttributeName = '" + AttributeName + "'"
        Dim WC As String = " where AttributeName = '" + AttributeName + "'"
        Dim iMax As Integer = iGetRowCount("Attributes", WC)

        If iMax > 0 Then
            Return
        End If

        S = ""
        S = S + " INSERT INTO [Attributes]"
        S = S + " ([AttributeName]"
        S = S + " ,[AttributeDataType]"
        S = S + " ,[AttributeDesc]"
        S = S + " ,[AssoApplication])"
        S = S + " VALUES "
        S = S + " ('" + AttributeName + "'"
        S = S + " ,'NVARCHAR'"
        S = S + " ,'ADDED BY ECM Library'"
        S = S + " ,'???')"

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)
        If Not B Then
            LOG.WriteToArchiveLog("clsDatabaseARCH : AttributeExists : 100 : Failed to add attribute.")
        End If

    End Sub

    ''' <summary>
    ''' Cks the attribute exists.
    ''' </summary>
    ''' <param name="AttributeName">Name of the attribute.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckAttributeExists(ByVal AttributeName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select count(*) from Attributes where AttributeName = '" + AttributeName + "'"
        Dim WC As String = " where AttributeName = '" + AttributeName + "'"
        Dim iMax As Integer = iGetRowCount("Attributes", WC)

        If iMax > 0 Then
            Return True
        Else
            Return False
        End If

    End Function

    ''' <summary>
    ''' Removes the freetext stop words.
    ''' </summary>
    ''' <param name="SearchPhrase">The search phrase.</param>
    Sub RemoveFreetextStopWords(ByRef SearchPhrase As String)

        SearchPhrase = SearchPhrase.Trim
        If SearchPhrase.Trim.Length = 0 Then
            Return
        End If

        Dim AL As New ArrayList
        GetSkipWords(AL)

        For i As Integer = 1 To SearchPhrase.Length
            Dim CH As String = Mid(SearchPhrase, i, 1)
            If CH = Chr(34) Then
                Mid(SearchPhrase, i, 1) = " "
            End If
        Next
        Dim NewPhrase As String = ""
        Dim A As String() = SearchPhrase.Split(CChar(" "))
        For i As Integer = 0 To UBound(A)
            Dim tWord As String = A(i).Trim
            Dim TempWord As String = tWord
            tWord = tWord.ToUpper
            If tWord.Length > 0 Then
                If AL.Contains(tWord) Then
                    A(i) = ""
                Else
                    A(i) = TempWord
                End If
            End If
        Next
        NewPhrase = ""
        For i As Integer = 0 To UBound(A)
            If A(i).Trim.Length > 0 Then
                NewPhrase = NewPhrase + " " + A(i)
            End If
        Next
        SearchPhrase = NewPhrase
    End Sub

    ''' <summary>
    ''' Sets the source global access flags.
    ''' </summary>
    ''' <param name="tgtGuid">The TGT unique identifier.</param>
    ''' <param name="FileType">Type of the file.</param>
    ''' <param name="rbPublic">if set to <c>true</c> [rb public].</param>
    ''' <param name="rbPrivate">if set to <c>true</c> [rb private].</param>
    ''' <param name="rbMstrYes">if set to <c>true</c> [rb MSTR yes].</param>
    ''' <param name="rbMstrNot">if set to <c>true</c> [rb MSTR not].</param>
    ''' <param name="SB">The sb.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SetSourceGlobalAccessFlags(ByVal tgtGuid As String, ByVal FileType As String,
                                   ByVal rbPublic As Boolean,
                                   ByVal rbPrivate As Boolean,
                                   ByVal rbMstrYes As Boolean,
                                   ByVal rbMstrNot As Boolean, ByRef SB As TextBox) As Boolean

        Dim tKey As String = tgtGuid
        Dim Bb As Boolean = True

        If rbPublic Then
            Dim SS As String = ""

            Dim isOwner As Boolean = ValidateContentOwnership(tgtGuid, FileType)
            If isOwner = False Then
                isOwner = ValidateCoOwnerOfContent(tgtGuid, FileType)
                If isOwner = False Then
                    'SB.Text = "You do not own all of this content, so some changes are not allowed."
                    SB.Text = "You do not own all of this content, so some changes are not allowed."
                    Return False
                End If
            End If

            If Not FileType.ToUpper.Equals(".MSG") And Not FileType.ToUpper.Equals(".EML") Then
                SS = "Update DataSource set isPublic = 'Y' where SourceGuid = '" + tKey + "'"
            Else
                SS = "Update email set isPublic = 'Y' where EmailGuid = '" + tKey + "'"
            End If
            Bb = ExecuteSqlNewConn(SS, False)
            If Bb Then
                LOG.WriteToArchiveLog("Reset the isPublic  for guid '" + tKey + "'")
            End If
        End If
        If rbPrivate Then
            Dim SS As String = ""

            Dim isOwner As Boolean = ValidateContentOwnership(tgtGuid, FileType)
            If isOwner = False Then
                isOwner = ValidateCoOwnerOfContent(tgtGuid, FileType)
                If isOwner = False Then
                    SB.Text = "You do not own all of this content, so some changes are not allowed."
                    'messagebox.show("You do not own all of this content, so some changes are not allowed.")
                    Return False
                End If
            End If

            If Not FileType.ToUpper.Equals(".MSG") And Not FileType.ToUpper.Equals(".EML") Then
                SS = "Update DataSource set isPublic = 'N' where SourceGuid = '" + tKey + "'"
            Else
                SS = "Update email set isPublic = 'N' where EmailGuid = '" + tKey + "'"
            End If
            Bb = ExecuteSqlNewConn(SS, False)
            If Bb Then
                LOG.WriteToArchiveLog("Reset the isPublic  for guid '" + tKey + "'")
            End If
        End If
        If rbMstrYes Then
            Dim SS As String = ""

            Dim isOwner As Boolean = ValidateContentOwnership(tgtGuid, FileType)
            If isOwner = False Then
                isOwner = ValidateCoOwnerOfContent(tgtGuid, FileType)
                If isOwner = False Then
                    SB.Text = "You do not own all of this content, so some changes are not allowed."
                    'messagebox.show("You do not own all of this content, so some changes are not allowed.")
                    Return False
                End If
            End If

            If Not FileType.ToUpper.Equals(".MSG") And Not FileType.ToUpper.Equals(".EML") Then

                SS = "Update DataSource set isMaster = 'Y' where SourceGuid = '" + tKey + "'"
                'Else
                '    SS  = "Update email set isPublic = 'Y' where EmailGuid = '" + tKey  + "'"
                Bb = ExecuteSqlNewConn(SS, False)
                If Bb Then
                    LOG.WriteToArchiveLog("Reset the isMaster for guid '" + tKey + "'")
                End If
            Else
                SS = "Update Email set isMaster = 'Y' where EmaileGuid = '" + tKey + "'"
                'Else
                '    SS  = "Update email set isPublic = 'N' where EmailGuid = '" + tKey  + "'"
                Bb = ExecuteSqlNewConn(SS, False)
                If Bb Then
                    LOG.WriteToArchiveLog("Reset the isMaster  for EMAIL guid '" + tKey + "'")
                End If
            End If
        End If
        If rbMstrNot Then

            Dim SS As String = ""

            Dim isOwner As Boolean = ValidateContentOwnership(tgtGuid, FileType)
            If isOwner = False Then
                isOwner = ValidateCoOwnerOfContent(tgtGuid, FileType)
                If isOwner = False Then
                    SB.Text = "You do not own all of this content, so some changes are not allowed."
                    'messagebox.show("You do not own all of this content, so some changes are not allowed.")
                    Return False
                End If
            End If

            If Not FileType.ToUpper.Equals(".MSG") And Not FileType.ToUpper.Equals(".EML") Then
                SS = "Update DataSource set isMaster = 'N' where SourceGuid = '" + tKey + "'"
                'Else
                '    SS  = "Update email set isPublic = 'N' where EmailGuid = '" + tKey  + "'"
                Bb = ExecuteSqlNewConn(SS, False)
                If Bb Then
                    LOG.WriteToArchiveLog("Reset the isMaster  for guid '" + tKey + "'")
                End If
            Else
                SS = "Update Email set isMaster = 'N' where EmaileGuid = '" + tKey + "'"
                'Else
                '    SS  = "Update email set isPublic = 'N' where EmailGuid = '" + tKey  + "'"
                Bb = ExecuteSqlNewConn(SS, False)
                If Bb Then
                    LOG.WriteToArchiveLog("Reset the isMaster  for EMAIL guid '" + tKey + "'")
                End If
            End If

        End If
        Return Bb
    End Function

    ''' <summary>
    ''' Does the content of the iown this.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function DoIownThisContent(ByVal SourceGuid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As String = ""
        Dim S As String = ""

        Try
            S = S + " select DataSourceOwnerUserID  "
            S = S + " from DataSource "
            S = S + " where SourceGuid = '" + SourceGuid + "' "

            Dim RSData As SqlDataReader = Nothing
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

            If RSData.HasRows Then
                RSData.Read()
                id = RSData.GetValue(0).ToString
                If id = gCurrUserGuidID Then
                    b = True
                Else
                    b = False
                End If
            Else
                id = CStr(-1)
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:DoIownThisContent: ", ex)
            b = False
        End Try
        Return b
    End Function

    ''' <summary>
    ''' Determines whether [is email public] [the specified email unique identifier].
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns><c>true</c> if [is email public] [the specified email unique identifier]; otherwise, <c>false</c>.</returns>
    Function isEmailPublic(ByVal EmailGuid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As String = ""
        Dim S As String = ""

        Try
            S = "Select ispublic from Email where EmailGuid = '" + EmailGuid + "'"

            Dim RSData As SqlDataReader = Nothing
            'Dim CS  = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsdata= command.ExecuteReader()
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            If RSData.HasRows Then
                RSData.Read()
                id = RSData.GetValue(0).ToString
                If id.ToUpper.Equals("Y") Then
                    b = True
                Else
                    b = False
                End If
            Else
                b = False
            End If
            RSData.Close()
            RSData = Nothing

            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:isEmailPublic: ", ex)
            b = False
        End Try
        Return b
    End Function

    ''' <summary>
    ''' Zeroizes the global search.
    ''' </summary>
    Sub ZeroizeGlobalSearch()
        Dim S As String = "delete from GlobalSeachResults where UserID = '" + gCurrUserGuidID + "'"
        Dim B As Boolean = False
        Try
            B = ExecuteSqlNewConn(S, False)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR 100 - clsDatabaseARCH:ZeroizeGlobalSearch: Failed to seroize global search - " + Environment.NewLine + S)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 200 - clsDatabaseARCH:ZeroizeGlobalSearch: ", ex)
            B = False
        End Try
    End Sub

    ''' <summary>
    ''' Gets the owner unique identifier.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getOwnerGuid(ByVal SourceGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'select DataSourceOwnerUserID from DataSource where SourceGuid= 'XX'
        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As String = ""
        Dim S As String = ""

        Try
            S = "Select DataSourceOwnerUserID from DataSource where SourceGuid= '" + SourceGuid + "'"

            Dim RSData As SqlDataReader = Nothing

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            If RSData.HasRows Then
                RSData.Read()
                id = RSData.GetValue(0).ToString
            Else
                id = ""
            End If
            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getOwnerGuid: ", ex)
            id = ""
        End Try
        Return id
    End Function

    ''' <summary>
    ''' Cks the content ownership.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="LoggedInUserGuid">The logged in user unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckContentOwnership(ByVal SourceGuid As String, ByVal LoggedInUserGuid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If isAdmin(LoggedInUserGuid) Then
            Return True
        End If

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As String = ""
        Dim S As String = ""
        Dim OwnerGuid As String = getOwnerGuid(SourceGuid)
        If OwnerGuid.Equals(LoggedInUserGuid) Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Gets all libraries user can access.
    ''' </summary>
    ''' <param name="AccessibleLibraries">The accessible libraries.</param>
    ''' <param name="isAdmin">if set to <c>true</c> [is admin].</param>
    Sub GetAllLibrariesUserCanAccess(ByRef AccessibleLibraries As ArrayList, ByVal isAdmin As Boolean)
        Dim rsData As SqlDataReader = Nothing
        Dim LibraryName As String = ""
        AccessibleLibraries.Clear()

        If isAdmin = True Then
            Dim S As String = "Select LibraryName, UserID from Library order by LibraryName"
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    LibraryName = rsData.GetValue(0).ToString
                    If Not AccessibleLibraries.Contains(LibraryName) Then
                        AccessibleLibraries.Add(LibraryName)
                    End If
                Loop
            End If
        Else
            Try
                Dim S As String = "Select   distinct   GroupLibraryAccess.LibraryName "
                S = S + " FROM         GroupUsers INNER JOIN"
                S = S + " GroupLibraryAccess ON GroupUsers.UserID = GroupLibraryAccess.UserID"
                S = S + " group by GroupUsers.UserID, GroupLibraryAccess.LibraryName, GroupLibraryAccess.GroupName  "
                S = S + " HAVING      (GroupUsers.UserID = '" + gCurrUserGuidID + "')  "

                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
                If rsData.HasRows Then
                    Do While rsData.Read()
                        LibraryName = rsData.GetValue(0).ToString
                        If Not AccessibleLibraries.Contains(LibraryName) Then
                            AccessibleLibraries.Add(LibraryName)
                        End If
                    Loop
                End If

                If Not rsData.IsClosed Then
                    rsData.Close()
                End If

                S = "Select LibraryName from Library where userid = '" + gCurrUserGuidID + "'"
                CONN = New SqlConnection(CS) : CONN.Open() : command = New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
                If rsData.HasRows Then
                    Do While rsData.Read()
                        LibraryName = rsData.GetValue(0).ToString
                        If Not AccessibleLibraries.Contains(LibraryName) Then
                            AccessibleLibraries.Add(LibraryName)
                        End If
                    Loop
                End If
            Catch ex As Exception

            End Try
        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()

    End Sub

    ''' <summary>
    ''' Gets the name of the server instance.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getServerInstanceName() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select @@SERVERNAME AS 'ServerName'"
        Dim rsData As SqlDataReader = Nothing
        Dim ServerName As String = ""
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            Do While rsData.Read()
                ServerName = rsData.GetValue(0).ToString
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getServerName Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return ServerName

    End Function

    ''' <summary>
    ''' Gets the name of the server machine.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getServerMachineName() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select SERVERPROPERTY('MachineName')"
        Dim rsData As SqlDataReader = Nothing
        Dim ServerName As String = ""
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            Do While rsData.Read()
                ServerName = rsData.GetValue(0).ToString
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getServerName Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return ServerName

    End Function

    ''' <summary>
    ''' Sets the server identifier.
    ''' </summary>
    ''' <param name="SqlServerInstanceNameX">The SQL server instance name x.</param>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="LicenseID">The license identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function setServerIdentifier(ByVal SqlServerInstanceNameX As String, ByVal CustomerID As String, ByVal LicenseID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim X As String = ENC.AES256EncryptString(SqlServerInstanceNameX)
        X = UTIL.RemoveSingleQuotes(X)
        Dim S As String = "Update License set  SqlServerInstanceNameX = '" + SqlServerInstanceNameX + "' where CustomerID = '" + CustomerID + "' and VersionNbr = '" + LicenseID + "'"
        Dim B As Boolean = Me.ExecuteSqlNewConn(90108, S)
        If B = False Then
            LOG.WriteToArchiveLog("clsDatabaseARCH:setServerIdentifier Error 100: Failed to add Server Identifier, system may be inoperable.")
            MessageBox.Show("clsDatabaseARCH:setServerIdentifier Error 100: Failed to add Server Identifier, system may be inoperable.")
            Return False
        End If
        Return True
    End Function

    ''' <summary>
    ''' Gets the server identifier.
    ''' </summary>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="LicenseID">The license identifier.</param>
    ''' <returns>System.String.</returns>
    Function getServerIdentifier(ByVal CustomerID As String, ByVal LicenseID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SqlServerInstanceNameX As String = ""
        Dim S As String = "Select SqlServerInstanceNameX from License where CustomerID = '" + CustomerID + "' and VersionNbr = '" + LicenseID + "'"
        Dim rsData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                SqlServerInstanceNameX = rsData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getServerIdentifier Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return SqlServerInstanceNameX
    End Function

    ''' <summary>
    ''' Sets the SQL instance identifier.
    ''' </summary>
    ''' <param name="SqlServerMachineName">Name of the SQL server machine.</param>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="LicenseID">The license identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function setSqlInstanceIdentifier(ByVal SqlServerMachineName As String, ByVal CustomerID As String, ByVal LicenseID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim X As String = ENC.AES256EncryptString(SqlServerMachineName)
        X = UTIL.RemoveSingleQuotes(X)
        Dim S As String = "Update License set  SqlServerInstanceNameX = '" + SqlServerMachineName + "' where CustomerID = '" + CustomerID + "' and LicenseID = '" + LicenseID + "'"
        Dim B As Boolean = Me.ExecuteSqlNewConn(90109, S)
        If B = False Then
            LOG.WriteToArchiveLog("clsDatabaseARCH:setServerIdentifier Error 100: Failed to add SQL Instance Identifier, system may be inoperable.")
            MessageBox.Show("clsDatabaseARCH:setServerIdentifier Error 100: Failed to add SQL Instance Identifier, system may be inoperable.")
            Return False
        End If
        Return True
    End Function

    ''' <summary>
    ''' Gets the SQL instance identifier.
    ''' </summary>
    ''' <param name="CustomerID">The customer identifier.</param>
    ''' <param name="LicenseID">The license identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function getSqlInstanceIdentifier(ByVal CustomerID As String, ByVal LicenseID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SqlServerMachineName As String = ""
        Dim S As String = "Select SqlServerMachineName from License where CustomerID = '" + CustomerID + "' and LicenseID = '" + LicenseID + "'"
        Dim rsData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                SqlServerMachineName = rsData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getSqlInstanceIdentifier Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return CBool(SqlServerMachineName)
    End Function

    ''' <summary>
    ''' Strings to byte array.
    ''' </summary>
    ''' <param name="str">The string.</param>
    ''' <returns>System.Byte().</returns>
    Public Shared Function StrToByteArray(ByVal str As String) As Byte()
        Dim encoding As New System.Text.ASCIIEncoding()
        'Dim encoding As New System.Text.UnicodeEncoding
        Return encoding.GetBytes(str)
    End Function 'StrToByteArray

    ''' <summary>
    ''' Gets the satus flags.
    ''' </summary>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="isMaster">The is master.</param>
    ''' <param name="isWebPage">The is web page.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="SourceType">Type of the source.</param>
    Public Sub getSatusFlags(ByRef isPublic As CheckBox, ByRef isMaster As CheckBox, ByRef isWebPage As CheckBox, ByVal SourceGuid As String, ByVal SourceType As String)
        Dim sPublic As String = ""
        Dim sMaster As String = ""
        Dim sWebPage As String = ""
        isMaster.Checked = False
        isPublic.Checked = False
        isWebPage.Checked = False
        Dim S As String = ""
        If SourceType.ToUpper.Equals(".EML") Then
            S = "Select isPublic, 'N' as isMaster, 'N' as isWebPage from EMAIL where EmailGuid = '" + SourceGuid + "' "
        ElseIf SourceType.ToUpper.Equals(".MSG") Then
            S = "Select isPublic, 'N' as isMaster, 'N' as isWebPage from EMAIL where EmailGuid = '" + SourceGuid + "' "
        Else
            S = "Select isPublic, isMaster, isWebPage from DataSource where SourceGuid = '" + SourceGuid + "'"
        End If
        Dim rsData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                Try
                    If IsDBNull(rsData.GetValue(0).ToString) Then
                        sPublic = "N"
                    Else
                        sPublic = rsData.GetValue(0).ToString
                    End If
                Catch ex As Exception
                    sPublic = "N"
                End Try
                Try
                    If IsDBNull(rsData.GetValue(1).ToString) Then
                        sMaster = "N"
                    Else
                        sMaster = rsData.GetValue(1).ToString
                    End If
                Catch ex As Exception
                    sMaster = "N"
                End Try
                Try
                    If IsDBNull(rsData.GetValue(2).ToString) Then
                        sWebPage = "N"
                    Else
                        sWebPage = rsData.GetValue(2).ToString
                    End If
                Catch ex As Exception
                    sWebPage = "N"
                End Try

            End If
            If sPublic.Equals("Y") Then
                isPublic.Checked = True
            Else
                isPublic.Checked = False
            End If
            If sMaster.Equals("Y") Then
                isMaster.Checked = True
            Else
                isMaster.Checked = False
            End If
            If sWebPage.Equals("Y") Then
                isWebPage.Checked = True
            Else
                isWebPage.Checked = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:getSqlInstanceIdentifier Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()

    End Sub

    ''' <summary>
    ''' Gets the retention code.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns>System.String.</returns>
    Function getRetentionCode(ByVal UserID As String, DirName As String) As String

        DirName = DirName.Replace("''", "'")
        DirName = DirName.Replace("'", "''")

        Dim RetentionCode As String = ""
        Dim S As String = "select top 1 RetentionCode from Directory where FQN = '" + DirName + "' and UserID = '" + UserID + "' "
        Dim rsData As SqlDataReader = Nothing
        Dim rPeriod As Integer = 10
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                RetentionCode = rsData.GetString(0)
            End If
        Catch ex As Exception
            rPeriod = 10
            LOG.WriteToArchiveLog("clsDatabaseARCH:getSqlInstanceIdentifier Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return RetentionCode
    End Function

    ''' <summary>
    ''' Gets the retention period.
    ''' </summary>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <returns>System.Int32.</returns>
    Function getRetentionPeriod(ByVal RetentionCode As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If RetentionCode.Trim.Length = 0 Then
            Return 50
        End If

        'Dim SqlServerMachineName  = ""
        RetentionCode = UTIL.RemoveSingleQuotes(RetentionCode)
        Dim S As String = "Select RetentionUnits from Retention where RetentionCode = '" + RetentionCode + "'"
        Dim rsData As SqlDataReader = Nothing
        Dim rPeriod As Integer = 10
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                rPeriod = rsData.GetInt32(0)
            End If
        Catch ex As Exception
            rPeriod = 10
            LOG.WriteToArchiveLog("clsDatabaseARCH:getSqlInstanceIdentifier Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return rPeriod
    End Function

    ''' <summary>
    ''' Gets the retention period maximum.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getRetentionPeriodMax() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'Dim SqlServerMachineName  = ""
        Dim S As String = ""
        Dim MaxYears As String = getRetentionPeriodYearsMax()
        Dim MaxPeriod As String = ""

        S = " SELECT [RetentionCode] FROM [Retention] where RetentionUnits = " + MaxYears

        Dim rsData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                MaxPeriod = rsData.GetValue(0).ToString
            End If
        Catch ex As Exception
            MaxPeriod = ""
            LOG.WriteToArchiveLog("clsDatabaseARCH:getRetentionPeriodMax Error 100: ", ex)
        End Try
        If rsData IsNot Nothing Then
            If Not rsData.IsClosed Then
                rsData.Close()
            End If
            rsData = Nothing
        End If

        GC.Collect()
        Return MaxPeriod

    End Function

    ''' <summary>
    ''' Gets the retention period years maximum.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getRetentionPeriodYearsMax() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'Dim SqlServerMachineName  = ""
        Dim S As String = ""
        S = " select MAX(RetentionUnits) FROM [Retention]"

        Dim rsData As SqlDataReader = Nothing
        Dim rPeriod As String = "100"
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                rPeriod = rsData.GetValue(0).ToString
            End If
        Catch ex As Exception
            rPeriod = CStr(10)
            LOG.WriteToArchiveLog("clsDatabaseARCH:getRetentionPeriodYearsMax Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return rPeriod
    End Function

    ''' <summary>
    ''' Sets the exchange default retention code.
    ''' </summary>
    Sub SetExchangeDefaultRetentionCode()
        Dim S As String = ""
        S = S + " update ExchangeHostPop "
        S = S + " set RetentionCode = (select top(1) RetentionCode from Retention)"
        S = S + " where RetentionCode Is null "
        Me.ExecuteSqlNewConn(90110, S)
    End Sub

    ''' <summary>
    ''' Gets the dir retention code.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.String.</returns>
    Function GetDirRetentionCode(ByVal FQN As String, ByVal UserID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = ""
        Dim rCode As String = ""
        Try

            S = S + " select RetentionCode from Directory"
            S = S + " where UserID = '" + UserID + "'"
            S = S + " and FQN = '" + FQN + "'"

            Dim rsData As SqlDataReader = Nothing
            Dim rPeriod As Integer = 10
            Try

                Dim CS As String = getRepoConnStr()
                Dim CONN As New SqlConnection(CS)
                CONN.Open()
                Dim command As New SqlCommand(S, CONN)
                rsData = command.ExecuteReader()

                If rsData.HasRows Then
                    rsData.Read()
                    rCode = rsData.GetValue(0).ToString
                End If

                If Not rsData.IsClosed Then
                    rsData.Close()
                End If
                rsData = Nothing
                command.Dispose()
                command = Nothing

                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
                CONN.Dispose()
            Catch ex As Exception
                LOG.WriteToArchiveLog("clsDatabaseARCH:GetDirRetentionCode Error 100: ", ex)
            End Try

            'If Not rsData.IsClosed Then
            '    rsData.Close()
            'End If
            'rsData = Nothing
            GC.Collect()
            Return rCode
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error 2323.45 GetDirRetentionCode: ", ex)
            Return "Retain 20"
        End Try

        Return ""

    End Function

    ''' <summary>
    ''' Gets the retention MGR.
    ''' </summary>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <returns>System.String.</returns>
    Function GetRetentionMgr(ByVal RetentionCode As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        S = S + " select ManagerName from Retention   "
        S = S + " where RetentionCode = '" + RetentionCode + "'"

        Dim rCode As String = ""

        Dim rsData As SqlDataReader = Nothing
        Dim rPeriod As Integer = 10
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                rCode = rsData.GetValue(0).ToString
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH:GetRetentionMgr Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return rCode

    End Function

    ''' <summary>
    ''' Sets the retention date.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="FileExtention">The file extention.</param>
    Sub setRetentionDate(ByVal SourceGuid As String, ByVal RetentionCode As String, ByVal FileExtention As String)

        Dim RetentionUnits As Integer = getRetentionPeriod(RetentionCode)
        Dim rightNow As Date = Now
        rightNow = rightNow.AddYears(RetentionUnits)
        Dim RetentionExpirationDate As String = rightNow.ToString
        Dim S As String = ""

        If FileExtention.ToUpper.Equals(".MSG") Or FileExtention.ToUpper.Equals(".EML") Then
            S = "Update email set RetentionExpirationDate = '" + RetentionExpirationDate + "' where EmailGuid = '" + SourceGuid + "' "
        Else
            S = "Update DataSource set RetentionExpirationDate = '" + RetentionExpirationDate + "' where SourceGuid = '" + SourceGuid + "' "
        End If

        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If FileExtention.ToUpper.Equals(".MSG") Or FileExtention.ToUpper.Equals(".EML") Then
            S = "Update email set RetentionCode = '" + RetentionCode + "' where EmailGuid = '" + SourceGuid + "' "
        Else
            S = "Update DataSource set RetentionCode = '" + RetentionCode + "' where SourceGuid = '" + SourceGuid + "' "
        End If

        B = Me.ExecuteSqlNewConn(S, False)
    End Sub

    ''' <summary>
    ''' Counts the machine.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function cntMachine(ByVal MachineName As String, ByVal FQN As String, ByVal SourceGuid As String) As Boolean

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        Dim RSData As SqlDataReader = Nothing
        S = " SELECT COUNT(*) FROM [Machine] where MachineName = '" + MachineName + "' and FQN = '" + FQN + "' and SourceGuid = '" + SourceGuid + "' "
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

        Try
            Using CONN

                RSData.Read()
                cnt = CInt(RSData.GetValue(0).ToString)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If

            CONN = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error - 1432.654.a - Failed to add machine for " + FQN)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Adds the machine source xx.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function AddMachineSourceXX(ByVal FQN As String, ByVal SourceGuid As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim MachineName As String = Environment.MachineName.ToString
        B = cntMachine(MachineName, FQN, SourceGuid)
        If Not B Then
            Dim S As String = "INSERT INTO [Machine]"
            S = S + " ([MachineName]"
            S = S + " ,[FQN]"
            S = S + " ,[ContentType]"
            S = S + " ,[CreateDate]"
            S = S + " ,[LastUpdate]"
            S = S + " ,[SourceGuid]"
            S = S + " ,[UserID])"
            S = S + " VALUES "
            S = S + " ('" + MachineName + "'"
            S = S + " ,'" + FQN + "'"
            S = S + " ,'Source'"
            S = S + " ,GETDATE()"
            S = S + " ,GETDATE()"
            S = S + " ,'" + SourceGuid + "'"
            S = S + " ,'" + gCurrUserGuidID + "'"
            S = S + " )"

            B = Me.ExecuteSqlNewConn(S, False)

        End If
        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is library owner] [the specified library name].
    ''' </summary>
    ''' <param name="LibName">Name of the library.</param>
    ''' <returns><c>true</c> if [is library owner] [the specified library name]; otherwise, <c>false</c>.</returns>
    Function isLibOwner(ByVal LibName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        S = " SELECT count(*) FROM [Library] where LibraryName = '" + LibName + "' and UserID = '" + gCurrUserGuidID + "' "

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        Try
            Using CONN
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If

            CONN = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error - 2133.654.x - Failed to validate lib owner.")
            B = False
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Determines whether [is library item owner] [the specified library item unique identifier].
    ''' </summary>
    ''' <param name="LibraryItemGuid">The library item unique identifier.</param>
    ''' <returns><c>true</c> if [is library item owner] [the specified library item unique identifier]; otherwise, <c>false</c>.</returns>
    Function isLibItemOwner(ByVal LibraryItemGuid As String) As Boolean

        Dim S As String = ""
        Dim B As Boolean = False
        Dim cnt As Integer = -1

        S = " SELECT count(*) FROM [LibraryItems] where LibraryItemGuid = '" + LibraryItemGuid + "' and LibraryOwnerUserID = '" + gCurrUserGuidID + "' "

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

        Try
            Using CONN
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using

            If cnt > 0 Then
                B = True
            Else
                B = False
            End If

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If

            CONN = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error - 2133.696.y - Failed to validate lib item owner.")
            B = False
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Gets the web metadata.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="WebParms">The web parms.</param>
    Sub getWebMetadata(ByVal SourceGuid As String, ByRef WebParms As SortedList(Of String, String))

        WebParms.Clear()

        Dim S As String = "Select "
        S = S + " [SourceName]"
        S = S + " ,[SourceTypeCode]"
        S = S + " ,[FQN]"
        S = S + " ,[FileLength]"
        S = S + " ,[FileDirectory]"
        S = S + " ,[OriginalFileType]"
        S = S + " ,[Description]"
        S = S + " ,[isGraphic]"
        S = S + " ,[isWebPage]"
        S = S + " FROM DataSource"
        S = S + " where SourceGuid  = '" + SourceGuid + "'"

        Dim SourceName As String = ""
        Dim SourceTypeCode As String = ""
        Dim FQN As String = ""
        Dim FileLength As String = ""
        Dim FileDirectory As String = ""
        Dim OriginalFileType As String = ""
        Dim Description As String = ""
        Dim isGraphic As String = ""
        Dim isWebPage As String = ""

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()

        Try
            Using CONN
                If RSData.HasRows Then
                    RSData.Read()
                    SourceName = RSData.GetValue(0).ToString
                    WebParms.Add("SourceName", SourceName)

                    SourceTypeCode = RSData.GetValue(1).ToString
                    WebParms.Add("SourceTypeCode", SourceTypeCode)

                    FQN = RSData.GetValue(2).ToString
                    WebParms.Add("FQN", FQN)

                    FileLength = RSData.GetValue(3).ToString
                    WebParms.Add("FileLength", FileLength)

                    FileDirectory = RSData.GetValue(4).ToString
                    WebParms.Add("FileDirectory", FileDirectory)

                    OriginalFileType = RSData.GetValue(5).ToString
                    WebParms.Add("OriginalFileType", OriginalFileType)

                    Description = RSData.GetValue(6).ToString
                    WebParms.Add("Description", Description)

                    isGraphic = RSData.GetValue(7).ToString
                    WebParms.Add("isGraphic", isGraphic)

                    isWebPage = RSData.GetValue(8).ToString
                    WebParms.Add("isWebPage", isWebPage)

                End If

                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing

            End Using

            CONN.Close()
            CONN = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error getWebMetadata - 2133.696.y - Failed to acquire web metadata: ", ex)
        End Try
    End Sub

    ''' <summary>
    ''' Populates the library combo.
    ''' </summary>
    ''' <param name="CB">The cb.</param>
    Sub PopulateLibCombo(ByRef CB As ComboBox)

        Try
            CB.Items.Clear()
        Catch ex As Exception
            Debug.Print(ex.Message)
        End Try
        Dim S As String = ""
        Dim isAdmin As Boolean = Me.isAdmin(gCurrUserGuidID)
        If isAdmin Then
            S = "Select LibraryName FROM Library order by LibraryName "
        Else
            S = "Select distinct [LibraryName]"
            S = S + " FROM [LibraryUsers]"
            S = S + " where UserID = '" + gCurrUserGuidID + "' "
            S = S + " group by LibraryName"
        End If

        Me.PopulateComboBox(CB, "LibraryName", S)

    End Sub

    ''' <summary>
    ''' Gets the count source.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns>System.Int32.</returns>
    Function getCntSource(ByVal SourceName As String, ByVal CRC As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        SourceName = UTIL.RemoveSingleQuotes(SourceName)

        Dim S As String = ""
        S = S + " SELECT count(*) "
        S = S + " FROM DataSource"
        S = S + " where SourceName = "
        S = S + "'" + SourceName + "'"
        S = S + " and CRC = " + CRC + ""

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            'Dim CS  = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsdata= command.ExecuteReader()

            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()

            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    'select datalength(SourceImage)  from DataSource where SourceGuid = '15bd8f45-5795-4526-adee-b0ddde66490b'
    ''' <summary>
    ''' Gets the size of the image.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function GetImageSize(ByVal SourceGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        S = "Select datalength(SourceImage)  from DataSource where SourceGuid = '" + SourceGuid + "'"
        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    Function GetImageBinary(ByVal SourceGuid As String, TblCode As String) As Byte()
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As String = ""
        Dim S As String = ""
        Dim MyBytes As Byte() = Nothing
        Dim CS As String = getRepoConnStr()

        Try
            CloseConn()
            CkConn()

            If (TblCode.Equals("C")) Then
                S = "Select SourceImage from DataSource where SourceGuid = '" + SourceGuid + "'"
            Else
                S = "Select Attachment from EmailAttachment where RowGuid = '" + SourceGuid + "'"
            End If
            Using CONN As New SqlConnection(CS)
                CONN.Open()
                Using command As New SqlCommand(S, CONN)
                    Using rsData As SqlDataReader = command.ExecuteReader()
                        If rsData.HasRows Then
                            rsData.Read()
                            MyBytes = rsData(0)
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR GetImageBinary: " + ex.Message + vbCrLf + S)
            b = False
        End Try

        Return MyBytes

    End Function


    ''' <summary>
    ''' Gets the maximum version NBR.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns>System.Int32.</returns>
    Function GetMaxVersionNbr(ByVal SourceName As String, CRC As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim cnt As Integer = -1
        Dim S As String = ""

        Dim iCnt As Integer = getCntSource(SourceName, CRC)

        If iCnt = 0 Then
            Return -1
        End If

        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        S = S + " SELECT MAX(VersionNbr) FROM DataSource where SourceName = '" + SourceName + "' "

        Try
            CloseConn()
            CkConn()

            'Dim CMD As New SqlCommand(S, gConn)
            Dim RSData As SqlDataReader = Nothing

            Using gConn
                Dim CS As String = getRepoConnStr()
                Dim CONN As New SqlConnection(CS)
                CONN.Open()
                Dim command As New SqlCommand(S, CONN)
                RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    RSData.Read()
                    cnt = RSData.GetInt32(0)
                    RSData.Close()
                    RSData = Nothing
                Else
                    cnt = 0
                End If
                'CMD.Connection.Close()
                'CMD = Nothing
            End Using
            If Not RSData Is Nothing Then
                RSData = Nothing
            End If
            'If Not CMD Is Nothing Then
            '    CMD = Nothing
            'End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: clsDatabaseARCH : GetMaxVersionNbr 100 - ", ex)
            LOG.WriteToArchiveLog("ERROR: clsDatabaseARCH : GetMaxVersionNbr 100 - SQL: " + Environment.NewLine + S)
        End Try

        Return cnt
    End Function

    ''' <summary>
    ''' Cks the files need update.
    ''' </summary>
    ''' <param name="ListOfFiles">The list of files.</param>
    ''' <param name="CheckArchiveBit">if set to <c>true</c> [check archive bit].</param>
    Sub ckFilesNeedUpdate(ByRef ListOfFiles As List(Of String), ByVal CheckArchiveBit As Boolean)

        Dim INFO As New Dictionary(Of String, String)
        Dim DBLocal As New clsDbLocal
        Dim HexCrc As String = ""
        Dim LL As Integer = 0
        Dim fiFullName = ""

        Try
            Dim A(0) As String
            Dim ArchFlag As String = ""
            For i As Integer = 0 To ListOfFiles.Count - 1
                Try
                    LL = 1
                    System.Windows.Forms.Application.DoEvents()
                    If i Mod 10 = 0 Then
                        frmNotify.lblFileSpec.Text = "Check Update Needed: " + i.ToString + " of " + ListOfFiles.Count.ToString
                        frmNotify.Refresh()
                    End If
                    System.Windows.Forms.Application.DoEvents()
                    Dim S As String = ListOfFiles(i)
                    LL = 10
                    'If CheckArchiveBit Then
                    '    ArchFlag = Mid(S, 1, InStr(S, "|") - 1)
                    '    ArchFlag = ArchFlag.ToUpper
                    '    If ArchFlag.Equals("FALSE") Then
                    '        ListOfFiles(i) = ""
                    '        GoTo NxtRec
                    '    End If
                    'End If
                    LL = 20
                    'False| xx.png|.png|C:\Temp\Tiff_Files|17630|22-Dec-10 8:00:57 PM|22-Dec-10 8:04:55 PM|22-Dec-10 8:01:02 PM
                    If S = Nothing Then
                        GoTo NxtRec
                    End If
                    If InStr(S, "|") = 0 Then
                        GoTo NxtRec
                    End If
                    A = S.Split(CChar("|"))
                    LL = 30

                    Dim Indicator As String = A(0)
                    Dim fiName = A(1).ToString
                    Dim fiExtension = A(2).ToString
                    fiFullName = A(3).ToString + "\" + A(1)
                    Dim Filength = A(4).ToString

                    Dim fiCreationTime = A(5).ToString
                    Dim fiLastAccessTime = A(6).ToString
                    Dim fiLastWriteTime = A(7).ToString

                    Dim FileLength As Int64 = CInt(Filength)
                    Dim LastAccessDate As DateTime = Nothing
                    Try
                        LastAccessDate = CDate(fiLastAccessTime)
                    Catch ex As Exception
                        LastAccessDate = Now
                    End Try

                    LL = 40
                    Dim LastWriteTime As DateTime = Nothing
                    Try
                        LastWriteTime = CDate(fiLastWriteTime)
                    Catch ex As Exception
                        LastWriteTime = Now
                    End Try
                    Dim CreateDate As DateTime = Nothing
                    Try
                        CreateDate = CDate(fiCreationTime)
                    Catch ex As Exception
                        CreateDate = LastWriteTime
                    End Try

                    Dim BB As Boolean = False
                    If Indicator.ToUpper.Equals("FALSE") Then
                        BB = False
                    Else
                        BB = True
                    End If
                    LL = 50

                    Dim NeedsUpdate As Boolean = False

                    INFO = DBLocal.getFileArchiveInfo(fiFullName)
                    If INFO.Count.Equals(0) Or INFO.Count.Equals(1) Then
                        NeedsUpdate = True
                    ElseIf LastAccessDate > Convert.ToDateTime(INFO("LastArchiveDate")) Then
                        NeedsUpdate = True
                    ElseIf FileLength <> Convert.ToInt64(INFO("FileSize")) Then
                        NeedsUpdate = True
                    End If

                    If INFO("AddNewRec").Equals("Y") Then
                        DBLocal.AddFileArchiveInfo(fiFullName)
                    End If

                    If NeedsUpdate.Equals(False) Then
                        GoTo NxtRec
                    End If

                    HexCrc = ENC.GenerateSHA512HashFromFile(fiFullName)
                    LL = 60

                    'BB = DBLocal.ckNeedsArchive(fiFullName, BB, HexCrc)
                    If NeedsUpdate.Equals(True) Then
                        BB = True
                    Else
                        BB = False
                    End If
                    LL = 70
                    If Not BB Then
                        ListOfFiles(i) = ""
                        GoTo NxtRec
                    End If

                    Dim b As Boolean = False
                    LL = 75
                    Dim VersionNbr As Integer = GetMaxVersionNbr(fiName, HexCrc)

                    If VersionNbr < 0 Then
                        '** The file does not exist in the repository, add it.
                        b = True
                    Else
                        LL = 80
                        b = ckSourceNeedsUpdate(fiName, HexCrc)
                        LL = 90
                        If b Then
                            If Not ListOfFiles.Contains(S) Then
                                ListOfFiles.Add(S)
                            End If
                        Else
                            ListOfFiles(i) = ""
                        End If
                        LL = 100
                    End If
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR 134 clsDatabaseARCH:ckFilesNeedUpdate - Skipping file: " + fiFullName, ex)
                End Try
NxtRec:
                LL = 110
            Next
        Catch ex As Exception
            Dim st As New StackTrace(True)
            st = New StackTrace(ex, True)

            LOG.WriteToArchiveLog("EX.TargetSite: " & ex.TargetSite.ToString)
            LOG.WriteToArchiveLog("Line: " & st.GetFrame(0).GetFileLineNumber().ToString)
            LOG.WriteToArchiveLog("ERROR 100 clsDatabaseARCH:ckFilesNeedUpdate LL = " + LL.ToString)
            LOG.WriteToArchiveLog("ERROR 100 clsDatabaseARCH:ckFilesNeedUpdate - ", ex)

            LOG.WriteToDirFileLog("EX.TargetSite: " & ex.TargetSite.ToString)
            LOG.WriteToDirFileLog("Line: " & st.GetFrame(0).GetFileLineNumber().ToString)
            LOG.WriteToDirFileLog("ERROR 100 clsDatabaseARCH:ckFilesNeedUpdate LL = " + LL.ToString)
            LOG.WriteToDirFileLog("ERROR 100 clsDatabaseARCH:ckFilesNeedUpdate - " + ex.Message)
        Finally
            DBLocal = Nothing
            GC.Collect()
            GC.WaitForPendingFinalizers()
        End Try

        frmNotify.lblFileSpec.Text = "Check Completed: " + ListOfFiles.Count.ToString
        frmNotify.Refresh()

    End Sub

    ''' <summary>
    ''' Cks the source needs update.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckSourceNeedsUpdate(ByVal SourceName As String, CRC As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""

        Dim bNeedsUpdating As Boolean = True

        SourceName = UTIL.RemoveSingleQuotes(SourceName)

        Try
            S = S + " select count(*) from datasource  where SourceName = '" + SourceName + "' and crc = " + CRC + " "

            Dim iCnt As Integer = iCount(S)
            If iCnt > 0 Then
                bNeedsUpdating = False
            Else
                bNeedsUpdating = True
            End If
        Catch ex As Exception
            bNeedsUpdating = True
            LOG.WriteToArchiveLog("ERROR 001 clsDatabaseARCH:ckSourceNeedsUpdate - " + S + Environment.NewLine + ex.Message)
        End Try

        Return bNeedsUpdating

    End Function

    ''' <summary>
    ''' Adds the archive dir.
    ''' </summary>
    ''' <param name="DirFQN">The dir FQN.</param>
    Sub AddArchiveDir(ByVal DirFQN As String)
        DirFQN = UTIL.RemoveSingleQuotes(DirFQN)

        Dim iCnt As Integer = ArchiveDirExists(DirFQN, gMachineID)

        If iCnt = 0 Then
            Dim S As String = ""
            Dim B As Boolean = False

            S = "INSERT INTO [DirectoryTemp]"
            S = S + " ([DirFQN]"
            S = S + " ,[CurrUserGuidID]"
            S = S + " ,[MachineID])"
            S = S + " VALUES "
            S = S + " ('" + DirFQN + "'"
            S = S + " ,'" + gCurrUserGuidID + "'"
            S = S + " ,'" + gMachineID + "'"

        End If

    End Sub

    ''' <summary>
    ''' Archives the dir exists.
    ''' </summary>
    ''' <param name="DirFqn">The dir FQN.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function ArchiveDirExists(ByVal DirFqn As String, ByVal MachineID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""

        DirFqn = UTIL.RemoveSingleQuotes(DirFqn)

        S = S + " SELECT COUNT(*) FROM [DirectoryTemp] where [DirFQN] = '" + DirFqn + "' and [CurrUserGuidID] = '" + gCurrUserGuidID + "' and [MachineID] = '" + MachineID + "'"

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                cnt = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
            End If

            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Gets the database information.
    ''' </summary>
    ''' <param name="ProductVersion">The product version.</param>
    ''' <param name="ProductLevel">The product level.</param>
    ''' <param name="Edition">The edition.</param>
    ''' <param name="VersionDesc">The version desc.</param>
    Sub getDbInfo(ByRef ProductVersion As String, ByRef ProductLevel As String, ByRef Edition As String, ByRef VersionDesc As String)
        Dim S As String = ""
        S = S + " SELECT SERVERPROPERTY('productversion') as ProductVersion, "
        S = S + " SERVERPROPERTY ('productlevel') as ProductLevel, "
        S = S + " SERVERPROPERTY ('edition') as Edition, "
        S = S + " @@VERSION as VersionDesc"

        CloseConn()
        CkConn()

        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            ProductVersion = RSData.GetValue(0).ToString
            ProductLevel = RSData.GetValue(1).ToString
            Edition = RSData.GetValue(2).ToString
            VersionDesc = RSData.GetValue(3).ToString
            RSData.Close()
            RSData = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        GC.Collect()
        GC.WaitForFullGCComplete()
    End Sub

    ''' <summary>
    ''' Populates all user library combo.
    ''' </summary>
    ''' <param name="cb">The cb.</param>
    Sub PopulateAllUserLibCombo(ByVal cb As ComboBox)
        Dim S As String = ""
        Try
            cb.Items.Clear()

            S = ""
            S = S + "Select LibraryName from Library order by LibraryName "

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim LibraryName As String = RSData.GetValue(0).ToString
                    If cb.Items.Contains(LibraryName) Then
                    Else
                        cb.Items.Add(LibraryName)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 33.44.1 - ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Populates the group user library combo.
    ''' </summary>
    ''' <param name="cb">The cb.</param>
    Sub PopulateGroupUserLibCombo(ByVal cb As ComboBox)
        Dim S As String = ""
        Dim bIsAdmin As Boolean = isAdmin(gCurrUserGuidID)
        Try
            cb.Items.Clear()
            If bIsAdmin = True Then
                S = ""
                S = S + "Select [LibraryName] FROM [Library] order by [LibraryName]"
            Else
                S = ""
                S = S + "Select distinct LibraryName from GroupLibraryAccess " + Environment.NewLine
                S = S + " where GroupName in " + Environment.NewLine
                S = S + " (select distinct GroupName from GroupUsers where UserID = '" + gCurrUserGuidID + "')" + Environment.NewLine
                S = S + "             union " + Environment.NewLine
                S = S + " select distinct LibraryName from LibraryUsers where UserID = '" + gCurrUserGuidID + "'" + Environment.NewLine
                S = S + " and LibraryName in (select LibraryName from Library)" + Environment.NewLine
                S = S + "             union " + Environment.NewLine
                S = S + " select LibraryName from Library where UserID = '" + gCurrUserGuidID + "'" + Environment.NewLine
            End If

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim LibraryName As String = RSData.GetValue(0).ToString
                    If cb.Items.Contains(LibraryName) Then
                    Else
                        cb.Items.Add(LibraryName)
                    End If
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 33.44.1 - ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the user group membership.
    ''' </summary>
    ''' <returns>ArrayList.</returns>
    Function GetUserGroupMembership() As ArrayList
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim A As New ArrayList
        Dim S As String = "Select distinct GroupName from GroupUsers where UserID = '" + gCurrUserGuidID + "'"
        Try
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim GroupyName As String = RSData.GetValue(0).ToString
                    A.Add(GroupyName)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR GetUserGroupMembership 33.44.2 - ", ex)
        End Try
        Return A
    End Function

    ''' <summary>
    ''' Cks the working dir exists.
    ''' </summary>
    ''' <param name="TypeDir">The type dir.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckWorkingDirExists(ByVal TypeDir As String) As Integer
        TypeDir = TypeDir.ToUpper

        Dim S As String = ""
        If TypeDir.Equals("CONTENT") Then
            S = S + " select COUNT(*) from SavedItems where ValName = 'CONTENT WORKING DIRECTORY' and Userid = '" + gCurrUserGuidID + "'"
        End If
        If TypeDir.Equals("EMAIL") Then
            S = S + " select COUNT(*) from SavedItems where ValName = 'EMAIL WORKING DIRECTORY' and Userid = '" + gCurrUserGuidID + "'"
        End If

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return cnt
    End Function

    ''' <summary>
    ''' Creates the new working dir.
    ''' </summary>
    ''' <param name="TypeDir">The type dir.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function CreateNewWorkingDir(ByVal TypeDir As String, ByVal DirName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""

        Dim B As Boolean = False

        DirName = UTIL.RemoveSingleQuotes(DirName)
        Dim iCnt As Integer = 0

        If TypeDir.Equals("EMAIL") Then

            iCnt = ckWorkingDirExists(TypeDir)
            If iCnt = 0 Then
                S = S + " INSERT INTO [SavedItems]"
                S = S + " ([Userid]"
                S = S + " ,[SaveName]"
                S = S + " ,[SaveTypeCode]"
                S = S + " ,[ValName]"
                S = S + " ,[ValValue])"
                S = S + " VALUES "
                S = S + " ('" + gCurrUserGuidID + "'"
                S = S + " ,'UserStartUpParameters'"
                S = S + " ,'StartUpParm'"
                S = S + " ,'EMAIL WORKING DIRECTORY'"
                S = S + " ,'" + DirName + "')"
            Else
                S = S + " update SavedItems "
                S = S + " set ValValue = '" + DirName + "'"
                S = S + " where ValName = 'EMAIL WORKING DIRECTORY'"
                S = S + " and Userid = '" + gCurrUserGuidID + "'"
            End If

            B = ExecuteSqlNewConn(90111, S)
            If B Then
                LOG.WriteToArchiveLog("The new EMAIL working directory has been set to : " + DirName + " for User " + gCurrUserGuidID)
            Else
                LOG.WriteToArchiveLog("Failed to set new EMAIL working directory to : " + DirName + " for User " + gCurrUserGuidID)
            End If

        ElseIf TypeDir.Equals("CONTENT") Then
            iCnt = ckWorkingDirExists(TypeDir)
            If iCnt = 0 Then
                S = S + " INSERT INTO [SavedItems]"
                S = S + " ([Userid]"
                S = S + " ,[SaveName]"
                S = S + " ,[SaveTypeCode]"
                S = S + " ,[ValName]"
                S = S + " ,[ValValue])"
                S = S + " VALUES "
                S = S + " ('" + gCurrUserGuidID + "'"
                S = S + " ,'UserStartUpParameters'"
                S = S + " ,'StartUpParm'"
                S = S + " ,'CONTENT WORKING DIRECTORY'"
                S = S + " ,'" + DirName + "')"
            Else
                S = S + " update SavedItems "
                S = S + " set ValValue = '" + DirName + "'"
                S = S + " where ValName = 'CONTENT WORKING DIRECTORY'"
                S = S + " and Userid = '" + gCurrUserGuidID + "'"
            End If

            B = ExecuteSqlNewConn(90112, S)
            If B Then
                LOG.WriteToArchiveLog("The new CONTENT working directory has been set to : " + DirName + " for User " + gCurrUserGuidID)
            Else
                LOG.WriteToArchiveLog("Failed to set new CONTENT working directory to : " + DirName + " for User " + gCurrUserGuidID)
            End If

        End If

        Return B
    End Function

    ''' <summary>
    ''' Cks the missing working dirs.
    ''' </summary>
    Sub ckMissingWorkingDirs()
        Dim iCnt As Integer = 0
        Dim TempDirName As String = DMA.getEnvVarTempDir
        iCnt = ckWorkingDirExists("EMAIL")
        If iCnt = 0 Then
            CreateNewWorkingDir("EMAIL", TempDirName)
        End If
        iCnt = ckWorkingDirExists("CONTENT")
        If iCnt = 0 Then
            CreateNewWorkingDir("CONTENT", TempDirName)
        End If
    End Sub

    ''' <summary>
    ''' Exchanges the email exists.
    ''' </summary>
    ''' <param name="EmailIdentifier">The email identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ExchangeEmailExists(ByVal EmailIdentifier As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        EmailIdentifier = UTIL.RemoveSingleQuotes(EmailIdentifier)

        'Dim SS As String = "select COUNT(*) from Email where EmailIdentifier = '" + EmailIdentifier + "' and RecHash = '" + RecHash + "'"
        Dim SS As String = "select COUNT(*) from Email where EmailIdentifier = '" + EmailIdentifier + "' "
        Dim iCnt As Integer = iCount(SS)

        If (iCnt = 0) Then
            Return False
        Else
            Return True
        End If

    End Function

    ''' <summary>
    ''' Exchanges the email exists v2.
    ''' </summary>
    ''' <param name="EmailIdentifier">The email identifier.</param>
    ''' <param name="RecHash">The record hash.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ExchangeEmailExistsV2(ByVal EmailIdentifier As String, RecHash As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        EmailIdentifier = UTIL.RemoveSingleQuotes(EmailIdentifier)

        'Dim SS As String = "select COUNT(*) from Email where EmailIdentifier = '" + EmailIdentifier + "' and RecHash = '" + RecHash + "'"
        Dim SS As String = "select COUNT(*) from Email where EmailIdentifier = '" + EmailIdentifier + "' "
        Dim iCnt As Integer = iCount(SS)

        If (iCnt = 0) Then
            Return False
        Else
            Return True
        End If

    End Function

    ''' <summary>
    ''' Determines whether [is archive disabled] [the specified archive type code].
    ''' </summary>
    ''' <param name="ArchiveTypeCode">The archive type code.</param>
    ''' <returns><c>true</c> if [is archive disabled] [the specified archive type code]; otherwise, <c>false</c>.</returns>
    Function isArchiveDisabled(ByVal ArchiveTypeCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim b As Boolean = False

        Try
            If ArchiveTypeCode.Equals("EXCHANGE") Then
                S = "Select ParmValue from RunParms where Parm = 'ExchangeDisabled' and UserID = '" + gCurrUserGuidID + "'"
            ElseIf ArchiveTypeCode.Equals("CONTENT") Then
                S = "Select ParmValue from RunParms where Parm = 'ContentDisabled' and UserID = '" + gCurrUserGuidID + "'"
            ElseIf ArchiveTypeCode.Equals("EMAIL") Then
                S = "Select ParmValue from RunParms where Parm = 'OutlookDisabled' and UserID = '" + gCurrUserGuidID + "'"
            ElseIf ArchiveTypeCode.Equals("ALL") Then
                S = "Select ParmValue from RunParms where Parm = 'ckDisable' and UserID = '" + gCurrUserGuidID + "'"
            Else
                Return False
            End If

            Dim ParmVal As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                ParmVal = RSData.GetValue(0).ToString
                If ParmVal.ToUpper.Equals("TRUE") Then
                    b = True
                Else
                    b = False
                End If
            Else
                b = False
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR - isArchiveDisabled : ", ex)
            b = False
        End Try

        GC.Collect()
        GC.WaitForFullGCComplete()

        Return b

    End Function

    ''' <summary>
    ''' Writes the XML data.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="FQN">The FQN.</param>
    Public Sub WriteXMLData(ByVal TblName As String, ByVal FQN As String)
        getRepoConnStr()

        Dim S As String = "Select * from " + TblName

        Dim dsXmlData As New DataSet()

        Dim cn As New SqlConnection(gConnStr)
        Dim daTempData As New SqlDataAdapter(S, cn)

        ' Load data from database
        daTempData.Fill(dsXmlData, TblName)

        ' Write XML to file
        dsXmlData.WriteXml(FQN)

    End Sub

    ''' <summary>
    ''' Loads the rs from XML.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="FQN">The FQN.</param>
    Public Sub LoadRsFromXML(ByVal TblName As String, ByVal FQN As String)

        getRepoConnStr()
        Dim S As String = "Select * from " + TblName
        Dim daSvr As New SqlDataAdapter(S, gConn)

        Dim DsSvr As New DataSet
        daSvr.Fill(DsSvr, TblName)

        Dim dsXml As New DataSet()
        ' Read in XML from file
        dsXml.ReadXml(FQN)
        Dim iCols As Integer = DsSvr.Tables(0).Columns.Count

        Dim DT As DataTable
        DT = DsSvr.Tables(0)

        Dim myBuilder As SqlCommandBuilder = New SqlCommandBuilder(daSvr)
        myBuilder.GetUpdateCommand()
        daSvr.UpdateCommand = myBuilder.GetUpdateCommand()
        daSvr.InsertCommand = myBuilder.GetInsertCommand()
        If gClipBoardActive = True Then Console.WriteLine(myBuilder.GetUpdateCommand())
        If gClipBoardActive = True Then Console.WriteLine(daSvr.UpdateCommand.ToString)

        For I As Integer = 0 To dsXml.Tables(0).Rows.Count - 1
            Dim DR As DataRow = Nothing
            DR = DT.NewRow
            For II As Integer = 0 To iCols - 1
                DR(II) = dsXml.Tables(0).Rows(I).Item(II)
            Next
            DT.Rows.Add(DR)
            Try
                daSvr.Update(DsSvr, TblName)
            Catch ex As Exception
                If InStr(ex.Message.ToString, "duplicate key", CompareMethod.Text) > 0 Then
                    Console.WriteLine("ERROR clsDatabaseARCH:LoadRsFromXML - ", ex)
                Else
                    LOG.WriteToArchiveLog("ERROR clsDatabaseARCH:LoadRsFromXML - ", ex)
                End If

            End Try
            DR = Nothing
        Next
        daSvr.Update(DsSvr, TblName)
        daSvr.Dispose()
        daSvr = Nothing
    End Sub

    ''' <summary>
    ''' Fixes the identifier exists.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function FixIdExists(ByVal ID As Integer) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim B As Boolean = False

        S = S + " select count(*) from [DB_Updates] where FixID = " + ID.ToString

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            RSData.Read()
            cnt = RSData.GetInt32(0)
            RSData.Close()
            RSData = Nothing
            CMD.Connection.Close()
            CMD = Nothing
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If

        If cnt > 0 Then
            B = True
        Else
            B = False
        End If

        Return B
    End Function

    ''' <summary>
    ''' Initializes the service parameters.
    ''' </summary>
    Sub InitializeServiceParameters()

        Dim S As String = ""
        Dim B As Boolean = False

        B = SysParmExists("srv_LogDirectory")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_LogDirectory','Set to blank for default. Change where the service logs are written. This directory is relative to the SERVICE machine.','','Y')"
            B = ExecuteSqlNewConn(90113, S)
        End If

        B = SysParmExists("srv_DetailedLogging")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_DetailedLogging','When set to 0 no logging will be limited, when 1, full execution details will be logged.','0','Y')"
            B = ExecuteSqlNewConn(90114, S)
        End If

        B = SysParmExists("srv_MaxFileSize")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_MaxFileSize','When set to 0 no limit on upload file size, any other value set the max limit.','0','Y')"
            B = ExecuteSqlNewConn(90115, S)
        End If

        B = SysParmExists("srv_disable")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_disable','When set to anything other than 0 the ECM Service will continue to run but will NOT archive.','0','Y')"
            B = ExecuteSqlNewConn(90116, S)
        End If

        B = SysParmExists("srv_shutdown")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_shutdown','When set to 1, the service (next poll) will stop running.','0','Y')"
            B = ExecuteSqlNewConn(90117, S)
        End If

        B = SysParmExists("srv_PollingInterval")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_PollingInterval','This is the number of MINUTES between executing an archive.','60','Y')"
            B = ExecuteSqlNewConn(90118, S)
        End If

        B = SysParmExists("srv_ArchiveNow")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_ArchiveNow','Set this value to a 1 to set the archive state to immediate." ','0','Y')"
            B = ExecuteSqlNewConn(90119, S)
        End If

        B = SysParmExists("srv_LastArchive")
        If B = False Then
            S = "insert into SystemParms (SysParm,SysParmDesc,SysParmVal,flgActive)"
            S = S + " values ('srv_LastArchive','This is the datetime of the last completed archive.','" + Now.ToString + "','Y')"
            B = ExecuteSqlNewConn(90120, S)
        End If

    End Sub

    ''' <summary>
    ''' Systems the parm exists.
    ''' </summary>
    ''' <param name="ParmName">Name of the parm.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function SysParmExists(ByVal ParmName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim I As Integer = 0
        Dim ConnStr As String = getRepoConnStr()

        Try

            Dim S As String = "Select count(*) FROM [SystemParms] where [SysParm] = '" + ParmName + "'"
            Dim dsSharePoint As SqlDataReader = SqlQryNewConn(S, ConnStr)

            If dsSharePoint.HasRows Then
                dsSharePoint.Read()
                I = dsSharePoint.GetInt32(0)
                If I > 0 Then
                    B = True
                Else
                    B = False
                End If
            Else
                B = False
            End If

            dsSharePoint.Close()
            dsSharePoint = Nothing
        Catch ex As Exception
            B = False
            LOG.WriteToArchiveLog("SysParmExists: 100 - " + ex.Message + Environment.NewLine + ConnStr + Environment.NewLine)
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Adds the default retention code.
    ''' </summary>
    Sub AddDefaultRetentionCode()

        Dim UID As String = getUserGuidID("admin")
        Dim S As String = "INSERT INTO [Retention]"
        S = S + " ([RetentionCode]"
        S = S + " ,[RetentionDesc]"
        S = S + " ,[RetentionUnits]"
        S = S + " ,[RetentionAction]"
        S = S + " ,[ManagerID]"
        S = S + " ,[ManagerName])"
        S = S + " VALUES "
        S = S + " ('R-10'"
        S = S + " ,'Retain for 10 years.'"
        S = S + " ,10"
        S = S + " ,'Move'"
        S = S + " ,'admin'"
        S = S + " ,'admin')"
        Dim b As Boolean = ExecuteSqlNewConn(S, False)
    End Sub

    ''' <summary>
    ''' Updates the ip.
    ''' </summary>
    ''' <param name="HostName">Name of the host.</param>
    ''' <param name="IP">The ip.</param>
    ''' <param name="checkCode">The check code.</param>
    Sub updateIp(ByVal HostName As String, ByVal IP As String, ByVal checkCode As Integer)
        ' 0 = add if new 1 = update access count 2 = update search count 2 = update access count and
        ' search count
        Dim B As Boolean = False
        Dim S As String = ""
        If checkCode = 0 Then
            S = "Select count(*) from IP where HostName ='" + HostName + "' and AccessingIP = '" + IP + "'"
            Dim WC As String = "where  HostName ='" + HostName + "' and AccessingIP = '" + IP + "'"
            Dim iCnt As Integer = iGetRowCount("IP", WC)

            If iCnt = 0 Then
                S = "INSERT INTO [IP]"
                S = S + " (HostName, [AccessingIP]"
                S = S + " ,[AccessCnt]"
                S = S + " ,[BlockIP]"
                S = S + " ,[SearchCnt]"
                S = S + " ,[FirstAccessDate]"
                S = S + " ,[LastAccessDate])"
                S = S + " VALUES "
                S = S + " ('" + HostName + "', '" + IP + "'"
                S = S + " ,1"
                S = S + " ,0"
                S = S + " ,0"
                S = S + " ,'" + Now.ToString + "'"
                S = S + " ,'" + Now.ToString + "')"
                B = ExecuteSqlNewConn(90121, S)
                If B = False Then
                    Me.xTrace(952, "updateIp: Failed to add IP - " + IP, "updateIp")
                End If
            End If
        ElseIf checkCode = 1 Then
            S = "update [IP] set LastAccessDate = '" + Now.ToString + "', AccessCnt = AccessCnt + 1 where HostName ='" + HostName + "' and AccessingIP = '" + IP + "' "
            B = ExecuteSqlNewConn(90122, S)
            If B = False Then
                Me.xTrace(953, "updateIp: Failed to update IP - " + IP, "updateIp")
            End If
        ElseIf checkCode = 2 Then
            S = "update [IP] set LastAccessDate = '" + Now.ToString + "', SearchCnt = SearchCnt + 1 where HostName ='" + HostName + "' and AccessingIP = '" + IP + "' "
            B = ExecuteSqlNewConn(90123, S)
            If B = False Then
                Me.xTrace(954, "updateIp: Failed to add IP - " + IP, "updateIp")
            End If
        ElseIf checkCode = 3 Then
            S = "update [IP] set LastAccessDate = '" + Now.ToString + "', SearchCnt = SearchCnt + 1, AccessCnt = AccessCnt + 1 where HostName ='" + HostName + "' and AccessingIP = '" + IP + "' "
            B = ExecuteSqlNewConn(90124, S)
            If B = False Then
                Me.xTrace(955, "updateIp: Failed to add IP - " + IP, "updateIp")
            End If
        End If

    End Sub

    ''' <summary>
    ''' Updates the do not change help text.
    ''' </summary>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="ScreenName">Name of the screen.</param>
    ''' <param name="WidgetName">Name of the widget.</param>
    ''' <param name="WidgetText">The widget text.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateDoNotChangeHelpText(ByVal WhereClause As String, ByVal ScreenName As String, ByVal WidgetName As String, ByVal WidgetText As String) As Boolean

        Dim b As Boolean = False
        Dim s As String = ""

        If Len(WhereClause) = 0 Then Return False

        s = s + " update HelpText set "
        s = s + "ScreenName = '" + ScreenName + "'" + ", "
        s = s + "WidgetName = '" + WidgetName + "'" + ", "
        s = s + "WidgetText = '" + WidgetText + "'"
        WhereClause = " " + WhereClause
        s = s + WhereClause
        b = ExecuteSqlNewConn(s, False)

        Return b
    End Function

    ''' <summary>
    ''' Determines whether [is client only] [the specified user identifier].
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if [is client only] [the specified user identifier]; otherwise, <c>false</c>.</returns>
    Function isClientOnly(ByVal UserID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim S As String = "Select ClientOnly from Users where UserID = '" + UserID + "'"
        Try
            CloseConn()
            CkConn()

            Dim CMD As New SqlCommand(S, gConn)
            Dim RSData As SqlDataReader = Nothing

            Using gConn
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    RSData.Read()
                    Try
                        B = RSData.GetBoolean(0)
                    Catch ex As Exception
                        B = False
                    End Try
                    RSData.Close()
                    RSData = Nothing
                    CMD.Connection.Close()
                    CMD = Nothing
                Else
                    B = False
                End If

            End Using
            If Not RSData Is Nothing Then
                RSData = Nothing
            End If
            If Not CMD Is Nothing Then
                CMD = Nothing
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERR: isClientOnly - ", ex)
            LOG.WriteToArchiveLog("ERR: isClientOnly - " + ex.StackTrace)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Determines whether [is single instance].
    ''' </summary>
    ''' <returns><c>true</c> if [is single instance]; otherwise, <c>false</c>.</returns>
    Function isSingleInstance() As Boolean
        'select SysParmVal from SystemParms where SysParm = 'SYS_SingleInstance'
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim B As Boolean = False

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_SingleInstance' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim tVal As String = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
                B = False
                If tVal.Equals("Y") Or tVal.Equals("y") Then
                    B = True
                End If
                If tVal.Equals("1") Then
                    B = True
                End If
            Else
                B = False
            End If

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return B

    End Function

    ''' <summary>
    ''' Determines whether [is extended PDF processing].
    ''' </summary>
    ''' <returns><c>true</c> if [is extended PDF processing]; otherwise, <c>false</c>.</returns>
    Function isExtendedPdfProcessing() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'select SysParmVal from SystemParms where SysParm = 'SYS_SingleInstance'
        Dim S As String = ""
        Dim B As Boolean = True

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_EcmPDFX' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim tVal As String = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
                B = False
                If tVal.Equals("Y") Or tVal.Equals("y") Then
                    B = True
                End If
                If tVal.Equals("1") Then
                    B = True
                End If
            Else
                B = False
            End If

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return B

    End Function

    ''' <summary>
    ''' Gets the PDF processing dir.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getPdfProcessingDir() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'select SysParmVal from SystemParms where SysParm = 'SYS_SingleInstance'
        Dim S As String = ""
        Dim B As Boolean = True

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_EcmPDFdir' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                S = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
            Else
                B = False
            End If

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If

        If S.Length = 0 Then
            Dim InsertSql As String = ""
            InsertSql = "INSERT [dbo].[SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive], [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('SYS_EcmPDFdir', 'Set this as the temporary PDF/Graphics processing directory. NO SPACES ALLOWED IN NAME.', 'C:\TEMP\PdfProcessing\', NULL, NULL, NULL, NULL)"
            ExecuteSqlNewConn(90125, InsertSql)
            S = "C:\TEMP\PdfProcessing\"
        End If

        Return S

    End Function

    ''' <summary>
    ''' Determines whether [is public allowed].
    ''' </summary>
    ''' <returns><c>true</c> if [is public allowed]; otherwise, <c>false</c>.</returns>
    Function isPublicAllowed() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        Dim B As Boolean = False

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_AllowPublic' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim tVal As String = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
                B = False
                If tVal.Equals("Y") Or tVal.Equals("y") Then
                    B = True
                ElseIf tVal.Equals("1") Then
                    B = True
                Else
                    B = False
                End If
            Else
                B = True
            End If

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return B

    End Function

    ''' <summary>
    ''' Sets the maximum size of the file upload.
    ''' </summary>
    Sub setMaxFileUploadSize()

        Dim S As String = ""
        Dim B As Boolean = False

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_MaxFileSize' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing
        Dim MaxSize As Double = 0

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim tVal As String = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
                gMaxSize = CInt(tVal)
            End If
        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        CloseConn()

    End Sub

    ''' <summary>
    ''' Shows the graphic meta data screen.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ShowGraphicMetaDataScreen() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'select SysParmVal from SystemParms where SysParm = 'SYS_SingleInstance'
        Dim S As String = ""
        Dim B As Boolean = False

        S = S + " select SysParmVal from SystemParms where SysParm = 'SYS_EmbededJPGMetadata' "

        CloseConn()
        CkConn()

        Dim cnt As Integer = -1
        Dim CMD As New SqlCommand(S, gConn)
        Dim RSData As SqlDataReader = Nothing

        Using gConn
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                Dim tVal As String = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                CMD.Connection.Close()
                CMD = Nothing
                B = False
                If tVal.Equals("Y") Or tVal.Equals("y") Then
                    B = True
                End If
                If tVal.Equals("1") Then
                    B = True
                End If
            Else
                B = False
            End If

        End Using
        If Not RSData Is Nothing Then
            RSData = Nothing
        End If
        If Not CMD Is Nothing Then
            CMD = Nothing
        End If
        Return B

    End Function

    'Sub LoadDefaultSystemParms()
    '    Dim S  = ""
    '    Dim I As Integer = 0

    ' S = "Select count(*) from SystemParms where SysParm = 'Default Thesaurus'" I = iCount(S) If I =
    ' 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('MaxUrlsToProcess', 'The number of
    ' levels to penetrate in a web site.', '2', NULL, NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90126,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'EmailFolder1'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('Default Thesaurus', 'This is the
    ' thesaurus that will be used when a specific thesaurus is not specified.', 'Roget', NULL, NULL,
    ' NULL, NULL)" Me.ExecuteSqlNewConn(90127,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'MaxSearchesToTrack'" I = iCount(S) If I
    ' = 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('RETENTION YEARS', 'The default number
    ' years to retain content.', '10', 'N', NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90128,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'MaxUrlsToProcess'" I = iCount(S) If I =
    ' 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('EmailFolder1', 'This is the Top Level
    ' folder name and is required. It can be overridden for an individual user using the APP.CONFIG
    ' file, entry name EmailFolder1', 'Personal Folders', 'Y', NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90129,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'RETENTION YEARS'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('SharePointVirtualLimit', 'When there
    ' are less records than this number, then a linked list is used for PURE speed.', '100001', 'Y',
    ' NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90130,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'SharePointECMVirtualLimit'" I =
    ' iCount(S) If I = 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc],
    ' [SysParmVal], [flgActive], [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES
    ' ('SharePointECMVirtualLimit', 'When there are less records than this number, then a linked list
    ' is used for PURE speed.', '1000001', 'Y', NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90131,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'SharePointVirtualLimit'" I = iCount(S)
    ' If I = 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal],
    ' [flgActive], [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('srv_disable', 'When set
    ' to anything other than 0 the ECM Service will continue to run but will NOT archive.', '0', 'Y',
    ' NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90132,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'SqlServerTimeout'" I = iCount(S) If I =
    ' 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('srv_PollingInterval', 'This is the
    ' number of MINUTES between executing an archive.', '60', 'Y', NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90133,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'srv_disable'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('srv_LastArchive', 'This is the
    ' datetime of the last completed archive.', '10/22/2009 7:58:57 PM', 'Y', NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90134,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'srv_LastArchive'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('MaxSearchesToTrack', 'The number of
    ' searches the user has in their immediate history.', '25', NULL, NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90135,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'srv_PollingInterval'" I = iCount(S) If I
    ' = 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('SqlServerTimeout', 'This is the value
    ' that will be assigned to the SQL Server timeout for users that do not have a specific timeout
    ' established.', '90', NULL, NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90136,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'srv_shutdown'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('srv_shutdown', 'When set to 1, the
    ' service (next poll) will stop running.', '0', 'Y', NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90137,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'SYS_SingleInstance'" I = iCount(S) If I
    ' = 0 Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('SYS_SingleInstance', 'When set to 1,
    ' ECM will store just 1 copy of an archive.', '0', NULL, NULL, NULL, NULL)"
    ' Me.ExecuteSqlNewConn(90138,S) End If

    ' S = "Select count(*) from SystemParms where SysParm = 'SYS_AllowPublic'" I = iCount(S) If I = 0
    ' Then S = " INSERT into [SystemParms] ([SysParm], [SysParmDesc], [SysParmVal], [flgActive],
    ' [isDirectory], [isEmailFolder], [flgAllSubDirs]) VALUES ('SYS_AllowPublic', 'When set to 1, ECM
    ' will allow a user to set their content so it can be viewed by all users, otherwise, only they
    ' can see their content.', '0', NULL, NULL, NULL, NULL)" Me.ExecuteSqlNewConn(90139,S) End If

    'End Sub

    ''' <summary>
    ''' Gets the container unique identifier.
    ''' </summary>
    ''' <param name="ContainerName">Name of the container.</param>
    ''' <returns>Guid.</returns>
    Function getContainerGuid(ContainerName As String) As Guid
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ContainerName = Mid(ContainerName, 1, 449)
        ContainerName = UTIL.RemoveSingleQuotes(ContainerName)

        Dim S As String = "Select ContainerGuid from Container where ContainerName = '" + ContainerName + "' "
        Dim S2 As String = "Select Count(*) from Container where ContainerName = '" + ContainerName + "' "
        Dim TgtGuid As Guid

        Dim iCnt As Integer = iCount(S2)
        If iCnt = 0 Then
            TgtGuid = Guid.NewGuid()
            S2 = "INSERT INTO [Container]([ContainerGuid],[ContainerName])VALUES('" + TgtGuid.ToString + "', '" + ContainerName + "')"
            Dim B As Boolean = ExecuteSqlNewConn(90140, S2)
            If B = False Then
                Return Nothing
            End If
        End If

        Try

            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            TgtGuid = rsData.GetGuid(0)
            rsData.Close()
            rsData = Nothing
        Catch ex As Exception
            ' xTrace(12455, "clsDataBase:getContainerGuid" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getContainerGuid : 4445 : ", ex)
            TgtGuid = Nothing
        End Try

        Return TgtGuid
    End Function

    ''' <summary>
    ''' Saves the content container.
    ''' </summary>
    ''' <param name="ContainerGuid">The container unique identifier.</param>
    ''' <param name="ContentUserRowGuid">The content user row unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function SaveContentContainer(ContainerGuid As Guid, ContentUserRowGuid As Guid) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = True
        Dim S As String = ""

        If ContainerGuid.Equals(ContainerGuid.Empty) Then
            'LOG.WriteToArchiveLog("NOTICE SaveContentContainer 77342.A1 - ContainerGuid is EMPTY.")
            Return False
        End If
        If ContentUserRowGuid.Equals(ContentUserRowGuid.Empty) Then
            'LOG.WriteToArchiveLog("NOTICE SaveContentContainer 77342.A2 - ContentUserRowGuid is EMPTY.")
            Return False
        End If
        Try
            S += " if not exists (select ContainerGuid from [ContentContainer] where [ContentUserRowGuid] = '" + ContentUserRowGuid.ToString + "' and [ContainerGuid] = '" + ContainerGuid.ToString + "')" + Environment.NewLine
            S += " begin " + Environment.NewLine
            S += " INSERT INTO [ContentContainer]" + Environment.NewLine
            S += " ([ContentUserRowGuid]" + Environment.NewLine
            S += " ,[ContainerGuid])" + Environment.NewLine
            S += " VALUES " + Environment.NewLine
            S += " ('" + ContentUserRowGuid.ToString + "'" + Environment.NewLine
            S += " ,'" + ContainerGuid.ToString + "')" + Environment.NewLine
            S += " END" + Environment.NewLine

            B = ExecuteSqlNewConn(90141, S)

            If Not B Then
                LOG.WriteToArchiveLog("ERROR SaveContentContainer 77342.B - Failed to insert content container: " + Environment.NewLine + S)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR SaveContentContainer 77342.C - Failed to insert content container: " + Environment.NewLine + S)
        End Try


        Return B

    End Function

    ''' <summary>
    ''' Saves the content owner.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="ContentTypeCode">The content type code.</param>
    ''' <param name="ContainerName">Name of the container.</param>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="NetworkName">Name of the network.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function saveContentOwner(ByVal ContentGuid As String,
                              ByVal UserID As String,
                              ContentTypeCode As String,
                              ContainerName As String,
                              MachineName As String,
                              NetworkName As String) As Boolean

        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'AddHandler currDomain.UnhandledException, AddressOf MYExnHandler
        'AddHandler Application.ThreadException, AddressOf MYThreadHandler

        Dim iCnt As Integer = 0
        Dim S As String = ""
        Dim MachineGuid As String = """"
        Dim ContainerGuid As Guid = Nothing
        Dim contentUserRowGuid As Guid = Nothing
        Dim BB As Boolean = SaveContentContainer(ContainerGuid, contentUserRowGuid)

        Try
            If Not slMachineNetwork.ContainsKey(MachineName + "|" + NetworkName) Then
                MachineGuid = MachineRegister(MachineName, NetworkName)
                slMachineNetwork.Add(MachineName + "|" + NetworkName, MachineGuid)
            Else
                MachineGuid = slMachineNetwork(MachineName + "|" + NetworkName)
            End If

            If Not slContainerGuid.ContainsKey(ContainerName) Then
                ContainerGuid = getContainerGuid(ContainerName)
                slContainerGuid.Add(ContainerName, ContainerGuid)
            Else
                ContainerGuid = getContainerGuid(ContainerName)
            End If

            S = "Select count(*) from ContentUser where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "'"
            iCnt = iCount(S)

            If iCnt = 0 Then
                Try
                    S = "INSERT INTO [ContentUser] ([ContentGuid] ,[UserID], ContentTypeCode, NbrOccurances) VALUES ('" + ContentGuid + "' ,'" + UserID + "' ,'" + ContentTypeCode + "', 1)"
                    Dim B As Boolean = ExecuteSqlNewConn(90142, S)
                    If Not B Then
                        ' xTrace(88652, "saveContentOwner", "ERROR: AddContentOwner - " + environment.NewLine + S)
                        LOG.WriteToArchiveLog("ERROR: AddContentOwner 00 - " + S)
                    Else
                        saveMachine(MachineGuid, ContentGuid, UserID)
                    End If
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR: AddContentOwner - ", ex)
                End Try
            Else
                Try
                    S = "update [ContentUser] set nbrOccurances = nbrOccurances + 1, LastAdded = getdate() where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "'"
                    Dim B As Boolean = ExecuteSqlNewConn(90142, S)
                    If Not B Then
                        ' xTrace(88652, "saveContentOwner", "ERROR: AddContentOwner 01 - " + environment.NewLine + S)
                        LOG.WriteToArchiveLog("ERROR: AddContentOwner - " + S)
                    Else
                        saveMachine(MachineGuid, ContentGuid, UserID)
                    End If
                Catch ex As Exception
                    LOG.WriteToArchiveLog("Error 100 - CLSDBARCH : saveContentOwner: ", ex)
                    LOG.WriteToArchiveLog("Error 101 - CLSDBARCH : saveContentOwner: " + ex.StackTrace)
                End Try
            End If

            contentUserRowGuid = getContentUserGuid(ContentGuid, UserID)
            BB = SaveContentContainer(ContainerGuid, contentUserRowGuid)

            Return BB
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error 200 - CLSDBARCH : saveContentOwner: ", ex)
            LOG.WriteToArchiveLog("Error 201 - CLSDBARCH : saveContentOwner: " + ex.StackTrace)
        End Try

        'RemoveHandler currDomain.UnhandledException, AddressOf MYExnHandler
        'RemoveHandler Application.ThreadException, AddressOf MYThreadHandler

    End Function

    ''' <summary>
    ''' Saves the machine by name and the associated peice of content on that machine.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="SourceGuid">The source GUID.</param>
    ''' <param name="UserID">The user ID.</param>
    Sub saveMachine(MachineName As String, SourceGuid As String, UserID As String)

        Dim MySql As String = ""

        MySql += "  if NOT exists (Select MachineName from Machine " + Environment.NewLine
        MySql += "      where MachineName = '" + MachineName + "' " + Environment.NewLine
        MySql += "      and SourceGuid = '" + SourceGuid + "' " + Environment.NewLine
        MySql += "      and UserID = '" + UserID + "')" + Environment.NewLine
        MySql += "  Begin " + Environment.NewLine
        MySql += "      INSERT INTO [Machine] (SourceGuid, MachineName, UserID) VALUES ('" + SourceGuid + "','" + MachineName + "', '" + UserID + "' )" + Environment.NewLine
        MySql += "  End" + Environment.NewLine

        Dim BB As Boolean = ExecuteSqlNewConn(90143, MySql)

        If Not BB Then
            ' xTrace(334561, "SaveMachine", "ERRROR 77623.11 - Failed to add Machine: " + environment.NewLine + MySql)
            LOG.WriteToArchiveLog("ERRROR 77623.11 - Failed to add Machine.")
        End If

    End Sub

    ''' <summary>
    ''' Gets the content GUID based on the name of the File/Email and the HASH code.
    ''' </summary>
    ''' <param name="SourceName">Name of the source document.</param>
    ''' <param name="CrcHash">The CRC hash.</param>
    ''' <returns>System.String.</returns>
    Function getContentGuid(SourceName As String, CrcHash As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        SourceName = UTIL.RemoveSingleQuotes(SourceName)
        Dim S As String = "Select SourceGuid from DataSource where SourceName = '" + SourceName + "' and CRC = " + CrcHash + " "
        Dim TgtGuid As String = ""

        Try

            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()
            If rsData.HasRows Then
                rsData.Read()
                TgtGuid = rsData.GetString(0)
            End If
            rsData.Close()
            rsData = Nothing
        Catch ex As Exception
            ' xTrace(12455, "clsDataBase:getContentUserGuid" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getContentUserGuid : 4445 : ", ex)
            TgtGuid = Nothing
        End Try

        Return TgtGuid
    End Function

    ''' <summary>
    ''' Gets the content user unique identifier.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>Guid.</returns>
    Function getContentUserGuid(ContentGuid As String, UserID As String) As Guid
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select ContentUserRowGuid from ContentUser where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "' "
        Dim TgtGuid As Guid

        Try

            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            rsData.Read()
            TgtGuid = rsData.GetGuid(0)
            rsData.Close()
            rsData = Nothing
        Catch ex As Exception
            ' xTrace(12455, "clsDataBase:getContentUserGuid" + ex.Message)
            LOG.WriteToArchiveLog("clsDatabaseARCH : getContentUserGuid : 4445 : ", ex)
            TgtGuid = Nothing
        End Try

        Return TgtGuid
    End Function

    ''' <summary>
    ''' Contents the owner exists.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ContentOwnerExists(ByVal ContentGuid As String, ByVal UserID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim iCnt As Integer = 0
        Dim S As String = ""

        S = "Select count(*) from ContentUser where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "'"
        iCnt = iCount(S)

        If iCnt = 0 Then
            Return False
        Else
            Return True
        End If

    End Function

    ''' <summary>
    ''' Synchronizes the source owners.
    ''' </summary>
    Sub SyncSourceOwners()

        Dim SqlStmts As New List(Of String)

        Dim S As String = "Select Count(*) from DataSource"
        Dim iCnt As Integer = iCount(S)
        Dim I As Integer = 0
        'frmreconMain.SB.Text = "0 of " + iCnt.ToString

        S = "Select SourceGuid, DataSourceOwnerUserID from DataSource where [SourceGuid] not in (Select SourceGuid from [ContentUser]) "

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                I += 1
                If I Mod 100 = 0 Then
                    'frmreconMain.SB.Text = I.ToString + " of " + iCnt.ToString
                    ''FrmMDIMain.Refresh()
                    Application.DoEvents()
                End If
                Dim SourceGuid As String = RSData.GetValue(0).ToString
                Dim DataSourceOwnerUserID As String = RSData.GetValue(0).ToString
                'Dim B As Boolean = ContentOwnerExists(SourceGuid , gCurrUserGuidID)
                'If Not B Then
                S = "INSERT INTO [ContentUser] ([ContentGuid] ,[UserID], NbrOccurances) VALUES ('" + SourceGuid + "' ,'" + DataSourceOwnerUserID + "', 1)"
                SqlStmts.Add(S)
                'End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        For I = 0 To SqlStmts.Count - 1
            If I Mod 100 = 0 Then
                'frmreconMain.SB.Text = "+ " + I.ToString + " of " + iCnt.ToString
                ''FrmMDIMain.Refresh()
                Application.DoEvents()
            End If
            S = SqlStmts(I)
            Dim B As Boolean = ExecuteSqlNewConn(90144, S)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: SyncSourceOwners - " + S)
            End If
        Next

    End Sub

    ''' <summary>
    ''' Cks the run at start up.
    ''' </summary>
    Sub ckRunAtStartUp()

        Dim C As String = ""
        Dim RunAtStart As Boolean = False

        C = getRconParm(gCurrUserGuidID, "LoadAtStartup")
        If C.Length > 0 Then
            If C.Equals("True") Then
                RunAtStart = True
            ElseIf C.Equals("False") Then
                RunAtStart = False
            Else
                Return
            End If
            Try
                Dim aPath As String = ""
                aPath = System.Reflection.Assembly.GetExecutingAssembly.Location
                If RunAtStart Then
                    Dim oReg As RegistryKey = Registry.CurrentUser
                    'Dim oKey As RegistryKey = oReg.OpenSubKey("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run", True)
                    Dim oKey As RegistryKey = oReg.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run", True)
                    oKey.CreateSubKey("EcmLibrary")
                    oKey.SetValue("EcmLibrary", aPath)
                    oKey.Close()
                Else
                    Dim oReg As RegistryKey = Registry.CurrentUser
                    Dim oKey As RegistryKey = oReg.OpenSubKey("Software\Microsoft\Windows\CurrentVersion\Run", True)
                    oKey.CreateSubKey("EcmLibrary")
                    oKey.SetValue("EcmLibrary", "")
                    oKey.DeleteSubKey("EcmLibrary")
                    oKey.Close()
                End If
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR ckRunAtStartUp 102.22.1 - Failed to set start up parameter." + Environment.NewLine + ex.Message)
            End Try
        End If
    End Sub

    ''' <summary>
    ''' Registers the machine to database.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    Public Sub RegisterMachineToDB(ByVal MachineName As String)
        MachineName = UTIL.RemoveSingleQuotes(MachineName)
        Dim iCnt As Integer = iGetRowCount("MachineRegistered", " Where MachineName = '" + MachineName + "' ")
        If iCnt = 0 Then
            Dim S As String = ""
            Dim B As Boolean = False
            S = "Insert into MachineRegistered (MachineName,CreateDate,LastUpdate) values ('" + MachineName + "', '" + Now.ToString + "', '" + Now.ToString + "')"
            B = ExecuteSqlNewConn(90145, S)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR RegisterMachineToDB 100 - Failed to add machine ID." + Environment.NewLine + S)
            End If
        End If

    End Sub

    ''' <summary>
    ''' Determines whether [is machine registered] [the specified machine name].
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <returns><c>true</c> if [is machine registered] [the specified machine name]; otherwise, <c>false</c>.</returns>
    Public Function isMachineRegistered(ByVal MachineName As String) As Boolean
        MachineName = UTIL.RemoveSingleQuotes(MachineName)
        Dim iCnt As Integer = iGetRowCount("MachineRegistered", " Where MachineName = '" + MachineName + "' ")
        If iCnt = 0 Then
            Return False
        Else
            Return True
        End If
    End Function

    ''' <summary>
    ''' Registers the ecm client.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    Sub RegisterEcmClient(ByVal MachineName As String)
        Dim iCnt As Integer = 0

        MachineName = UTIL.ReplaceSingleQuotes(MachineName)

        iCnt = Me.iCount("Select count(*) from LoginClient where MachineName = '" + MachineName + "'")
        If iCnt = 0 Then
            Dim S As String = "Insert into LoginClient (MachineName) values ('" + MachineName + "') "
            Dim B As Boolean = Me.ExecuteSqlNewConn(90146, S)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: RegisterEcmClient - Failed to register client for " + MachineName + ".")
            End If
        End If
    End Sub

    ''' <summary>
    ''' Determines whether [is dir admin disabled] [the specified user identifier].
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if [is dir admin disabled] [the specified user identifier]; otherwise, <c>false</c>.</returns>
    Function isDirAdminDisabled(ByVal UserID As String, ByVal FQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim B As Boolean = False
        Try
            Dim S As String = "Select count(*) from Directory where UserID = '" + UserID + "' and FQN = '" + FQN + "' and AdminDisabled = 1"
            Dim I As Integer = Me.iCount(S)
            If I >= 1 Then
                B = True
            Else
                B = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR clsDatabaseARCH:isDirAdminDisabled 100 - ", ex)
            B = False
        End Try
        Return B
    End Function

    ''' <summary>
    ''' Gets the folder name by identifier.
    ''' </summary>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <returns>System.String.</returns>
    Public Function getFolderNameById(ByVal FolderID As String) As String
        Dim b As Boolean = True
        Dim S As String = ""
        S = "Select [FolderName]      "
        S = S + " FROM [EmailFolder]"
        S = S + " where [FolderID] = '" + FolderID + "' and Userid = '" + gCurrUserGuidID + "' "
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        rsData = command.ExecuteReader()

        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()
        'log.WriteToArchiveLog("*** FOLDER NOTICE getFolderNameById ID 001z - : " + id + environment.NewLine + S)
        Return id
    End Function

    ''' <summary>
    ''' Gets the name of the folder identifier by.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="UID">The uid.</param>
    ''' <returns>System.String.</returns>
    Public Function getFolderIdByName(ByVal FolderName As String, ByVal UID As String) As String

        FolderName = UTIL.RemoveSingleQuotes(FolderName)

        Dim b As Boolean = True
        Dim S As String = ""
        S = "Select [FolderID]      "
        S = S + " FROM [EmailFolder]"
        S = S + " where [FolderName] = '" + FolderName + "' and UserID = '" + UID + "' "
        Dim i As Integer = 0
        Dim id As String = ""

        Dim rsData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
        If rsData.HasRows Then
            rsData.Read()
            id = rsData.GetValue(0).ToString
        Else
            id = ""
        End If

        rsData.Close()
        rsData = Nothing

        Return id

    End Function

    ''' <summary>
    ''' Removes the library directories.
    ''' </summary>
    ''' <param name="DirectoryName">Name of the directory.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    Sub RemoveLibraryDirectories(ByVal DirectoryName As String, ByVal LibraryName As String)

        DirectoryName = UTIL.RemoveSingleQuotes(DirectoryName)

        Dim s As String = ""
        s = s + " select count(*) from LibraryItems"
        s = s + " where LibraryName = '" + LibraryName + "'"
        s = s + " and SourceGuid in (select SourceGuid from DataSource where FileDirectory = '" + DirectoryName + "')"

        Dim icnt As Integer = iCount(s)
        If icnt = 0 Then
            MessageBox.Show("No archived DOCUMENTS associated with Library '" + LibraryName + "/" + DirectoryName + "', returning.")
        Else
            MessageBox.Show("There are " + icnt.ToString + " DOCUMENTS associated with Library '" + LibraryName + "/" + DirectoryName + "', removing the association.")
        End If

        LOG.WriteToArchiveLog("INFO RemoveLibraryDirectories: removed " + icnt.ToString + " rows from directory " + DirectoryName + " in library " + LibraryName + ".")

        Dim ULogin As String = Me.getUserLoginByUserid(gCurrUserGuidID)

        s = ""
        s = s + " DELETE FROM LibraryItems "
        s = s + " where LibraryName = '" + LibraryName + "'"
        s = s + " and SourceGuid in (select SourceGuid from DataSource where FileDirectory = '" + DirectoryName + "')"

        Dim B As Boolean = ExecuteSqlNewConn(90147, s)
        If B = True Then
            Dim Msg As String = "Notice: Directory '" + DirectoryName + "' was removed from library '" + LibraryName + "' by User '" + ULogin + "'"
            LOG.WriteToArchiveLog(Msg)
            AddSysMsg(Msg)
        Else
            Dim Msg As String = "Notice: Directory '" + DirectoryName + "' FAILED to remove from library '" + LibraryName + "' by User '" + ULogin + "'"
            LOG.WriteToArchiveLog(Msg)
            AddSysMsg(Msg)
        End If
    End Sub

    ''' <summary>
    ''' Removes the library emails.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <param name="UserID">The user identifier.</param>
    Sub RemoveLibraryEmails(ByVal FolderName As String, ByVal LibraryName As String, ByVal UserID As String)

        Dim s As String = ""
        Dim CurrentmailFolderID As String = getFolderIdByName(FolderName, UserID)

        s = s + " select count(*) from LibraryItems"
        s = s + " where LibraryName = '" + LibraryName + "'"
        s = s + " and SourceGuid in (select EmailGuid from Email where OriginalFolder = '" + FolderName + "')"

        Dim icnt As Integer = iCount(s)
        If icnt = 0 Then
            MessageBox.Show("No archived emails associated with Library '" + LibraryName + "/" + FolderName + "', returning.")
        Else
            MessageBox.Show("There are " + icnt.ToString + " emails associated with Library '" + LibraryName + "/" + FolderName + "', removing the association.")
        End If

        LOG.WriteToArchiveLog("INFO: RemoveLibraryEmails removed " + icnt.ToString + " records from email folder + " + FolderName + " and Library " + LibraryName + ".")

        s = ""
        s = s + " delete from LibraryItems"
        s = s + " where LibraryName = '" + LibraryName + "'"
        s = s + " and SourceGuid in (select EmailGuid from Email where OriginalFolder = '" + FolderName + "')"

        Dim B As Boolean = ExecuteSqlNewConn(90148, s)

        If B = True Then
            Dim Msg As String = "Notice: EMAIL Folder '" + FolderName + "' was removed from library '" + LibraryName + "' by User '" + UserID + "'"
            LOG.WriteToArchiveLog(Msg)
            AddSysMsg(Msg)
        Else
            Dim Msg As String = "Notice: EMAIL Folder '" + FolderName + "' - FAILED to remove from library '" + LibraryName + "' by User '" + UserID + "'"
            LOG.WriteToArchiveLog(Msg)
            AddSysMsg(Msg)
        End If

    End Sub

    ''' <summary>
    ''' Adds the library directory.
    ''' </summary>
    ''' <param name="FolderName">Name of the folder.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RecordsAdded">The records added.</param>
    ''' <param name="bAddSubDir">if set to <c>true</c> [b add sub dir].</param>
    Sub AddLibraryDirectory(ByVal FolderName As String, ByVal LibraryName As String, ByVal UserID As String, ByRef RecordsAdded As Integer, ByVal bAddSubDir As Boolean)
        'select sourceguid,SourceName,OriginalFileType from DataSource where FileDirectory = 'c:\temp'
        RecordsAdded = 0
        Dim s As String = "Select count(*) from DataSource where FileDirectory = '" + FolderName + "' and DataSourceOwnerUserID = '" + UserID + "' "

        If bAddSubDir Then
            s = "Select count(*) from DataSource where FileDirectory like '" + FolderName + "%' and DataSourceOwnerUserID = '" + UserID + "' "
        Else
            s = "Select count(*) from DataSource where FileDirectory = '" + FolderName + "' and DataSourceOwnerUserID = '" + UserID + "' "
        End If

        Dim iCnt As Integer = Me.iCount(s)
        If iCnt = 0 Then
            Return
        End If

        If bAddSubDir Then
            s = "Select sourceguid,SourceName,OriginalFileType from DataSource where FileDirectory like '" + FolderName + "%' and DataSourceOwnerUserID = '" + UserID + "' "
        Else
            s = "Select sourceguid,SourceName,OriginalFileType from DataSource where FileDirectory = '" + FolderName + "' and DataSourceOwnerUserID = '" + UserID + "' "
        End If

        '  Select [SourceGuid]
        ',[SourceName]
        ',[ItemType]
        ',[LibraryItemGuid]
        ',[DataSourceOwnerUserID]
        ',[LibraryOwnerUserID]
        ',[LibraryName]
        ',[AddedByUserGuidId]

        Dim SourceName As String = ""
        Dim ItemType As String = ""
        Dim LibraryItemGuid As String = ""
        Dim LibraryOwnerUserID As String = GetLibOwnerByName(LibraryName)
        Dim AddedByUserGuidId As String = gCurrUserGuidID
        Dim DataSourceOwnerUserID As String = UserID

        Dim SourceGuid As String = ""
        Dim OriginalFileType As String = ""
        Dim i As Integer = 0
        Dim RSData As SqlDataReader = Nothing

        Dim TempDirName As String = DMA.getEnvVarTempDir
        Dim TempFQN As String = TempDirName + "\AddLibItems.txt"

        Dim F As File
        If File.Exists(TempFQN) Then
            File.Delete(TempFQN)
        End If
        F = Nothing

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(s, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            Do While RSData.Read()
                Application.DoEvents()
                i += 1
                If i Mod 2 = 0 Then
                    frmLibraryAssignment.SB.Text = i.ToString + " of " + iCnt.ToString
                    ''FrmMDIMain.Refresh()
                    Application.DoEvents()
                End If

                SourceGuid = RSData.GetValue(0).ToString
                SourceName = RSData.GetValue(1).ToString
                OriginalFileType = RSData.GetValue(2).ToString
                ItemType = OriginalFileType
                LibraryItemGuid = Guid.NewGuid.ToString

                Dim sData As String = SourceGuid
                sData += Chr(254) + SourceName
                sData += Chr(254) + ItemType
                sData += Chr(254) + LibraryItemGuid
                sData += Chr(254) + DataSourceOwnerUserID
                sData += Chr(254) + LibraryOwnerUserID
                sData += Chr(254) + LibraryName
                sData += Chr(254) + AddedByUserGuidId

                LOG.WriteToTempFile(TempFQN, sData)

            Loop
        End If
        RSData.Close()
        RSData = Nothing

        Dim iRecCount As Integer = 0
        Dim objReaderCtr As New System.IO.StreamReader(TempFQN)
        Do While objReaderCtr.Peek() <> -1
            Dim TextLine As String = objReaderCtr.ReadLine()
            iRecCount += 1
            If i Mod 2 = 0 Then
                frmLibraryAssignment.SB.Text = "Pass #2: " + i.ToString + " of " + iCnt.ToString
                ''FrmMDIMain.Refresh()
                Application.DoEvents()
            End If
        Loop

        objReaderCtr = Nothing

        ''FrmMDIMain.TSPB1.Minimum = 0
        ''FrmMDIMain.TSPB1.Maximum = iRecCount + 10
        ''FrmMDIMain.SB.Text = "Remaining to validate: " + iRecCount.ToString

        Dim LI As New clsLIBRARYITEMS

        i = 0
        Dim objReader As New System.IO.StreamReader(TempFQN)
        Do While objReader.Peek() <> -1

            If gTerminateImmediately = True Then
                Return
            End If

            i += 1
            ''FrmMDIMain.SB4.Text = i.ToString
            Application.DoEvents()

            If i Mod 2 = 0 Then
                frmLibraryAssignment.SB.Text = "Pass #3: " + i.ToString + " of " + iCnt.ToString
                ''FrmMDIMain.Refresh()
                Application.DoEvents()
            End If

            Dim TextLine As String = objReader.ReadLine()
            If TextLine.Length = 0 Then
                GoTo NextRec
            End If

            Dim A As String() = TextLine.Split(Chr(254))

            If A.Length < 2 Then
                GoTo NextRec
            End If

            SourceGuid = A(0)
            SourceName = A(1)
            ItemType = A(2)
            LibraryItemGuid = A(3)
            DataSourceOwnerUserID = A(4)
            LibraryOwnerUserID = A(5)
            LibraryName = A(6)
            AddedByUserGuidId = A(7)

            RecordsAdded += 1
            s = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "'"
            iCnt = iCount(s)

            If iCnt = 0 Then
                LI.setAddedbyuserguidid(AddedByUserGuidId)
                LI.setDatasourceowneruserid(DataSourceOwnerUserID)
                LI.setItemtitle(SourceName)
                LI.setItemtype(ItemType)
                LI.setLibraryitemguid(LibraryItemGuid)
                LI.setLibraryname(LibraryName)
                LI.setLibraryowneruserid(LibraryOwnerUserID)
                LI.setSourceguid(SourceGuid)
                Dim b As Boolean = LI.Insert
                If Not b Then
                    LOG.WriteToArchiveLog("ERROR: Failed to add Library Item Directory: '" + FolderName + "', Library: '" + LibraryName + "', SourceName: '" + SourceName + "'")
                End If
            End If
NextRec:
        Loop

        objReader = Nothing

        LI = Nothing
        GC.Collect()

        s = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "'"
        iCnt = iCount(s)

        ''FrmMDIMain.SB.Text = "Library additions: " + iCnt.ToString + " added."
        ''FrmMDIMain.SB4.Text = ""
        frmLibraryAssignment.SB.Text = "Library additions complete: " + iCnt.ToString + " added."
        frmLibraryAssignment.SB.Text = "Done: " + i.ToString + " of " + iCnt.ToString
    End Sub

    ''' <summary>
    ''' Adds the library email.
    ''' </summary>
    ''' <param name="EmailFolder">The email folder.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RecordsAdded">The records added.</param>
    Sub AddLibraryEmail(ByVal EmailFolder As String, ByVal LibraryName As String, ByVal UserID As String, ByVal RecordsAdded As Integer)

        Dim CurrentmailFolderID As String = getFolderIdByName(EmailFolder, UserID)

        'select emailguid, SUBSTRING(subject,1,100) as Subject, sourcetypecode from Email where Currmailfolderid  = '00000000AE37B53150C4EF4991D438C857CB5B08A2B40000'
        Dim s As String = "Select count(*) from Email where OriginalFolder  = '" + EmailFolder + "'"
        s = ""
        s = s + " select count(*) "
        s = s + " from Email where OriginalFolder  = '" + EmailFolder + "'"
        s = s + " and Email.UserID in (select UserID from LibraryUsers where LibraryName = '" + LibraryName + "')"

        Dim iCnt As Integer = Me.iCount(s)
        If iCnt = 0 Then
            frmLibraryAssignment.SB.Text = "Done."
            frmLibraryAssignment.SB.Refresh()
            Return
        End If

        s = "Select emailguid, SUBSTRING(subject,1,100) as Subject, SUBSTRING(body,1,100) as Body, sourcetypecode from Email where OriginalFolder  = '" + EmailFolder + "'"

        s = ""
        s = s + " select emailguid, SUBSTRING(subject,1,100) as Subject, SUBSTRING(body,1,100) as Body, sourcetypecode "
        s = s + " from Email where OriginalFolder  = '" + EmailFolder + "'"
        s = s + " and Email.UserID in (select UserID from LibraryUsers where LibraryName = '" + LibraryName + "')"

        Dim SourceName As String = ""
        Dim ItemType As String = ""
        Dim LibraryItemGuid As String = ""
        Dim LibraryOwnerUserID As String = GetLibOwnerByName(LibraryName)
        Dim AddedByUserGuidId As String = gCurrUserGuidID
        Dim DataSourceOwnerUserID As String = UserID
        Dim Body As String = ""

        Dim EmailGuid As String = ""
        Dim OriginalFileType As String = ""
        Dim i As Integer = 0
        Dim RSData As SqlDataReader = Nothing

        Dim TempDirName As String = DMA.getEnvVarTempDir
        Dim TempFQN As String = TempDirName + "\AddLibItems.txt"

        Dim F As File
        If File.Exists(TempFQN) Then
            Try
                File.Delete(TempFQN)
            Catch ex As Exception
                LOG.WriteToArchiveLog("Warning: could not delete " + TempFQN + "." + Environment.NewLine + ex.Message)
            End Try
        End If
        F = Nothing

        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(s, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()

                i += 1
                If i Mod 5 = 0 Then
                    frmLibraryAssignment.SB.Text = "Applied: " + i.ToString + " of " + iCnt.ToString
                    frmLibraryAssignment.SB.Refresh()
                    ''FrmMDIMain.SB.Text = i.ToString + " of " + iCnt.ToString
                    ''FrmMDIMain.Refresh()
                    Application.DoEvents()
                End If

                EmailGuid = RSData.GetValue(0).ToString
                SourceName = RSData.GetValue(1).ToString
                Body = RSData.GetValue(2).ToString
                OriginalFileType = RSData.GetValue(3).ToString

                If InStr(SourceName, Environment.NewLine) > 0 Or InStr(SourceName, vbCr) > 0 Or InStr(SourceName, vbLf) > 0 Then
                    SourceName = UTIL.RemoveCrLF(SourceName)
                End If
                If InStr(Body, Environment.NewLine) > 0 Or InStr(Body, vbCr) > 0 Or InStr(Body, vbLf) > 0 Then
                    Body = UTIL.RemoveCrLF(Body)
                End If

                If SourceName.Trim.Length = 0 Then
                    SourceName = "-"
                End If

                If Body.Trim.Length = 0 Then
                    Body = "-"
                End If
                If OriginalFileType.Trim.Length = 0 Then
                    OriginalFileType = "?"
                End If

                ItemType = OriginalFileType
                LibraryItemGuid = Guid.NewGuid.ToString

                Dim sData As String = ""
                sData = EmailGuid + Chr(253)
                sData = sData + SourceName + Chr(253)
                sData = sData + Body + Chr(253)
                sData = sData + ItemType + Chr(253)
                sData = sData + LibraryItemGuid + Chr(253)
                sData = sData + DataSourceOwnerUserID + Chr(253)
                sData = sData + LibraryOwnerUserID + Chr(253)
                sData = sData + LibraryName + Chr(253)
                sData = sData + AddedByUserGuidId + Chr(253)

                LOG.WriteToTempFile(TempFQN, sData)

            Loop
        End If
        RSData.Close()
        RSData = Nothing

        Dim iRecCount As Integer = 0
        Dim objReaderCtr As New System.IO.StreamReader(TempFQN)
        Do While objReaderCtr.Peek() <> -1
            Dim TextLine As String = objReaderCtr.ReadLine()
            iRecCount += 1
        Loop

        objReaderCtr = Nothing

        Dim LI As New clsLIBRARYITEMS

        ''FrmMDIMain.SB.Text = "Validating library entries: " + iRecCount.ToString
        ''FrmMDIMain.TSPB1.Minimum = 0
        ''FrmMDIMain.TSPB1.Maximum = iRecCount + 10

        i = 0
        Dim objReader As New System.IO.StreamReader(TempFQN)
        Do While objReader.Peek() <> -1
            i += 1
            If i Mod 10 = 0 Then
                Dim iToProcess As Integer = iRecCount - i
                'If iToProcess > 0 Then
                '    'FrmMDIMain.TSPB1.Value = iToProcess
                'End If
                Application.DoEvents()
            End If
            Dim TextLine As String = objReader.ReadLine()

            If TextLine.Trim.Length = 0 Then
                GoTo SkipRec01
            End If

            Dim A As String() = TextLine.Split(Chr(253))

            If A.Length <> 10 Then
                LOG.WriteToArchiveLog("Warning: Failed to enter email lib item " + A(1).Trim + ",  " + A(0).Trim)
                GoTo SkipRec01
            End If

            EmailGuid = A(0).Trim
            SourceName = A(1).Trim
            Body = A(2).Trim
            ItemType = A(3).Trim
            LibraryItemGuid = A(4).Trim
            DataSourceOwnerUserID = A(5).Trim
            LibraryOwnerUserID = A(6).Trim
            LibraryName = A(7).Trim
            AddedByUserGuidId = A(8).Trim

            Dim NewSubj As String = SourceName + " : " + Body
            NewSubj = Mid(NewSubj, 1, 199)

            s = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + EmailGuid + "'"
            iCnt = iCount(s)

            If iCnt = 0 Then
                LI.setAddedbyuserguidid(AddedByUserGuidId)
                LI.setDatasourceowneruserid(DataSourceOwnerUserID)
                LI.setItemtitle(NewSubj)
                LI.setItemtype(ItemType)
                LI.setLibraryitemguid(LibraryItemGuid)
                LI.setLibraryname(LibraryName)
                LI.setLibraryowneruserid(LibraryOwnerUserID)
                LI.setSourceguid(EmailGuid)
                Dim b As Boolean = LI.Insert
                If Not b Then
                    LOG.WriteToArchiveLog("ERROR: Failed to add Library Item to EMAIL Folder: '" + EmailFolder + "', Library: '" + LibraryName + "', ItemTitle: '" + SourceName + "'")
                End If
            End If
SkipRec01:
        Loop

        objReader = Nothing

        LI = Nothing
        GC.Collect()

        frmMain.SB.Text = "Library audit complete."
    End Sub

    ''' <summary>
    ''' Adds the system MSG.
    ''' </summary>
    ''' <param name="tMsg">The t MSG.</param>
    Sub AddSysMsg(ByVal tMsg As String)

        tMsg = UTIL.RemoveSingleQuotesV1(tMsg)

        Dim b As Boolean = False
        Dim S As String = ""
        Dim eGuid = ""
        eGuid = Guid.NewGuid.ToString

        S = S + " INSERT INTO [SystemMessage]"
        S = S + "            ([UserID]"
        S = S + "            ,[EntryDate]"
        S = S + "            ,[EntryGuid]"
        S = S + "            ,[EntryMsg])"
        S = S + " VALUES "
        S = S + "            ('" + gCurrUserGuidID + "'"
        S = S + "            ,'" + Now.ToString + "'"
        S = S + "            ,'" + eGuid + "'"
        S = S + "            ,'" + tMsg + "')"

        b = ExecuteSqlNewConn(90149, S)

        If Not b Then
            LOG.WriteToArchiveLog("Warning: Failed to add system notice '" + tMsg + "' to log.")
        End If
    End Sub

    ''' <summary>
    ''' Determines whether [is dir enabled] [the specified FQN].
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if [is dir enabled] [the specified FQN]; otherwise, <c>false</c>.</returns>
    Function isDirEnabled(ByVal FQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        FQN = UTIL.RemoveSingleQuotes(FQN)

        Dim B As Boolean = True
        Dim S As String = "Select ckDisableDir from Directory where fqn = '" + FQN + "' and UserID = '" + gCurrUserGuidID + "' "
        CloseConn()
        GC.Collect()

        'Dim CNN As New SqlConnection
        Dim RSData As SqlDataReader = Nothing
        Dim tVal As String = ""
        Try
            CloseConn()
            CkConn()
            Using gConn
                Dim command As New SqlCommand(S, gConn)
                RSData = SqlQryNewConn(S)
                RSData.Read()
                tVal = RSData.GetValue(0).ToString
                command.Connection.Close()
                command = Nothing
            End Using
            If tVal.ToUpper.Equals("Y") Then
                B = True
            Else
                B = False
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error 100 - CLSDBARCH : isDirEnabled: ", ex)
            LOG.WriteToArchiveLog("Error 100 - CLSDBARCH : isDirEnabled: " + ex.StackTrace)
            B = False
        Finally
            If Not RSData Is Nothing Then
                If Not RSData.IsClosed Then
                    RSData.Close()
                End If
                RSData = Nothing
            End If
            'CNN.Close()
            'CNN.Dispose()
            'CNN = Nothing
            GC.Collect()
        End Try

        CloseConn()
        Return B

    End Function

    ''' <summary>
    ''' Adds the name of the hashed dir.
    ''' </summary>
    ''' <param name="sName">Name of the s.</param>
    Sub AddHashedDirName(ByVal sName As String)

        Dim S As String = ""
        Dim d As Double = UTIL.HashName(sName)
        Dim NameExists As Boolean = False
        Dim NewGuid As String = Guid.NewGuid.ToString
        Try
            Dim HashedString As String = ""
            Dim icnt As Integer = iCount("Select count(*) from HashDir where Hash = " + d.ToString)
            If icnt = 0 Then
                HashedString = UTIL.ReplaceSingleQuotes(sName)
                S = "Insert into HashDir (Hash, HashedString, HashID) values (" + d.ToString + ",'" + HashedString + "', '" + NewGuid + "' ) "
                Dim B As Boolean = ExecuteSqlNewConn(90150, S)
                If B = False Then
                    LOG.WriteToArchiveLog("ERROR: AddHashedDirName 200 - " + S)
                End If
                Return
            Else
                NameExists = False
                S = "Select HashedString, HashID from HashDir where Hash = " + d.ToString
                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read()
                        Dim tName As String = RSData.GetValue(0).ToString
                        Dim ID As String = RSData.GetValue(1).ToString
                        If tName.ToUpper.Equals(sName.ToUpper) Then
                            '* it already exists
                            NameExists = True
                            Exit Do
                        End If
                    Loop
                    If NameExists = False Then

                        HashedString = UTIL.ReplaceSingleQuotes(sName)
                        S = "Insert into HashDir (Hash, HashedString, HashID) values (" + d.ToString + ",'" + HashedString + "', '" + NewGuid + "') "
                        Dim B As Boolean = ExecuteSqlNewConn(90151, S)
                        If B = False Then
                            LOG.WriteToArchiveLog("ERROR: AddHashedDirName 400 - " + S)
                        End If
                    End If
                End If
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddHashedDirName 100 - ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Adds the name of the hashed file.
    ''' </summary>
    ''' <param name="sName">Name of the s.</param>
    Sub AddHashedFileName(ByVal sName As String)

        Dim S As String = ""
        'Dim d As Double = UTIL.HashName(sName )
        Dim d As Double = UTIL.HashCalc(sName)
        Dim NameExists As Boolean = False
        Dim NewGuid As String = Guid.NewGuid.ToString
        Try
            Dim HashedString As String = ""
            Dim icnt As Integer = iCount("Select count(*) from HashFile where Hash = " + d.ToString)
            If icnt = 0 Then
                HashedString = UTIL.ReplaceSingleQuotes(sName)
                S = "Insert into HashFile (Hash, HashedString, HashID) values (" + d.ToString + ",'" + HashedString + "', '" + NewGuid + "' ) "
                Dim B As Boolean = ExecuteSqlNewConn(90152, S)
                If B = False Then
                    LOG.WriteToArchiveLog("ERROR: AddHashedFileName 200 - " + S)
                End If
                Return
            Else
                NameExists = False
                S = "Select HashedString, HashID from HashFile where Hash = " + d.ToString
                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                If RSData.HasRows Then
                    Do While RSData.Read()
                        Dim tName As String = RSData.GetValue(0).ToString
                        Dim ID As String = RSData.GetValue(1).ToString
                        If tName.ToUpper.Equals(sName.ToUpper) Then
                            '* it already exists
                            NameExists = True
                            Exit Do
                        End If
                    Loop
                    If NameExists = False Then

                        HashedString = UTIL.ReplaceSingleQuotes(sName)
                        S = "Insert into HashFile (Hash, HashedString, HashID) values (" + d.ToString + ",'" + HashedString + "', '" + NewGuid + "') "
                        Dim B As Boolean = ExecuteSqlNewConn(90153, S)
                        If B = False Then
                            LOG.WriteToArchiveLog("ERROR: AddHashedFileName 400 - " + S)
                        End If
                    End If
                End If
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddHashedFileName 100 - ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Gets the FQNS.
    ''' </summary>
    ''' <param name="Qty">The qty.</param>
    ''' <returns>ArrayList.</returns>
    Function getFqns(ByVal Qty As String) As ArrayList
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim A As New ArrayList

        Dim S As String = ""
        S = S + " select top " + Qty + " fqn from DataSource"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0
        Dim table_name As String = ""
        Dim column_name As String = ""
        Dim data_type As String = ""
        Dim character_maximum_length As String = ""

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim FQN As String = RSData.GetValue(0).ToString
                A.Add(FQN)
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        Return A

    End Function

    ''' <summary>
    ''' Adds the PST folder.
    ''' </summary>
    ''' <param name="StoreID">The store identifier.</param>
    ''' <param name="ParentFolderName">Name of the parent folder.</param>
    ''' <param name="ParentFolderID">The parent folder identifier.</param>
    ''' <param name="FolderKeyName">Name of the folder key.</param>
    ''' <param name="FolderID">The folder identifier.</param>
    ''' <param name="PstFQN">The PST FQN.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function AddPstFolder(ByVal StoreID As String, ByVal ParentFolderName As String, ByVal ParentFolderID As String, ByVal FolderKeyName As String, ByVal FolderID As String, ByVal PstFQN As String, ByVal RetentionCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        'ByVal FolderID , ByVal CurrFolder As Microsoft.Office.Interop.Outlook.MAPIFolder,
        Dim B As Boolean = True

        ParentFolderName = UTIL.RemoveSingleQuotes(ParentFolderName)

        Dim FolderName As String = ParentFolderName
        Dim UID As String = gCurrUserGuidID
        Dim SelectedForArchive As String = "Y"

        'Dim FolderFQN  = ParentFolderName + "|" + FolderKeyName
        Dim FolderFQN As String = FolderKeyName
        FolderFQN = UTIL.RemoveSingleQuotes(FolderFQN)

        'Dim SS  = " select count(*) from EmailFolder where UserID = '" + gCurrUserGuidID + "' and FolderID = '" + ParentFolderName  + "'"
        Dim SS As String = " select count(*) from EmailFolder where UserID = '" + gCurrUserGuidID + "' and FolderID = '" + FolderFQN + "'"
        Dim iCnt As Integer = iCount(SS)

        If iCnt = 1 Then
            Return True
        End If

        Dim S As String = ""
        S = S + " INSERT INTO [EmailFolder]"
        S = S + "    ([UserID]"
        S = S + "    ,[FolderName]"
        S = S + "    ,[ParentFolderName]"
        S = S + "    ,[FolderID]"
        S = S + "    ,[ParentFolderID]"
        S = S + "    ,[SelectedForArchive]"
        S = S + "    ,[StoreID]"
        S = S + "    ,[isSysDefault]"
        S = S + "    ,[RetentionCode])"
        S = S + " VALUES "
        S = S + "    ('" + UID + "'"
        'S = S + "    ,'" + UTIL.RemoveSingleQuotes(FolderKeyName ) + "'"
        S = S + "    ,'" + UTIL.RemoveSingleQuotes(FolderFQN) + "'"
        S = S + "    ,'" + UTIL.RemoveSingleQuotes(ParentFolderName) + "'"
        S = S + "    ,'" + FolderID + "'"
        S = S + "    ,'" + ParentFolderID + "'"
        S = S + "    ,'" + SelectedForArchive + "'"
        S = S + "    ,'" + StoreID + "'"
        S = S + "    ,0"
        S = S + "    ,'" + RetentionCode + "')"

        B = ExecuteSqlNewConn(90154, S)

        If Not B Then
            LOG.WriteToArchiveLog("ERROR: AddPstFolder 100 - " + S)
        End If

        Return B
    End Function

    ''' <summary>
    ''' Gets the dir profile.
    ''' </summary>
    ''' <param name="ProfileName">Name of the profile.</param>
    ''' <returns>System.String.</returns>
    Function getDirProfile(ByVal ProfileName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ProfileName = UTIL.RemoveSingleQuotes(ProfileName)

        Dim S As String = ""
        S = S + " Select [ProfileName]"
        S = S + " ,[Parms]"
        S = S + " FROM [DirProfiles]"
        S = S + " where ProfileName = '" + ProfileName + "' "

        CloseConn()
        CkConn()

        Dim ProfileStr As String = ""
        Dim wc As String = ""

        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                ProfileStr = RSData.GetValue(1).ToString
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            Me.xTrace(30021, "iExecCountStmt", ex.Message.ToString)
            ProfileStr = CStr(-1)
            LOG.WriteToArchiveLog("clsDatabaseARCH : iExecCountStmt : 100 : ", ex)
        End Try

        Return ProfileStr
    End Function

    ''' <summary>
    ''' Gets the name of current server.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getNameOfCurrentServer() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SvrName As String = ""
        Dim S As String = "Select serverproperty('MachineName')"
        CloseConn()
        CkConn()

        Dim wc As String = ""

        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                SvrName = RSData.GetValue(0).ToString
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            Me.xTrace(30021, "iExecCountStmt", ex.Message.ToString)
            SvrName = ""
            LOG.WriteToArchiveLog("clsDatabaseARCH : iExecCountStmt : 100 : ", ex)
        End Try

        Return SvrName
    End Function

    ''' <summary>
    ''' Gets the quick row count.
    ''' </summary>
    ''' <param name="TableName">Name of the table.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getQuickRowCnt(ByVal TableName As String) As Integer
        Dim I As Integer = 0
        TableName = UTIL.RemoveSingleQuotes(TableName)
        Dim S As String = "Select o.name, rows from sysobjects o inner join sysindexes i on o.id = i.id where i.indid < 2 and o.name = '" + TableName + "'"
        CloseConn()
        CkConn()

        Try
            Using gConn

                Dim RSData As SqlDataReader = Nothing
                Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
                RSData.Read()
                I = RSData.GetInt32(0)
                RSData.Close()
                RSData = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As Exception
            Me.xTrace(30021, "iExecCountStmt", ex.Message.ToString)
            I = -1
            LOG.WriteToArchiveLog("clsDatabaseARCH : iExecCountStmt : 100 : ", ex)
        End Try
        Return I
    End Function

    ''' <summary>
    ''' Gets the help information.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getHelpInfo() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim RSData As SqlDataReader = Nothing
        Dim S As String = "Select [HelpName],[HelpEmailAddr],[HelpPhone],[AreaOfFocus],[HoursAvail] FROM [HelpInfo] order by HelpName "
        Dim HelpInfo As String = ""

        Try

            Dim HelpName As String = ""
            Dim HelpEmailAddr As String = ""
            Dim HelpPhone As String = ""
            Dim AreaOfFocus As String = ""
            Dim HoursAvail As String = ""

            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()

                    HelpName = RSData.GetValue(0).ToString
                    HelpEmailAddr = RSData.GetValue(1).ToString
                    HelpPhone = RSData.GetValue(2).ToString
                    AreaOfFocus = RSData.GetValue(3).ToString
                    HoursAvail = RSData.GetValue(4).ToString

                    If HelpName.Trim.Length > 0 Then
                        HelpInfo = HelpInfo + "Contact - " + HelpName + Environment.NewLine
                    End If
                    If HelpName.Trim.Length > 0 Then
                        HelpInfo = HelpInfo + "Email - " + HelpEmailAddr + Environment.NewLine
                    End If
                    If HelpName.Trim.Length > 0 Then
                        HelpInfo = HelpInfo + "Phone - " + HelpPhone + Environment.NewLine
                    End If
                    If HelpName.Trim.Length > 0 Then
                        HelpInfo = HelpInfo + "Help Area - " + AreaOfFocus + Environment.NewLine
                    End If
                    If HelpName.Trim.Length > 0 Then
                        HelpInfo = HelpInfo + "Hours - " + HoursAvail + Environment.NewLine
                    End If

                    HelpInfo += Environment.NewLine

                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getHelpInfo 100: ", ex)
            Return ""
        Finally
            RSData.Close()
            RSData = Nothing
        End Try

        Return HelpInfo

    End Function

    ''' <summary>
    ''' Gets the help email.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getHelpEmail() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim RSData As SqlDataReader = Nothing
        Dim S As String = "Select [HelpEmailAddr] from HelpInfo where EmailNotification = 1 "
        Dim HelpInfo As String = ""

        Try

            Dim HelpName As String = ""
            Dim HelpEmailAddr As String = ""
            Dim HelpPhone As String = ""
            Dim AreaOfFocus As String = ""
            Dim HoursAvail As String = ""

            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    HelpEmailAddr = RSData.GetValue(0).ToString
                    HelpInfo = HelpInfo + HelpEmailAddr + "|"
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR getHelpEmail 100: ", ex)
            Return "support@EcmLibrary.com|dale@ecmlibrary.com|"
        Finally
            RSData.Close()
            RSData = Nothing
            GC.Collect()
        End Try

        Return HelpInfo

    End Function

    ''' <summary>
    ''' Populates the grid.
    ''' </summary>
    ''' <param name="S">The s.</param>
    ''' <param name="DGV">The DGV.</param>
    Sub PopulateGrid(ByVal S As String, ByRef DGV As DataGridView)
        'System.Windows.Forms.DataGridViewCellEventArgs
        Try

            Dim BS As New BindingSource
            Dim CS As String = getRepoConnStr()
            Dim sqlcn As New SqlConnection(CS)
            Dim sadapt As New SqlDataAdapter(S, sqlcn)
            Dim ds As DataSet = New DataSet

            If sqlcn.State = ConnectionState.Closed Then
                sqlcn.Open()
            End If

            sadapt.Fill(ds, "GridData")

            DGV.DataSource = ds.Tables("GridData")
        Catch ex As Exception
            ' If gRunUnattended = False Then MessageBox.Show("Error PopulateGrid 122165.4: " + ex.Message)
            LOG.WriteToArchiveLog("Error PopulateGrid 122165.4: ", ex)
        End Try

    End Sub

    ''' <summary>
    ''' Traces the activity.
    ''' </summary>
    ''' <param name="Msg">The MSG.</param>
    Sub TraceActivity(ByVal Msg As String)
        Dim S As String = ""
        Msg = UTIL.RemoveSingleQuotes(Msg)
        S = "Insert into Trace ( [LogEntry] ) values ( '" + Msg + "' ) "
        ExecuteSqlNewConn(90155, S)
    End Sub

    ''' <summary>
    ''' Updates the version information.
    ''' </summary>
    ''' <param name="Product">The product.</param>
    ''' <param name="ProductVersion">The product version.</param>
    Sub UpdateVersionInfo(ByVal Product As String, ByVal ProductVersion As String)

        Product = UTIL.RemoveSingleQuotes(Product)
        ProductVersion = UTIL.RemoveSingleQuotes(ProductVersion)

        Dim S As String = "Select count(*) from VersionInfo where Product = '" + Product + "' "

        Dim iCnt As Integer = iCount(S)

        If iCnt = 0 Then
            S = " INSERT INTO [VersionInfo] ([Product] ,[ProductVersion]) VALUES ('" + Product + "','" + ProductVersion + "')"
        Else
            S = " UPDATE [VersionInfo] SET [ProductVersion] = '" + ProductVersion + "' WHERE Product = '" + Product + "' "
        End If

        Dim B As Boolean = ExecuteSqlNewConn(S, False)
        If B = False Then
            LOG.WriteToArchiveLog("ERROR: UpdateVersionInfo - 100 : failed to update version info. " + Environment.NewLine + S)
        End If

    End Sub

    ''' <summary>
    ''' Gets the version information.
    ''' </summary>
    ''' <param name="Product">The product.</param>
    ''' <returns>System.String.</returns>
    Function getVersionInfo(ByVal Product As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim VerInfo As String = ""
        Product = UTIL.RemoveSingleQuotes(Product)

        Dim S As String = "Select count(*) from VersionInfo where Product = '" + Product + "' "

        Dim iCnt As Integer = iCount(S)

        If iCnt = 0 Then
            VerInfo = "No version info exists on " + Product
        Else
            S = "Select [ProductVersion] FROM [VersionInfo] where [Product] = '" + Product + "' "
            'S = "Select FixID, Applied, AppliedDate from DB_Updates order by FixID"
            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    VerInfo += RSData.GetValue(0).ToString
                    'VerInfo  += " : " + RSData.GetValue(1).ToString
                    'VerInfo  += " : " + RSData.GetValue(2).ToString + environment.NewLine
                Loop
            Else
                VerInfo = "No version info exists on " + Product
            End If
        End If

        Dim B As Boolean = ExecuteSqlNewConn(S, False)
        If B = False Then
            LOG.WriteToArchiveLog("ERROR: UpdateVersionInfo - 100 : failed to update version info. " + Environment.NewLine + S)
        End If

        Return VerInfo

    End Function

    ''' <summary>
    ''' Fixes the email keys.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function FixEmailKeys() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Try
            'SELECT [FolderName], [FileDirectory] FROM [EmailFolder]
            Dim S As String = "Select [FolderName] FROM [EmailFolder]"
            Dim FolderName = ""
            Dim L As New List(Of String)

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    FolderName = RSData.GetValue(0).ToString
                    If InStr(FolderName, "|") > 0 Then
                        Dim tFolderName As String = Mid(FolderName, 1, InStr(FolderName, "|") - 1)
                        tFolderName = tFolderName.Trim
                        If tFolderName.Length > 0 Then
                            If L.Contains(tFolderName) Then
                            Else
                                L.Add(tFolderName)
                            End If
                        End If
                    Else
                        If L.Contains(FolderName) Then
                        Else
                            L.Add(FolderName)
                        End If
                    End If
                Loop
            End If

            RSData.Close()
            RSData = Nothing

            S = "update EmailFolder set FileDirectory = 'xx' where FolderName like 'xx%'"

            For i As Integer = 0 To L.Count - 1
                Dim tgtFolder As String = L(i)
                tgtFolder = UTIL.RemoveSingleQuotes(tgtFolder)
                S = "update EmailFolder set FileDirectory = '" + tgtFolder + "' where FolderName like '" + tgtFolder + "|%' and FileDirectory is null"
                Dim BB As Boolean = ExecuteSqlNewConn(90156, S)
                If Not BB Then
                    LOG.WriteToArchiveLog("ERROR - FixEmailKeys 200 : " + S)
                End If

                S = "update EmailArchParms set FileDirectory = '" + tgtFolder + "' where FolderName like '" + tgtFolder + "|%' and FileDirectory is null"
                BB = ExecuteSqlNewConn(90157, S)
                If Not BB Then
                    LOG.WriteToArchiveLog("ERROR - FixEmailKeys 300 : " + S)
                End If
            Next
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR FixEmailKeys 100: ", ex)
            Return False
        End Try

    End Function

    ''' <summary>
    ''' Gets the attachment weights.
    ''' </summary>
    ''' <param name="SL">The sl.</param>
    Sub getAttachmentWeights(ByRef SL As SortedList(Of String, Integer))
        SL.Clear()
        Dim S As String = "Select EmailGuid, Weight from EmailAttachmentSearchList where UserID = '" + gCurrUserGuidID + "'"
        S = S + " and EmailGuid is not null"
        Dim EmailGuid As String = ""
        Dim Weight As Integer = -1
        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            Do While RSData.Read()
                Try
                    EmailGuid = RSData.GetValue(0).ToString
                    Try
                        Weight = RSData.GetInt32(1)
                    Catch ex As Exception
                        Weight = 0
                        LOG.WriteToArchiveLog("INFO - returned null weights '" + EmailGuid + "' : " + S)
                    End Try

                    If SL.Keys.Contains(EmailGuid) Then
                    Else
                        SL.Add(EmailGuid, Weight)
                    End If
                Catch ex As Exception
                    LOG.WriteToArchiveLog("INFO - returned null values: " + S)
                End Try

            Loop
        End If

        If Not RSData.IsClosed Then
            RSData.Close()
        End If
        RSData = Nothing
        command.Dispose()
        command = Nothing

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()

    End Sub

    ''' <summary>
    ''' Gets the disabled directories.
    ''' </summary>
    ''' <param name="ListOfDirs">The list of dirs.</param>
    Sub getDisabledDirectories(ByRef ListOfDirs As List(Of String))
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ListOfDirs.Clear()
        Dim S As String = "Select [FQN] FROM [Directory] where UserID = '" + gCurrUserGuidID + "' and (ckDisableDir = 'Y' or AdminDisabled = 1)"
        Dim DirFQN As String = ""
        Dim Weight As Integer = -1
        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                DirFQN = RSData.GetValue(0).ToString
                If ListOfDirs.Contains(DirFQN) Then
                Else
                    ListOfDirs.Add(DirFQN)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Runs the unattended.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function RunUnattended() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim ckVal As String = getUserParm("user_RunUnattended")
        'Dim ckVal  = getSystemParm("srv_RunUnattended")
        If ckVal.Equals("1") Then
            gRunUnattended = True
            Return True
        ElseIf ckVal.Equals("0") Then
            gRunUnattended = False
            Return False
        ElseIf ckVal.ToUpper.Equals("Y") Then
            gRunUnattended = True
            Return True
        ElseIf ckVal.ToUpper.Equals("N") Then
            Return False
        Else
            gRunUnattended = False
            Return False
        End If

    End Function

    ''' <summary>
    ''' Gets the size of the database.
    ''' </summary>
    ''' <param name="TargetGrid">The target grid.</param>
    ''' <returns>System.Double.</returns>
    Function getDbSize(ByRef TargetGrid As System.Windows.Forms.DataGridView) As Double
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = " "
        S = S + " SELECT"
        S = S + " a.FILEID,"
        S = S + " CONVERT(decimal(12,2),ROUND(a.size/128.000,2)) as [FILESIZEINMB] ,"
        S = S + " CONVERT(decimal(12,2),ROUND(fileproperty(a.name,'SpaceUsed')/128.000,2)) as [SPACEUSEDINMB],"
        S = S + " CONVERT(decimal(12,2),ROUND((a.size-fileproperty(a.name,'SpaceUsed'))/128.000,2)) as [FREESPACEINMB],"
        S = S + " a.name as [DATABASENAME],"
        S = S + " a.FILENAME as [FILENAME]"
        S = S + "     FROM "
        S = S + "     dbo.sysfiles a "

        PopulateGrid(S, TargetGrid)

    End Function

    ''' <summary>
    ''' Gets the table dasd use.
    ''' </summary>
    ''' <param name="TargetGrid">The target grid.</param>
    Sub getTableDasdUse(ByRef TargetGrid As System.Windows.Forms.DataGridView)
        Dim S As String = ""
        Dim CS As String = getRepoConnStr()
        Dim Connection As SqlConnection = New SqlConnection(CS)
        If Connection.State = ConnectionState.Closed Then
            Connection.Open()
        End If
        Dim Command As SqlCommand =
        New SqlCommand()
        Command.Connection = Connection
        Command.CommandText = "GetAllTableSizes"
        Dim Adapter As SqlDataAdapter =
                New SqlDataAdapter(Command)

        Dim DataSet As DataSet =
            New DataSet(Command.CommandText)

        Adapter.Fill(DataSet)
        TargetGrid.DataSource = DataSet.Tables(0)

    End Sub

    ''' <summary>
    ''' Gets the space used.
    ''' </summary>
    ''' <param name="TargetGrid">The target grid.</param>
    Sub getSpaceUsed(ByRef TargetGrid As System.Windows.Forms.DataGridView)
        Dim S As String = ""
        Dim CS As String = getRepoConnStr()
        Dim Connection As SqlConnection = New SqlConnection(CS)
        If Connection.State = ConnectionState.Closed Then
            Connection.Open()
        End If

        Dim Command As SqlCommand =
        New SqlCommand()
        Command.Connection = Connection
        Command.CommandText = "ECM_spaceused"
        Dim Adapter As SqlDataAdapter =
                New SqlDataAdapter(Command)

        Dim DataSet As DataSet =
            New DataSet(Command.CommandText)

        Adapter.Fill(DataSet)
        TargetGrid.DataSource = DataSet.Tables(0)

    End Sub

    ''' <summary>
    ''' Determines whether [is listening on].
    ''' </summary>
    ''' <returns><c>true</c> if [is listening on]; otherwise, <c>false</c>.</returns>
    Function isListeningOn() As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim MachineName As String = DMA.GetCurrMachineName()
        Dim S As String = "Select COUNT(*) FROM [DirectoryListener] where Machinename = '" + MachineName + "' and [ListenerActive] = 1"
        Dim iCnt As Integer = iCount(S)
        If iCnt > 0 Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Gets the listener files.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub GetListenerFiles(ByRef L As SortedList(Of String, String))

        Dim S As String = ""
        L.Clear()
        Dim MachineName As String = DMA.GetCurrMachineName()
        MachineName = UTIL.RemoveSingleQuotes(MachineName)

        S = "Select [SourceFile], DirGuid  FROM [DirectoryListenerFiles] where Archived = 0 and MachineName = '" + gMachineID + "'"

        Dim FQN As String = ""
        Dim SourceFile As String = ""
        Dim Archived As Boolean = False
        Dim EntryDate As Date = Nothing
        Dim UserID As String = ""
        Dim DirGuid As String = ""

        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()

        Try
            If CONN.State = ConnectionState.Closed Then
                CONN.Open()
            End If
        Catch ex As Exception
            L.Clear()
            LOG.WriteToArchiveLog("ERROR : GetListenerFiles 100 - ", ex)
            Return
        End Try

        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        Try
            If RSData.HasRows Then
                Do While RSData.Read()
                    SourceFile = RSData.GetValue(0).ToString
                    DirGuid = RSData.GetValue(1).ToString
                    If Not L.ContainsKey(SourceFile) Then
                        L.Add(SourceFile, DirGuid)
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: GetListenerFiles 100 - ", ex)
        Finally
            If Not RSData.IsClosed Then
                RSData.Close()
            End If
            RSData = Nothing
            command.Dispose()
            command = Nothing

            If CONN.State = ConnectionState.Open Then
                CONN.Close()
            End If
            CONN.Dispose()
        End Try

    End Sub

    ''' <summary>
    ''' Gets the modified files.
    ''' </summary>
    Public Sub getModifiedFiles()

        Dim cPath As String = LOG.getTempEnvironDir()
        Dim tFQN As String = cPath + "\ListenerFilesLog.ECM"
        Dim NewFile As String = tFQN + ".rdy"
        Dim F0 As New FileInfo(NewFile)
        Dim F As New FileInfo(tFQN)
        Dim SL As New SortedList(Of String, String)
        Try

            If F0.Exists() Then
                LOG.WriteToInstallLog("ACTIVATED the TimerUploadFiles: getModifiedFiles - the RDY file missing. ")
                GoTo P1
            End If

            If F.Exists Then
                File.Move(tFQN, NewFile)
            Else
                F = Nothing
                GC.Collect()
                Return
            End If

P1:

            ' Create new StreamReader instance with Using block. Open file.txt with the Using statement.

            If Not File.Exists(NewFile) Then
                Return
            End If

            Dim R As New StreamReader(NewFile)
            Try
                Using R
                    ' Store contents in this String.
                    Dim line As String

                    ' Read first line.
                    line = R.ReadLine
                    Dim I As Integer = 0
                    ' Loop over each line in file, While list is Not Nothing.
                    Do While Not R.EndOfStream
                        Application.DoEvents()

                        I += 1
                        ''FrmMDIMain.ListenerStatus.Text = I.ToString
                        Application.DoEvents()
                        If line.Trim.Length > 0 Then
                            Dim a As String() = line.Split(Chr(254))
                            Dim CDE As String = a(0).ToUpper
                            Dim Fqn As String = a(1)
                            If SL.Count > 10000 Then
                                SL.Clear()
                            End If
                            If SL.ContainsKey(Fqn) Then
                            Else
                                Dim FI As New FileInfo(Fqn)
                                If FI.Exists Then
                                    Dim tDir As String = FI.DirectoryName
                                    RegisterArchiveFile(Fqn, tDir)
                                    If SL.ContainsKey(Fqn) Then
                                    Else
                                        SL.Add(Fqn, tDir)
                                        LOG.WriteToInstallLog("Registered file: getModifiedFiles: " + Fqn)
                                    End If
                                End If
                                FI = Nothing
                            End If
                        End If
                        line = R.ReadLine
                    Loop
                End Using
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR getModifiedFiles - 288: ", ex)
            Finally
                R.Close()
                R.Dispose()
                GC.Collect()
            End Try

            Try
                If Not F Is Nothing Then
                    F = Nothing
                End If
                If Not F0 Is Nothing Then
                    'F0.Delete()
                    F0 = Nothing
                End If
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR getModifiedFiles 100 - could not delete file - " + tFQN)
            Finally
                Try
                    Kill(NewFile)
                Catch ex As Exception
                    Console.WriteLine(ex.Message)
                End Try
            End Try
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: getModifiedFiles 200 Listener Files could not be processed for = " + tFQN + Environment.NewLine + ex.Message)
        End Try
        ''FrmMDIMain.ListenerStatus.Text = "."
    End Sub

    ''' <summary>
    ''' Gets the size of the document.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function getDocSize(ByVal SourceGuid As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = False
        Dim I As Integer = 0
        Dim S As String = "Select FileLength from DataSource where SourceGuid = '" + SourceGuid + "'"
        Dim RSData As SqlDataReader = Nothing
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            If RSData.HasRows Then
                RSData.Read()
                I = RSData.GetInt32(0)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("getDocSize - Warning: email - no msgsize found: ", ex)
        Finally
            CloseConn()
            RSData.Close()
            RSData = Nothing
        End Try
        Return I
    End Function

    ''' <summary>
    ''' Registers the archive file.
    ''' </summary>
    ''' <param name="SourceFile">The source file.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function RegisterArchiveFile(ByVal SourceFile As String, ByVal DirName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        gListenerActivityStart = Now
        Application.DoEvents()
        Dim B As Boolean = True

        Dim RunGuid As String = getDirGuid(DirName, gMachineID)

        SourceFile = UTIL.RemoveSingleQuotes(SourceFile)

        Dim S As String = "Select count(*) FROM [DirectoryListenerFiles] where [DirGuid] = '" + RunGuid + "' and SourceFile = '" + SourceFile + "'  AND archived = 0 "
        'Dim S  = "Select count(*) FROM [DirectoryListenerFiles] where SourceFile = '" + SourceFile + "'  AND archived = 0 and MachineName = '" + gMachineID + "' "

        Dim iCnt = iCount(S)

        If iCnt = 0 Then
            S = ""
            S = S + " INSERT INTO [DirectoryListenerFiles]"
            S = S + "            ([DirGuid]"
            S = S + "            ,[SourceFile]"
            S = S + "            ,[Archived]"
            S = S + "            ,[EntryDate]"
            S = S + "            ,[UserID]"
            S = S + "            ,[MachineName], NameHash)"
            S = S + "      VALUES"
            S = S + "            ('" + RunGuid + "'"
            S = S + "            ,'" + SourceFile + "'"
            S = S + "            ,0"
            S = S + "            ,'" + Now.ToString + "'"
            S = S + "            ,'" + gCurrUserGuidID + "'"
            S = S + "            ,'" + gMachineID + "'"
            S = S + "            ," & 555.555
            S = S + " )"

            B = ExecuteSqlNewConn(90158, S)

        End If

        gListenerActivityStart = Now

        Return B
    End Function

    ''' <summary>
    ''' Cleans the out old listener files.
    ''' </summary>
    Sub CleanOutOldListenerFiles()
        Dim S As String = "delete from DirectoryListenerFiles where DATEDIFF(dd,entrydate,GETDATE()) > 30"
        Dim B As Boolean = ExecuteSqlNewConn(90159, S)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR CleanOutOldListenerFiles 100 - failed to delete files: " + S)
        End If
    End Sub

    ''' <summary>
    ''' Removes the temporary ocr files.
    ''' </summary>
    Sub removeTempOcrFiles()
        Try
            Dim WorkingDirectory As String = getWorkingDirectory(gCurrUserGuidID, "CONTENT WORKING DIRECTORY")
            LOG.PurgeDirectory(WorkingDirectory, "*.tif*")
        Catch ex As Exception
            LOG.WriteToArchiveLog("WARNING: removeTempOcrFiles Some temporary files may remain for a while in " + getWorkingDirectory(gCurrUserGuidID, "CONTENT WORKING DIRECTORY"))
        End Try

    End Sub

    ''' <summary>
    ''' Removes the null emails.
    ''' </summary>
    Sub RemoveNullEmails()
        Dim S As String = ""
        S = "Select count(*) from email where datalength(emailimage) < 1 or EmailImage is null"

        Dim icnt As Integer = iCount(S)

        If icnt = 0 Then
            MessageBox.Show("None to remove... returning")
            Return
        End If

        Dim msg As String = "This will DELETE " + icnt.ToString + " NULL items from emails, are you sure?"
        Dim dlgRes As DialogResult = MessageBox.Show(msg, "Delete Emails", MessageBoxButtons.YesNo)
        If dlgRes = Windows.Forms.DialogResult.No Then
            Return
        End If

        S = "Select EmailGuid, ShortSubj from email where datalength(emailimage) < 1 or EmailImage is null"

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        Dim I As Integer = 0
        If RSData.HasRows Then
            Do While RSData.Read()
                I += 1
                Dim EmailGuid As String = RSData.GetValue(0).ToString
                Dim ShortSubj As String = RSData.GetValue(1).ToString
                Application.DoEvents()
                ''FrmMDIMain.SB4.Text = I.ToString
                Me.DeleteContent(EmailGuid, "EMAIL", ShortSubj)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        ''FrmMDIMain.SB4.Text = "Done"
    End Sub

    ''' <summary>
    ''' Removes the null source.
    ''' </summary>
    Sub RemoveNullSource()
        Dim S As String = ""
        S = "Select count(*) from dataSource where datalength(SourceImage) < 1 or SourceImage is null"

        Dim icnt As Integer = iCount(S)

        If icnt = 0 Then
            MessageBox.Show("None to remove... returning")
            Return
        End If

        Dim msg As String = "This will remove " + icnt.ToString + " NULL items from Source, are you sure?"
        Dim dlgRes As DialogResult = MessageBox.Show(msg, "Delete Content", MessageBoxButtons.YesNo)
        If dlgRes = Windows.Forms.DialogResult.No Then
            Return
        End If

        S = "Select SourceGuid, fqn from dataSource where datalength(SourceImage) < 1 or SourceImage is null"

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        Dim I As Integer = 0
        If RSData.HasRows Then
            Do While RSData.Read()
                I += 1
                Dim SourceGuid As String = RSData.GetValue(0).ToString
                Dim fqn As String = RSData.GetValue(1).ToString
                Application.DoEvents()
                'FrmMDIMain.SB4.Text = I.ToString
                Me.DeleteContent(SourceGuid, "CONTENT", fqn)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        'FrmMDIMain.SB4.Text = "Done"

    End Sub

    ''' <summary>
    ''' Gets the directory libraries.
    ''' </summary>
    ''' <param name="DirectoryName">Name of the directory.</param>
    ''' <param name="L">The l.</param>
    Sub GetDirectoryLibraries(ByVal DirectoryName As String, ByRef L As List(Of String))
        L.Clear()

        Dim ParentDirectoryToUse As String = ""
        Dim isIncludedAsSubDir As Boolean = isSubDirIncluded(DirectoryName, ParentDirectoryToUse)

        If ParentDirectoryToUse.Length > 0 Then
            DirectoryName = ParentDirectoryToUse
        End If

        DirectoryName = UTIL.RemoveSingleQuotes(DirectoryName)

        Dim LibName As String = ""
        Dim S As String = "Select LibraryName from LibDirectory where DirectoryName = '" + DirectoryName + "' and UserID = '" + gCurrUserGuidID + "'"
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                LibName = RSData.GetValue(0).ToString
                If Not L.Contains(LibName) Then
                    L.Add(LibName)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()
    End Sub

    ''' <summary>
    ''' Cks the folder disabled.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="DirFQN">The dir FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckFolderDisabled(ByVal UID As String, ByVal DirFQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = " "

        DirFQN = UTIL.RemoveSingleQuotes(DirFQN)

        CloseConn()
        CkConn()

        S = "Select COUNT(*) from Directory where ckDisableDir = 'Y' and UserID = '" + gCurrUserGuidID + "' and FQN = '" + DirFQN + "'"

        Dim iCnt As Integer = iCount(S)

        If iCnt > 0 Then
            Return True
        Else
            Return False
        End If

        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Function

    ''' <summary>
    ''' Adds the file ext.
    ''' </summary>
    ''' <param name="FileExt">The file ext.</param>
    ''' <param name="Description">The description.</param>
    Sub AddFileExt(ByVal FileExt As String, ByVal Description As String)
        'FrmMDIMain.SB4.Text = FileExt
        FileExt = UTIL.RemoveSingleQuotes(FileExt)
        Description = UTIL.RemoveSingleQuotes(Description)
        Dim S As String = "Insert into FileType (FileExt, Description) Values ('" + FileExt + "', '" + Description + "')"
        Dim B As Boolean = ExecuteSqlNewConn(90160, S)
    End Sub

    ''' <summary>
    ''' Deletes the content.
    ''' </summary>
    ''' <param name="TgtGuid">The TGT unique identifier.</param>
    ''' <param name="TypeContent">Content of the type.</param>
    ''' <param name="FQN">The FQN.</param>
    Sub DeleteContent(ByVal TgtGuid As String, ByVal TypeContent As String, ByVal FQN As String)

        Dim S As String = ""
        Dim B As Boolean = False

        S = "Delete from SourceAttribute where SourceGuid = '" + TgtGuid + "' "
        B = ExecuteSqlNewConn(90161, S)

        S = "Delete from LibraryItems where SourceGuid = '" + TgtGuid + "' "
        B = ExecuteSqlNewConn(90162, S)

        If TypeContent.ToUpper.Equals("EMAIL") Then

            S = "Delete from [Recipients] where EmailGuid = '" + TgtGuid + "' "
            B = ExecuteSqlNewConn(90163, S)

            S = "Delete from EMAIL where EmailGuid = '" + TgtGuid + "' "
            B = ExecuteSqlNewConn(90164, S)
        Else

            S = "Delete from DataSource where SourceGuid = '" + TgtGuid + "' "
            B = ExecuteSqlNewConn(90165, S)

        End If

        ' xTrace(666, "DeleteContent : F10 : " + gCurrLoginID + " deleted file " + FQN + ".", "frmDocSearch")

    End Sub

    ''' <summary>
    ''' Determines whether [is parent dir disabled] [the specified dir FQN].
    ''' </summary>
    ''' <param name="DirFQN">The dir FQN.</param>
    ''' <returns><c>true</c> if [is parent dir disabled] [the specified dir FQN]; otherwise, <c>false</c>.</returns>
    Function isParentDirDisabled(ByVal DirFQN As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim TgtLib As String = ""
        Dim TempDir As String = ""
        Dim SS As String = ""
        If DirFQN.Trim.Length > 2 Then
            If Mid(DirFQN, 1, 2) = "\\" Then
                SS = "\\"
            Else
                SS = ""
            End If
        End If

        Dim DirList As New List(Of String)

        Dim A As String() = DirFQN.Split(CChar("\"))

        For I As Integer = 0 To UBound(A)
            TempDir = SS + TempDir + A(I)
            DirList.Add(TempDir)
            TempDir = TempDir + "\"
        Next

        For II As Integer = DirList.Count - 1 To 0 Step -1

            TempDir = DirList(II)
            TempDir = UTIL.RemoveSingleQuotes(TempDir)
            Dim iCnt As Integer = isDirectoryDisabled(TempDir)

            If iCnt = 1 Then
                Return True
            ElseIf iCnt = 0 Then
                Return False
            End If

            TempDir = TempDir + "\"
        Next

        Return False

    End Function

    ''' <summary>
    ''' Determines whether [is directory disabled] [the specified dir FQN].
    ''' </summary>
    ''' <param name="DirFqn">The dir FQN.</param>
    ''' <returns>System.Int32.</returns>
    Public Function isDirectoryDisabled(ByVal DirFqn As String) As Integer

        Dim RC As Integer = -1
        'Dim CNN As New SqlConnection
        Dim rsData As SqlDataReader = Nothing

        Try
            Dim S As String = "Select ckDisableDir from Directory where FQN = '" + DirFqn + "' and UserID = '" + gCurrUserGuidID + "' "

            Dim CS As String = getRepoConnStr()
            'Dim CONN As New SqlConnection(CS)
            'CONN.Open()

            Dim b As Boolean = False
            rsData = SqlQryNewConn(S, CS)
            rsData.Read()
            If rsData.HasRows Then
                Dim sChar As String = rsData.GetValue(0).ToString
                If sChar.ToUpper.Equals("Y") Then
                    RC = 1
                ElseIf sChar.ToUpper.Equals("N") Then
                    RC = 0
                Else
                    RC = 0
                End If
            Else
                RC = -1
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR isDirectoryDisabled 1993.21: ", ex)
            RC = -1
        Finally
            'CloseConn()
            'GC.Collect()
            If rsData IsNot Nothing Then
                If Not rsData.IsClosed Then
                    rsData.Close()
                End If
                rsData = Nothing
            End If
            'CNN.Close()
            'CNN.Dispose()
            'CNN = Nothing
            GC.Collect()
        End Try

        Return RC
    End Function

    ''' <summary>
    ''' Determines whether [is sub dir included bit on] [the specified dir FQN].
    ''' </summary>
    ''' <param name="DirFqn">The dir FQN.</param>
    ''' <returns>System.Int32.</returns>
    Public Function isSubDirIncludedBitON(ByVal DirFqn As String) As Integer

        Dim RC As Integer = -1
        'Dim CNN As New SqlConnection
        Dim rsData As SqlDataReader = Nothing

        Try
            Dim S As String = "Select IncludeSubDirs from Directory where FQN = '" + DirFqn + "' and UserID = '" + gCurrUserGuidID + "' "

            Dim CS As String = getRepoConnStr()
            'Dim CONN As New SqlConnection(CS)
            'CONN.Open()

            Dim b As Boolean = False
            rsData = SqlQryNewConn(S, CS)
            rsData.Read()
            If rsData.HasRows Then
                Dim sChar As String = rsData.GetValue(0).ToString
                If sChar.ToUpper.Equals("Y") Then
                    RC = 1
                ElseIf sChar.ToUpper.Equals("N") Then
                    RC = 0
                Else
                    RC = 0
                End If
            Else
                RC = -1
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR isDirectoryDisabled 1993.21: ", ex)
            RC = -1
        Finally
            'CloseConn()
            'GC.Collect()
            If rsData IsNot Nothing Then
                If Not rsData.IsClosed Then
                    rsData.Close()
                End If
                rsData = Nothing
            End If
            'CNN.Close()
            'CNN.Dispose()
            'CNN = Nothing
            GC.Collect()
        End Try

        Return RC
    End Function

    ''' <summary>
    ''' Determines whether the specified file type code is indexed.
    ''' </summary>
    ''' <param name="FileTypeCode">The file type code.</param>
    ''' <returns><c>true</c> if the specified file type code is indexed; otherwise, <c>false</c>.</returns>
    Function isIndexed(ByVal FileTypeCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If InStr(FileTypeCode, ".") = 0 Then
            FileTypeCode = "." + FileTypeCode
        End If

        Dim iCnt As Integer = iCount("Select COUNT(*) from sys.fulltext_document_types where document_type = '" + FileTypeCode + "'")
        If iCnt > 0 Then
            Return True
        Else
            Return False
        End If

    End Function

    '
    ''' <summary>
    ''' Determines whether the specified file type code is ocrd.
    ''' </summary>
    ''' <param name="FileTypeCode">The file type code.</param>
    ''' <returns><c>true</c> if the specified file type code is ocrd; otherwise, <c>false</c>.</returns>
    Function isOcrd(ByVal FileTypeCode As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If InStr(FileTypeCode, ".") = 0 Then
            FileTypeCode = "." + FileTypeCode
        End If

        Dim iCnt As Integer = iCount("Select COUNT(*)  FROM [ImageTypeCodes] where ImageTypeCode = '" + FileTypeCode + "'")
        If iCnt > 0 Then
            Return True
        Else
            Return False
        End If

    End Function

    ''' <summary>
    ''' Gets the ocr types.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub getOcrTypes(ByRef L As List(Of String))
        Dim S As String = "Select ImageTypeCode from ImageTypeCodes"

        L.Clear()
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim FileExt As String = RSData.GetValue(0).ToString
                FileExt = FileExt.ToUpper
                If Not L.Contains(FileExt) Then
                    L.Add(FileExt)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the indexed types.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub getIndexedTypes(ByRef L As List(Of String))
        Dim S As String = "Select document_type from sys.fulltext_document_types"

        L.Clear()
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim FileExt As String = RSData.GetValue(0).ToString
                FileExt = FileExt.ToUpper
                If Not L.Contains(FileExt) Then
                    L.Add(FileExt)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the processs as ext.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub getProcesssAsExt(ByRef L As SortedList(Of String, String))
        L.Clear()
        Dim S As String = "Select [ExtCode],[ProcessExtCode] FROM [ProcessFileAs]"
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim ExtCode As String = RSData.GetValue(0).ToString.ToUpper
                Dim ProcessExtCode As String = RSData.GetValue(1).ToString.ToUpper
                If Not L.ContainsKey(ExtCode) Then
                    L.Add(ExtCode, ProcessExtCode)
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing
    End Sub

    ''' <summary>
    ''' Shows the indexed files.
    ''' </summary>
    ''' <param name="D">The d.</param>
    Sub ShowIndexedFiles(ByRef D As DataGridView)

        Dim AL As New ArrayList
        'Dim dgCols() As String
        Dim OCRTYPES As New List(Of String)
        Dim INDEXTYPES As New List(Of String)
        Dim S As String = ""

        Dim ProcessAsExt As New SortedList(Of String, String)
        getProcesssAsExt(ProcessAsExt)

        getOcrTypes(OCRTYPES)
        getIndexedTypes(INDEXTYPES)

        S = "Select     document_type AS FileExt, '' as Indexed, '' as Ocrd, '' as IndexedAs "
        S = S + " FROM sys.fulltext_document_types "
        S = S + " UNION"
        S = S + " SELECT     ExtCode AS FileExt, '' as Indexed, '' as Ocrd, '' as IndexedAs  "
        S = S + " FROM AvailFileTypes "
        S = S + " UNION"
        S = S + " SELECT     ImageTypeCode AS FileExt, '' as Indexed, '' as Ocrd, '' as IndexedAs  "
        S = S + " FROM ImageTypeCodes "
        S = S + " UNION"
        S = S + " SELECT DISTINCT OriginalFileType AS FileExt, '' as Indexed, '' as Ocrd, '' as IndexedAs  "
        S = S + " FROM DataSource "
        S = S + " ORDER BY FileExt"

        Dim iCount As Integer = 0
        D.Rows.Clear()
        D.Columns.Add(CStr(0), "EXT")
        D.Columns.Add(CStr(1), "Indexed")
        D.Columns.Add(CStr(2), "Ocrd")
        D.Columns.Add(CStr(3), "IndexedAs")

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Dim FileExt As String = RSData.GetValue(0).ToString
                FileExt = FileExt.ToUpper
                'If InStr(FileExt, "JPG", CompareMethod.Text) > 0 Then
                '    Console.WriteLine("XXX")
                'End If
                If InStr(FileExt, ".") = 0 Then
                    FileExt = "." + FileExt
                End If
                Dim Indexed As String = RSData.GetValue(1).ToString
                Dim Ocrd As String = RSData.GetValue(2).ToString
                Dim BB As Boolean = False
                If OCRTYPES.Contains(FileExt) Then
                    Ocrd = "Y"
                    Indexed = "Y"
                    BB = True
                Else
                    Ocrd = "N"
                End If
                If BB = False Then
                    If INDEXTYPES.Contains(FileExt) Then
                        Indexed = "Y"
                    Else
                        Indexed = "N"
                    End If
                End If

                Dim IndexedAs As String = "-"
                If ProcessAsExt.ContainsKey(FileExt) Then
                    Dim II As Integer = ProcessAsExt.IndexOfKey(FileExt)
                    IndexedAs = ProcessAsExt.Item(FileExt).ToString
                    'IndexedAs = ProcessAsExt.Values(II)
                End If

                D.Rows.Add(FileExt, Indexed, Ocrd, IndexedAs)

                iCount = iCount + 1

            Loop
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Gets the ocr text.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="ContentType">Type of the content.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <returns>System.String.</returns>
    Function getOcrText(ByRef SourceGuid As String, ByVal ContentType As String, ByVal AttachmentName As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select document_type from sys.fulltext_document_types"
        If ContentType.Equals("DOC") Then
            S = "Select OcrText from DataSource where SourceGuid = '" + SourceGuid + "' "
        Else
            AttachmentName = UTIL.RemoveSingleQuotes(AttachmentName)
            S = "Select OcrText from EmailAttachment where EmailGuid = '" + SourceGuid + "' and AttachmentName = '" + AttachmentName + "' "
        End If

        Dim OcrText As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                OcrText = RSData.GetValue(0).ToString
            Loop
        End If
        RSData.Close()
        RSData = Nothing
        Return OcrText

    End Function

    ''' <summary>
    ''' Gets the SQL server version.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getSqlServerVersion() As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "Select @@VERSION AS 'ServerVersion'"
        Dim rsData As SqlDataReader = Nothing
        Dim ServerVersion As String = ""
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            Do While rsData.Read()
                ServerVersion = rsData.GetValue(0).ToString
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getSqlServerVersion Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return ServerVersion

    End Function

    ''' <summary>
    ''' Gets the dbsizemb.
    ''' </summary>
    ''' <returns>System.Double.</returns>
    Function getDBSIZEMB() As Double
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "exec Sp_spaceused"
        S = "Select "
        S = S + "     a.name as [DatabaseName], a.FILEID,"
        S = S + "     CONVERT(decimal(12,2),ROUND(a.size/128.000,2)) as [FileSizeInMB] ,"
        S = S + "     CONVERT(decimal(12,2),ROUND(fileproperty(a.name,'SpaceUsed')/128.000,2)) as [SpaceUsedInMB],"
        S = S + "     CONVERT(decimal(12,2),ROUND((a.size-fileproperty(a.name,'SpaceUsed'))/128.000,2)) as [FreeSpaceInMB],    "
        S = S + "     a.FILENAME as [FILENAME]"
        S = S + "     FROM"
        S = S + "     dbo.sysfiles a"
        Dim rsData As SqlDataReader = Nothing
        Dim DBSIZEMB As Double = 0
        Try
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : rsData = command.ExecuteReader()
            Do While rsData.Read()
                DBSIZEMB += rsData.GetDecimal(2)
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getSqlDBSIZEMB Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        Return DBSIZEMB

    End Function

    ''' <summary>
    ''' Builds the dictionary.
    ''' </summary>
    ''' <param name="MySql">My SQL.</param>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Function BuildDictionary(MySql As String) As Dictionary(Of String, String)

        Dim DICT As New Dictionary(Of String, String)
        Dim C1 As String = ""
        Dim C2 As String = ""
        Dim rsData As SqlDataReader = Nothing
        Dim DBSIZEMB As Double = 0

        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(MySql, CONN)
            rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    C1 = rsData.GetValue(0).ToString
                    C2 = rsData.GetValue(1).ToString
                    If Not DICT.Keys.Contains(C1) Then
                        DICT.Add(C1, C2)
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getSqlDBSIZEMB Error 100: " + ex.Message)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()

        Return DICT

    End Function

    ''' <summary>
    ''' Gets the list of.
    ''' </summary>
    ''' <param name="MySql">My SQL.</param>
    ''' <returns>List(Of System.String).</returns>
    Function getListOf(MySql As String) As List(Of String)

        Dim L As New List(Of String)
        Dim C1 As String = ""
        Dim rsData As SqlDataReader = Nothing
        Dim DBSIZEMB As Double = 0

        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(MySql, CONN)
            rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    C1 = rsData.GetValue(0).ToString
                    If Not L.Contains(C1) Then
                        L.Add(C1)
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getListOf Error 100: " + ex.Message + Environment.NewLine + MySql)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()

        Return L
    End Function

    Function getDictionaryOfStrings(MySql As String) As Dictionary(Of String, String)

        Dim L As New Dictionary(Of String, String)
        Dim C1 As String = ""
        Dim C2 As String = ""
        Dim rsData As SqlDataReader = Nothing
        Dim DBSIZEMB As Double = 0

        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(MySql, CONN)
            rsData = command.ExecuteReader()
            If rsData.HasRows Then
                Do While rsData.Read()
                    C1 = rsData.GetValue(0).ToString
                    C2 = rsData.GetValue(1).ToString
                    If Not L.Keys.Contains(C1) Then
                        L.Add(C1, C2)
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getListOf Error 100: " + ex.Message + Environment.NewLine + MySql)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()

        Return L
    End Function

    ''' <summary>
    ''' Gets the file ext.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getFileExt(SourceGuid As String) As String

        Dim MySQl As String = "Select FQN from DataSource where SourceGuid = '" + SourceGuid + "' "
        Dim L As New List(Of String)
        Dim C1 As String = ""
        Dim rsData As SqlDataReader = Nothing
        Dim DBSIZEMB As Double = 0
        Dim EXT As String = ""

        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            Using CONN
                CONN.Open()
                Dim command As New SqlCommand(MySQl, CONN)
                Using command
                    Using rsData
                        rsData = command.ExecuteReader()
                        If rsData.HasRows Then
                            Do While rsData.Read()
                                C1 = rsData.GetValue(0).ToString
                            Loop
                        End If
                    End Using
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getFileExt Error 100: " + ex.Message + Environment.NewLine + MySQl)
        End Try

        GC.Collect()

        EXT = Path.GetDirectoryName(C1)

        Return EXT
    End Function

    ''' <summary>
    ''' Rebuilds the cross index file types.
    ''' </summary>
    Sub RebuildCrossIndexFileTypes()

        Dim FM As New frmNotify
        FM.Show()
        FM.Text = "VALIDATING iFilter Extensions"

        Dim LisOfIncl As New List(Of String)
        LisOfIncl = getListOf("Select distinct lower([ExtCode]) FROM IncludedFiles ")

        Dim BB As Boolean = True
        Dim SqlStmts As New List(Of String)
        Dim K As Integer = 0
        Dim CurrEXT As String = ""
        Dim ProcessAsEXT As String = ""
        Dim SourceGuid As String = ""
        Dim OriginalFileType As String = ""
        Dim SourceTypeCode As String = ""
        Dim I As Integer = 0
        Dim MySql As String = ""
        Dim DICT As New Dictionary(Of String, String)
        Dim GoodCnt As Integer = 0
        Dim BadCnt As Integer = 0

        MySql = "select distinct lower(ExtCode), lower(ProcessExtCode) from ProcessFileAs"
        DICT = BuildDictionary(MySql)

        MySql = "select sourceGuid, lower([OriginalFileType]), lower([SourceTypeCode]) from DataSource where FQN is not null and ltrim(rtrim(fqn)) <> '' "
        Dim DS As DataSet = getDataSet(MySql)

        K = DS.Tables(0).Rows.Count

        For I = 0 To DS.Tables(0).Rows.Count - 1

            SourceGuid = DS.Tables(0).Rows(I).Item(0)
            OriginalFileType = DS.Tables(0).Rows(I).Item(1).ToString.ToLower.Trim
            SourceTypeCode = DS.Tables(0).Rows(I).Item(1).ToString.ToLower.Trim

            FM.lblFileSpec.Text = "File# " + I.ToString + " of " + K.ToString
            FM.Refresh()
            Application.DoEvents()

            If SourceTypeCode.Length > 0 Then
                If Not LisOfIncl.Contains(SourceTypeCode) Then
                    If DICT.ContainsKey(SourceTypeCode) Then
                        S = "Update DataSource set SourceTypeCode = '" + DICT(SourceTypeCode) + "' where SourceGuid = '" + SourceGuid + "' "
                        SqlStmts.Add(S)
                        BadCnt += 1
                    Else
                        S = "Update DataSource set SourceTypeCode = '" + OriginalFileType + "' where SourceGuid = '" + SourceGuid + "' "
                        SqlStmts.Add(S)
                        BadCnt += 1
                    End If
                End If
            Else
                S = "Update DataSource set SourceTypeCode = '" + OriginalFileType + "' where SourceGuid = '" + SourceGuid + "' "
                SqlStmts.Add(S)
                BadCnt += 1
            End If

            If (OriginalFileType.Length > 0) Then
                If (Not LisOfIncl.Contains(OriginalFileType)) Then
                    S = "Update DataSource set SourceTypeCode = '" + OriginalFileType + "' where SourceGuid = '" + SourceGuid + "' "
                    SqlStmts.Add(S)
                    BadCnt += 1
                ElseIf Not OriginalFileType.Equals(SourceTypeCode) Then
                    If Not LisOfIncl.Contains(SourceTypeCode) Then
                        ProcessAsEXT = DICT(OriginalFileType)
                        S = "Update DataSource set SourceTypeCode = '" + ProcessAsEXT + "' where SourceGuid = '" + SourceGuid + "' "
                        SqlStmts.Add(S)
                        BadCnt += 1
                    Else
                        GoodCnt += 1
                    End If
                ElseIf DICT.Keys.Contains(OriginalFileType) Then
                    ProcessAsEXT = DICT(OriginalFileType)
                    S = "Update DataSource set SourceTypeCode = '" + ProcessAsEXT + "' where SourceGuid = '" + SourceGuid + "' "
                    SqlStmts.Add(S)
                    BadCnt += 1

                Else
                    GoodCnt += 1
                End If
            Else
                BadCnt += 1
                LOG.WriteToArchiveLog("ERROR Q23: (Manually FIX) NO extension for Sourceguid " + SourceGuid)
                Dim ext As String = getFileExt(SourceGuid).ToLower
                S = "Update DataSource set OriginalFileType = '" + ext + "' where SourceGuid = '" + SourceGuid + "' "
                SqlStmts.Add(S)
                If Not LisOfIncl.Contains(ext) Then
                    S = "Update DataSource set SourceTypeCode = '" + ext + "' where SourceGuid = '" + SourceGuid + "' "
                End If
                If DICT.ContainsKey(ext) Then
                    Dim pext = DICT(ext)
                    S = "Update DataSource set SourceTypeCode = '" + pext + "' where SourceGuid = '" + SourceGuid + "' "
                End If
                BadCnt += 1
            End If

        Next

        If SqlStmts.Count > 0 Then
            Dim CMD As New SqlCommand
            Dim connString As String = getRepoConnStr()
            Dim conn As New SqlConnection(connString)

            If conn Is Nothing Then
                conn = New SqlConnection(getRepoConnStr())
            End If
            If conn.State = ConnectionState.Closed Then
                conn.ConnectionString = getRepoConnStr()
                conn.Open()
            End If

            FM.Text = "Applying Corrections"
            K = SqlStmts.Count
            If K > 0 Then
                I = 0
                CMD.Connection = conn
                CMD.CommandText = MySql
                CMD.CommandType = CommandType.Text
                Using conn
                    Using CMD
                        For Each MySql In SqlStmts
                            Try
                                I += 1
                                FM.lblFileSpec.Text = "File# " + I.ToString + " of " + K.ToString
                                FM.Refresh()
                                Application.DoEvents()

                                CMD.CommandText = MySql
                                CMD.ExecuteNonQuery()
                            Catch ex As Exception
                                LOG.WriteToArchiveLog("ERROR 22x: updateDBUpdateLastwrite: " + ex.Message + Environment.NewLine + MySql)
                                B = False
                            End Try
                        Next
                    End Using
                End Using
            End If
        End If

        FM.lblFileSpec.Text = ""
        FM.Refresh()
        Application.DoEvents()

        FM.Close()
        FM.Dispose()

    End Sub

    ''' <summary>
    ''' Validates the file types email.
    ''' </summary>
    Sub ValidateFileTypesEmail()
        Dim S As String = "Select rowid, attachmentname from EmailAttachment where OriginalFileTypeCode is null "
        Dim I As Integer = 0
        Dim rowid As Integer = 0
        Dim ExtCode As String = ""
        Dim attachmentname As String = ""
        Dim OriginalFileType As String = ""
        Dim SourceTypeCode As String = ""
        Dim ProcessExtCode As String = ""
        Dim K As Integer = 0

        Dim rsData As SqlDataReader = Nothing
        Dim ServerVersion As String = ""
        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()
            Do While rsData.Read()
                Application.DoEvents()
                rowid = rsData.GetInt32(0)
                attachmentname = rsData.GetValue(1).ToString
                OriginalFileType = UTIL.getFileSuffix(attachmentname).ToLower
                K += 1
                If K Mod 10 = 0 Then
                    'FrmMDIMain.SB4.Text = K.ToString + "/" + I.ToString
                End If
                If InStr(OriginalFileType, ".") = 0 Then
                    OriginalFileType = "." + OriginalFileType
                End If
                I += 1
                S = "Update EmailAttachment set OriginalFileTypeCode = '" + OriginalFileType + "' where rowid = " + rowid.ToString
                Dim b As Boolean = ExecuteSqlNewConn(90167, S)
                If Not b Then
                    LOG.WriteToArchiveLog("ERROR ValidateFileTypesEmail: File with ROWID '" + rowid.ToString + "' did not UPDATE file type from '" + OriginalFileType + "' to '" + ProcessExtCode + "'.")
                End If
                'End If
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:ValidateFileTypesEmail Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        'FrmMDIMain.SB4.Text = ""

    End Sub

    ''' <summary>
    ''' Rebuilds the cross index file types email.
    ''' </summary>
    Sub RebuildCrossIndexFileTypesEmail()

        ValidateFileTypesEmail()

        Dim S As String = ""
        S = S + " SELECT     ProcessFileAs.ExtCode, ProcessFileAs.ProcessExtCode, EmailAttachment.AttachmentName, EmailAttachment.RowID, EmailAttachment.OriginalFileTypeCode "
        S = S + " FROM         ProcessFileAs INNER JOIN"
        S = S + "              EmailAttachment ON ProcessFileAs.ExtCode = EmailAttachment.AttachmentCode                     "

        Dim I As Integer = 0
        Dim K As Integer = 0
        Dim AttachmentName As String = ""
        Dim ExtCode As String = ""
        Dim RowID As Integer = 0
        Dim OriginalFileTypeCode As String = ""
        Dim SourceTypeCode As String = ""
        Dim ProcessExtCode As String = ""

        Dim rsData As SqlDataReader = Nothing
        Dim ServerVersion As String = ""
        Try
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            rsData = command.ExecuteReader()
            Do While rsData.Read()
                Application.DoEvents()
                ExtCode = rsData.GetValue(0).ToString.ToLower
                ProcessExtCode = rsData.GetValue(1).ToString
                AttachmentName = rsData.GetValue(2).ToString.ToLower
                RowID = rsData.GetInt32(3)
                OriginalFileTypeCode = rsData.GetValue(4).ToString.ToLower
                K += 1
                If K Mod 10 = 0 Then
                    'FrmMDIMain.SB4.Text = K.ToString + "/" + I.ToString
                End If
                If ProcessExtCode.Equals(SourceTypeCode) Then
                Else
                    I += 1
                    S = "Update EmailAttachment set AttachmentCode = '" + ProcessExtCode + "' where RowID = " + RowID.ToString
                    Dim b As Boolean = ExecuteSqlNewConn(90168, S)
                    If Not b Then
                        LOG.WriteToArchiveLog("ERROR RebuildCrossIndexFileTypesEmail: File with RowID '" + RowID.ToString + "' did not UPDATE file type from '" + OriginalFileTypeCode + "' to '" + ProcessExtCode + "'.")
                    End If
                End If
            Loop
        Catch ex As Exception
            LOG.WriteToArchiveLog("Error: clsDatabaseARCH:getSqlServerVersion Error 100: ", ex)
        End Try

        If Not rsData.IsClosed Then
            rsData.Close()
        End If
        rsData = Nothing
        GC.Collect()
        'FrmMDIMain.SB4.Text = ""

    End Sub

    ''' <summary>
    ''' Emails the exists.
    ''' </summary>
    ''' <param name="EmailIdentifier">The email identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function EmailExists(ByVal EmailIdentifier As String) As Integer

        EmailIdentifier = UTIL.RemoveSingleQuotes(EmailIdentifier)

        Dim B As Integer = 0
        Dim TBL As String = "Email"
        Dim WC As String = "Where EmailIdentifier = '" + EmailIdentifier + "'"

        B = iGetRowCount(TBL, WC)

        Return B
    End Function

    'update Email set EmailIdentifier = EmailGuid where EmailIdentifier is null
    ''' <summary>
    ''' Resets the missing email ids.
    ''' </summary>
    Sub resetMissingEmailIds()

        Dim B As Boolean = False
        Dim S As String = ""
        Dim ID As Integer = 217

        S = S + "update Email set EmailIdentifier = EmailGuid where EmailIdentifier is null and UseriD = '" + gCurrUserGuidID + "' "
        B = ExecuteSqlNewConn(S, False)
    End Sub

    ''' <summary>
    ''' Gets the library users.
    ''' </summary>
    ''' <param name="isAdmin">if set to <c>true</c> [is admin].</param>
    ''' <param name="G">The g.</param>
    Sub getLibUsers(ByVal isAdmin As Boolean, ByRef G As DataGridView)
        G.Columns.Clear()
        G.Rows.Clear()

        G.Columns.Add("LibraryName", "Library Name")
        G.Columns.Add("UserName", "User Name")
        G.Columns.Add("OwnerName", "Owner Name")

        Dim S As String = ""
        If isAdmin = True Then
            S = S + " SELECT distinct L.LibraryName, "
            S = S + " L.LibraryOwnerUserID, "
            S = S + " L.UserID"
            S = S + " from LibraryUsers L "
            S = S + " order by LibraryName"
        Else
            S = S + " SELECT distinct L.LibraryName, "
            S = S + " L.LibraryOwnerUserID, "
            S = S + " L.UserID"
            S = S + " from LibraryUsers L "
            S = S + " Where  L.UserID = '" + gCurrUserGuidID + "' "
            S = S + " order by LibraryName"
        End If

        Dim LibraryName As String = ""
        Dim UserGuid As String = ""
        Dim OwnerGuid As String = ""
        Dim UserLoginID As String = ""
        Dim OwnerLoginID As String = ""
        Dim UserName As String = ""
        Dim OwnerName As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                LibraryName = RSData.GetValue(0).ToString
                OwnerGuid = RSData.GetValue(1).ToString
                UserGuid = RSData.GetValue(2).ToString
                OwnerLoginID = getUserLoginByUserid(OwnerGuid)
                UserLoginID = getUserLoginByUserid(UserGuid)
                OwnerName = getUserNameByID(OwnerGuid)
                UserName = getUserNameByID(UserGuid)
                G.Rows.Add(LibraryName, UserName, OwnerName)
            Loop
        End If

        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If

        CONN.Dispose()
        RSData.Close()
        RSData = Nothing
        GC.Collect()

    End Sub

    ''' <summary>
    ''' Cleans up library items.
    ''' </summary>
    Sub cleanUpLibraryItems()

        Dim S As String = ""
        S = S + " delete from LibraryItems where " + Environment.NewLine
        S = S + " SourceGuid not in (select emailguid as TgtGuid from Email" + Environment.NewLine
        S = S + " union " + Environment.NewLine
        S = S + " select sourceguid as TgtGuid from DataSource)"

        Dim B As Boolean = ExecuteSqlNewConn(90169, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 100: did not successfully complete.")
        End If

        S = "delete FROM LibraryItems where LibraryName not in  (select LibraryName from Library)"
        B = ExecuteSqlNewConn(90170, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 200: did not successfully complete.")
        End If

        S = "delete from LibraryUsers where LibraryName not in  (select LibraryName from Library)"
        B = ExecuteSqlNewConn(90171, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 300: did not successfully complete.")
        End If

        S = "delete from LibraryUsers where UserID not in  (select userid from users)"
        B = ExecuteSqlNewConn(90172, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 300.1: did not successfully complete.")
        End If

        S = "delete from GroupUsers where UserID not in (select userid from users) "
        B = ExecuteSqlNewConn(90173, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 400: did not successfully complete.")
        End If

        S = "delete from GroupUsers where GroupName not in (select GroupName from UserGroup) "
        B = ExecuteSqlNewConn(90174, S)
        If Not B Then
            LOG.WriteToArchiveLog("Warning cleanUpLibraryItems 500: did not successfully complete.")
        End If

    End Sub

    ''' <summary>
    ''' Inventories the content library items.
    ''' </summary>
    Sub inventoryContentLibraryItems()

        Dim S As String = ""
        S = S + " SELECT COUNT(*)"
        S = S + " FROM LibDirectory INNER JOIN"
        S = S + " DataSource ON LibDirectory.DirectoryName = DataSource.FileDirectory"

        Dim II As Integer = 0
        Dim iCnt As Integer = iCount(S)
        Dim RecsToProcess As Integer = iCnt

        If iCnt = 0 Then
            Return
        End If

        Dim TGuid As String = Guid.NewGuid.ToString

        'S = ""
        'S = S + " SELECT LibDirectory.DirectoryName, LibDirectory.LibraryName, DataSource.SourceGuid, DataSource.OriginalFileType"
        ''S = S + "   INTO #T" + TGuid
        'S = S + " FROM LibDirectory INNER JOIN"
        'S = S + " DataSource ON LibDirectory.DirectoryName = DataSource.FileDirectory"

        S = ""
        S = S + " SELECT DISTINCT LibDirectory.LibraryName, DataSource.SourceGuid, DataSource.OriginalFileType, Library.UserID, DataSource.SourceName, DataSource.DataSourceOwnerUserID"
        S = S + " FROM         LibDirectory INNER JOIN"
        S = S + " DataSource ON LibDirectory.DirectoryName = DataSource.FileDirectory INNER JOIN"
        S = S + " Library ON LibDirectory.UserID = Library.UserID"
        'S = S + " GROUP BY LibDirectory.LibraryName, DataSource.SourceGuid, DataSource.OriginalFileType, Library.UserID, DataSource.SourceName"

        'SELECT FirstName, LastName
        'INTO TestTable
        'FROM Person.Contact
        'WHERE EmailPromotion = 2
        '----Verify that Data in TestTable
        'SELECT FirstName, LastName
        'FROM TestTable
        '----Clean Up Database
        'DROP TABLE TestTable

        Dim tDir As String = LOG.getTempEnvironDir
        Dim LIKEYS As String = tDir + "\" + TGuid + ".txt"
        Dim SW As New StreamWriter(LIKEYS)

        Dim DirectoryName As String = ""
        Dim LibraryName As String = ""
        Dim SourceGuid As String = ""
        Dim OriginalFileType As String = ""
        Dim SourceName As String = ""
        Dim DataSourceOwnerUserID As String = ""
        Dim UserID As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                'FrmMDIMain.SB4.Text = "Step 1 of 2: " + II.ToString + " of " + RecsToProcess.ToString
                Application.DoEvents()

                LibraryName = RSData.GetValue(0).ToString
                SourceGuid = RSData.GetValue(1).ToString
                OriginalFileType = RSData.GetValue(2).ToString
                UserID = RSData.GetValue(3).ToString
                SourceName = RSData.GetValue(4).ToString
                DataSourceOwnerUserID = RSData.GetValue(5).ToString

                If InStr(OriginalFileType, ".") = 0 Then
                    OriginalFileType = "." + OriginalFileType
                End If

                S = ""
                S += LibraryName + Chr(254)
                S += SourceGuid + Chr(254)
                S += OriginalFileType + Chr(254)
                S += UserID + Chr(254)
                S += SourceName + Chr(254)
                S += DataSourceOwnerUserID

                SW.WriteLine(S)

            Loop
        End If
        RSData.Close()
        RSData = Nothing
        SW.Close()

        Dim srFileReader As System.IO.StreamReader
        Dim sInputLine As String = ""

        II = 0
        srFileReader = System.IO.File.OpenText(LIKEYS)
        sInputLine = srFileReader.ReadLine()
        Do Until sInputLine Is Nothing
            'FrmMDIMain.SB4.Text = "Step 2 of 2: " + II.ToString + " of " + RecsToProcess.ToString
            Application.DoEvents()

            sInputLine = srFileReader.ReadLine()

            If sInputLine = "" Then
                GoTo NextRow
            End If

            Dim A As String() = sInputLine.Split(Chr(254))

            LibraryName = UTIL.RemoveSingleQuotes(A(0))
            SourceGuid = A(1)
            OriginalFileType = A(2)
            UserID = A(3)
            SourceName = A(4)
            DataSourceOwnerUserID = A(5)

            S = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "'"
            iCnt = iCount(S)

            If iCnt = 0 Then
                S = ""
                S = S + " INSERT INTO [LibraryItems]" + Environment.NewLine
                S = S + " ([SourceGuid]" + Environment.NewLine
                S = S + " ,[ItemTitle]" + Environment.NewLine
                S = S + " ,[ItemType]" + Environment.NewLine
                S = S + " ,[LibraryItemGuid]" + Environment.NewLine
                S = S + " ,[DataSourceOwnerUserID]" + Environment.NewLine
                S = S + " ,[LibraryOwnerUserID]" + Environment.NewLine
                S = S + " ,[LibraryName]" + Environment.NewLine
                S = S + " ,[AddedByUserGuidId])" + Environment.NewLine
                S = S + "      VALUES( " + Environment.NewLine
                S = S + " ('" + SourceGuid + "'" + Environment.NewLine
                S = S + " ,'" + SourceName + "'" + Environment.NewLine
                S = S + " ,'" + OriginalFileType + "'" + Environment.NewLine
                S = S + " ,'" + Guid.NewGuid.ToString + "'" + Environment.NewLine
                S = S + " ,'" + DataSourceOwnerUserID + "'" + Environment.NewLine
                S = S + " ,'" + LibraryName + "'" + Environment.NewLine
                S = S + " ,'" + gCurrUserGuidID + "')"

                Dim B As Boolean = ExecuteSqlNewConn(90175, S)
                If Not B Then
                    LOG.WriteToArchiveLog("Error: ValidateLibraryItems 100 - Failed to add library item Library: [" + LibraryName + "], SourceName: [" + SourceName + "], SourceGuid: [" + SourceGuid + "]")
                End If

            End If
NextRow:
        Loop

        srFileReader.Close()
        srFileReader.Dispose()
        SW.Dispose()
        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Inventories the email library items.
    ''' </summary>
    Sub inventoryEmailLibraryItems()

        Dim S As String = ""
        'S = S + " SELECT COUNT(*)"
        'S = S + " FROM LibEmail INNER JOIN"
        'S = S + " DataSource ON LibDirectory.DirectoryName = DataSource.FileDirectory"

        Dim II As Integer = 0
        Dim iCnt As Integer = 0   'iCount(S)
        Dim RecsToProcess As Integer = iCnt

        'If iCnt = 0 Then
        '    Return
        'End If

        Dim TGuid As String = Guid.NewGuid.ToString
        S = ""
        S = S + " Select DISTINCT" + Environment.NewLine
        S = S + " LibEmail.LibraryName , email.emailGuid, " + Environment.NewLine
        S = S + " email.SourceTypeCode, Library.UserID, Email.ShortSubj, " + Environment.NewLine
        S = S + " Email.UserID" + Environment.NewLine
        S = S + " FROM         LibEmail INNER JOIN" + Environment.NewLine
        S = S + " Email ON LibEmail.FolderName = Email.OriginalFolder" + Environment.NewLine
        S = S + " INNER Join " + Environment.NewLine
        S = S + " Library ON LibEmail.UserID = Library.UserID"

        Clipboard.Clear()
        Clipboard.SetText(S)

        Dim tDir As String = LOG.getTempEnvironDir
        Dim LIKEYS As String = tDir + "\" + TGuid + ".txt"
        Dim SW As New StreamWriter(LIKEYS)

        Dim LibraryName As String = ""
        Dim SourceGuid As String = ""
        Dim OriginalFileType As String = ""
        Dim DataSourceOwnerUserID As String = ""
        Dim SourceName As String = ""
        Dim UserID As String = ""

        Dim rsEmail As SqlDataReader = Nothing
        'rsEmail = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)

        Clipboard.Clear()
        Clipboard.SetText(S)

        rsEmail = command.ExecuteReader()

        If rsEmail.HasRows Then
            Do While rsEmail.Read()
                II += 1
                'FrmMDIMain.SB4.Text = "Step 3 of 4: " + II.ToString + " of " + RecsToProcess.ToString
                Application.DoEvents()

                LibraryName = rsEmail.GetValue(0).ToString
                SourceGuid = rsEmail.GetValue(1).ToString
                OriginalFileType = rsEmail.GetValue(2).ToString
                DataSourceOwnerUserID = rsEmail.GetValue(3).ToString
                SourceName = rsEmail.GetValue(4).ToString
                UserID = rsEmail.GetValue(5).ToString

                If InStr(OriginalFileType, ".") = 0 Then
                    OriginalFileType = "." + OriginalFileType
                End If

                S = ""
                S += LibraryName + Chr(254)
                S += SourceGuid + Chr(254)
                S += OriginalFileType + Chr(254)
                S += UserID + Chr(254)
                S += SourceName + Chr(254)
                S += DataSourceOwnerUserID

                SW.WriteLine(S)

            Loop
        End If
        rsEmail.Close()
        rsEmail = Nothing
        SW.Close()

        Dim srFileReader As System.IO.StreamReader
        Dim sInputLine As String = ""

        II = 0
        srFileReader = System.IO.File.OpenText(LIKEYS)
        sInputLine = srFileReader.ReadLine()
        Do Until sInputLine Is Nothing
            'FrmMDIMain.SB4.Text = "Step 4 of 4: " + II.ToString + " of " + RecsToProcess.ToString
            Application.DoEvents()

            sInputLine = srFileReader.ReadLine()

            If sInputLine = "" Then
                GoTo NextRow
            End If

            Dim A As String() = sInputLine.Split(Chr(254))

            LibraryName = UTIL.RemoveSingleQuotes(A(0))
            SourceGuid = A(1)
            OriginalFileType = A(2)
            UserID = A(3)
            SourceName = A(4)
            DataSourceOwnerUserID = A(5)

            S = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "'"
            iCnt = iCount(S)

            If iCnt = 0 Then
                S = ""
                S = S + " INSERT INTO [LibraryItems]" + Environment.NewLine
                S = S + " ([SourceGuid]" + Environment.NewLine
                S = S + " ,[ItemTitle]" + Environment.NewLine
                S = S + " ,[ItemType]" + Environment.NewLine
                S = S + " ,[LibraryItemGuid]" + Environment.NewLine
                S = S + " ,[DataSourceOwnerUserID]" + Environment.NewLine
                S = S + " ,[LibraryOwnerUserID]" + Environment.NewLine
                S = S + " ,[LibraryName]" + Environment.NewLine
                S = S + " ,[AddedByUserGuidId])" + Environment.NewLine
                S = S + "      VALUES( " + Environment.NewLine
                S = S + " ('" + SourceGuid + "'" + Environment.NewLine
                S = S + " ,'" + SourceName + "'" + Environment.NewLine
                S = S + " ,'" + OriginalFileType + "'" + Environment.NewLine
                S = S + " ,'" + Guid.NewGuid.ToString + "'" + Environment.NewLine
                S = S + " ,'" + DataSourceOwnerUserID + "'" + Environment.NewLine
                S = S + " ,'" + LibraryName + "'" + Environment.NewLine
                S = S + " ,'" + gCurrUserGuidID + "')"

                Dim B As Boolean = ExecuteSqlNewConn(90176, S)
                If Not B Then
                    LOG.WriteToArchiveLog("Error: ValidateLibraryItems 100 - Failed to add library item Library: [" + LibraryName + "], SourceName: [" + SourceName + "], SourceGuid: [" + SourceGuid + "]")
                End If

            End If
NextRow:
        Loop

        srFileReader.Close()
        srFileReader.Dispose()
        SW.Dispose()
        rsEmail = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

        'FrmMDIMain.SB4.Text = "Validation Complete"

    End Sub

    ''' <summary>
    ''' Gets the list of assigned libraries.
    ''' </summary>
    ''' <param name="DirectoryName">Name of the directory.</param>
    ''' <param name="TypeEntry">The type entry.</param>
    ''' <param name="AssignedLibraries">The assigned libraries.</param>
    Sub GetListOfAssignedLibraries(ByVal DirectoryName As String, ByVal TypeEntry As String, ByRef AssignedLibraries As List(Of String))

        Dim S As String = ""
        AssignedLibraries.Clear()

        If TypeEntry.Equals("EMAIL") Then
            S = "Select LibraryName from LibEmail where FolderName = '" + DirectoryName + "'"
        Else
            S = "Select LibraryName from LibDirectory where DirectoryName = '" + DirectoryName + "'"
        End If

        Dim LibraryName As String = ""
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                LibraryName = RSData.GetValue(0).ToString
                If Not AssignedLibraries.Contains(LibraryName) Then
                    AssignedLibraries.Add(LibraryName)
                End If
            Loop
        Else
            AssignedLibraries.Add("No assigned libraries")
        End If
        RSData.Close()
        RSData = Nothing
        command.Dispose()
        If CONN.State = ConnectionState.Open Then
            CONN.Close()
        End If
        CONN.Dispose()
        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Determines whether [is sub dir included] [the specified dir FQN].
    ''' </summary>
    ''' <param name="DirFQN">The dir FQN.</param>
    ''' <param name="ParentDir">The parent dir.</param>
    ''' <returns><c>true</c> if [is sub dir included] [the specified dir FQN]; otherwise, <c>false</c>.</returns>
    Function isSubDirIncluded(ByVal DirFQN As String, ByRef ParentDir As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        ParentDir = ""

        Dim TgtLib As String = ""
        Dim TempDir As String = ""
        Dim SS As String = ""
        If DirFQN.Trim.Length > 2 Then
            If Mid(DirFQN, 1, 2) = "\\" Then
                SS = "\\"
            Else
                SS = ""
            End If
        End If

        Dim DirList As New List(Of String)

        Dim A As String() = DirFQN.Split(CChar("\"))

        For I As Integer = 0 To UBound(A)
            TempDir = SS + TempDir + A(I)
            DirList.Add(TempDir)
            TempDir = TempDir + "\"
        Next

        For II As Integer = DirList.Count - 1 To 0 Step -1

            TempDir = DirList(II)
            TempDir = UTIL.RemoveSingleQuotes(TempDir)

            Dim iCnt As Integer = isSubDirIncludedBitON(TempDir)

            If iCnt = 1 Then
                ParentDir = TempDir
                Return True
            ElseIf iCnt = 0 Then
                Return False
            End If

            TempDir = TempDir + "\"
        Next

        Return False
    End Function

    ''' <summary>
    ''' Gets the library owner guids.
    ''' </summary>
    ''' <param name="LibraryOwnerGuids">The library owner guids.</param>
    Sub getLibraryOwnerGuids(ByRef LibraryOwnerGuids As SortedList(Of String, String))
        Dim S As String = "Select LibraryName,UserID from Library"
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
        Try
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Dim LibraryName = RSData.GetValue(0).ToString
                    Dim UserID = RSData.GetValue(1).ToString
                    If Not LibraryOwnerGuids.ContainsKey(LibraryName) Then
                        LibraryOwnerGuids.Add(LibraryName, UserID)
                    End If
                Loop

            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddLibraryGroupUser 100 - ", ex)
        Finally
            RSData.Close()
            RSData = Nothing
        End Try
    End Sub

    ''' <summary>
    ''' Adds the library group user.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    Sub AddLibraryGroupUser(ByVal GroupName As String)

        GroupName = UTIL.RemoveSingleQuotes(GroupName)

        Dim LibraryOwnerGuids As New SortedList(Of String, String)

        getLibraryOwnerGuids(LibraryOwnerGuids)

        Dim S As String = ""

        S = S + " SELECT     GroupLibraryAccess.LibraryName, GroupLibraryAccess.GroupOwnerUserID, GroupLibraryAccess.GroupName, "
        S = S + "               GroupUsers.UserID AS GroupUserGuid, GroupUsers.FullAccess, GroupUsers.ReadOnlyAccess, GroupUsers.DeleteAccess, GroupUsers.Searchable, "
        S = S + "                       GroupUsers.GroupOwnerUserID AS GroupOwnerUserIDGuid"
        S = S + " FROM         GroupLibraryAccess INNER JOIN"
        S = S + "               GroupUsers ON GroupLibraryAccess.GroupName = GroupUsers.GroupName"
        If GroupName.Equals("*") Then
        Else
            S = S + " WHERE     (GroupLibraryAccess.GroupName = '" + GroupName + "')"
        End If
        S = S + " order by GroupLibraryAccess.LibraryName"

        Dim LibraryName As String = ""
        Dim GroupOwnerUserID As String = ""
        Dim tGroupName As String = ""
        Dim GroupUserGuid As String = ""
        Dim FullAccess As String = ""
        Dim ReadOnlyAccess As String = ""
        Dim DeleteAccess As String = ""
        Dim Searchable As String = ""
        Dim GroupOwnerUserIDGuid As String = ""

        Dim deleteExecutionList As New List(Of String)
        Dim insertExecutionList As New List(Of String)
        Dim PrevLibName As String = ""

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
        Try
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()

                    LibraryName = RSData.GetValue(0).ToString
                    GroupOwnerUserID = RSData.GetValue(1).ToString
                    tGroupName = RSData.GetValue(2).ToString
                    GroupUserGuid = RSData.GetValue(3).ToString
                    FullAccess = RSData.GetValue(4).ToString
                    ReadOnlyAccess = RSData.GetValue(5).ToString
                    DeleteAccess = RSData.GetValue(6).ToString
                    Searchable = RSData.GetValue(7).ToString
                    GroupOwnerUserIDGuid = RSData.GetValue(8).ToString

                    'If PrevLibName <> LibraryName Then
                    '    Dim tsql As String = "DELETE FROM LibraryUsers where [LibraryName] = '" + LibraryName + "' and (SingleUser is null or SingleUser = 0)"
                    '    deleteExecutionList.Add(tsql)
                    'End If

                    Dim LibraryOwnerUserID As String = ""
                    If LibraryOwnerGuids.ContainsKey(LibraryName) Then '
                        Dim iName As Integer = LibraryOwnerGuids.IndexOfKey(LibraryName)
                        LibraryOwnerUserID = LibraryOwnerGuids.Values(iName)
                    Else
                        LibraryOwnerUserID = gCurrUserGuidID
                    End If

                    LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

                    Dim iSql As String = ""
                    'iSql = iSql + ""
                    'iSql = iSql + "INSERT INTO [LibraryUsers]"
                    'iSql = iSql + " ([ReadOnly]"
                    'iSql = iSql + ",[CreateAccess]"
                    'iSql = iSql + ",[UpdateAccess]"
                    'iSql = iSql + ",[DeleteAccess]"
                    'iSql = iSql + ",[UserID]"
                    'iSql = iSql + ",[LibraryOwnerUserID]"
                    'iSql = iSql + ",[LibraryName])"
                    'iSql = iSql + " VALUES"
                    'iSql = iSql + " (0"
                    'iSql = iSql + ",1"
                    'iSql = iSql + ",1"
                    'iSql = iSql + ",1"
                    'iSql = iSql + ",'" + GroupUserGuid + "'"
                    'iSql = iSql + ",'" + LibraryOwnerUserID + "'"
                    'iSql = iSql + ",'" + LibraryName + "')"

                    iSql = ""
                    iSql += "INSERT INTO [LibraryUsers]" + Environment.NewLine
                    iSql += "           ([ReadOnly]" + Environment.NewLine
                    iSql += "           ,[CreateAccess]" + Environment.NewLine
                    iSql += "           ,[UpdateAccess]" + Environment.NewLine
                    iSql += "           ,[DeleteAccess]" + Environment.NewLine
                    iSql += "           ,[UserID]" + Environment.NewLine
                    iSql += "           ,[LibraryOwnerUserID]" + Environment.NewLine
                    iSql += "           ,[LibraryName]" + Environment.NewLine
                    iSql += "           ,[NotAddedAsGroupMember]" + Environment.NewLine
                    iSql += "           ,[GroupUser])" + Environment.NewLine
                    iSql += "     VALUES" + Environment.NewLine
                    iSql += "           (0" + Environment.NewLine
                    iSql += "           ,1" + Environment.NewLine
                    iSql += "           ,1" + Environment.NewLine
                    iSql += "           ,0" + Environment.NewLine
                    iSql += "           ,'" + GroupUserGuid + "'" + Environment.NewLine
                    iSql += "           ,'" + GroupOwnerUserIDGuid + "'" + Environment.NewLine
                    iSql += "           ,'" + LibraryName + "'" + Environment.NewLine
                    iSql += "           ,0" + Environment.NewLine
                    iSql += "           ,1)" + Environment.NewLine

                    insertExecutionList.Add(iSql)

                    PrevLibName = LibraryName

                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddLibraryGroupUser 100 - ", ex)
        Finally
            RSData.Close()
        End Try

        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

        For I As Integer = 0 To deleteExecutionList.Count - 1
            Dim tSql As String = deleteExecutionList(I)
            Dim B As Boolean = True
            B = ExecuteSqlNewConn(90177, tSql)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: Failed to DELETE library users for library " + LibraryName + " : " + tSql)
            End If
        Next

        For I As Integer = 0 To insertExecutionList.Count - 1
            Dim tSql As String = insertExecutionList(I)
            Dim B As Boolean = True
            B = ExecuteSqlNewConn(90178, tSql)
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: Failed to ADD library user. " + Environment.NewLine + tSql)
            Else
                LOG.WriteToArchiveLog("NOTICE: ADDED library user. " + Environment.NewLine + tSql)
            End If
        Next

    End Sub

    ''' <summary>
    ''' Deletes the library group user.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    Public Sub DeleteLibraryGroupUser(ByVal GroupName As String, ByVal LibraryName As String)

        GroupName = UTIL.RemoveSingleQuotes(GroupName)
        LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

        Dim S As String = ""

        S += " SELECT     GroupLibraryAccess.GroupName, GroupLibraryAccess.LibraryName, GroupUsers.UserID AS Userid" + Environment.NewLine
        S += " FROM       GroupLibraryAccess INNER JOIN" + Environment.NewLine
        S += "            GroupUsers ON GroupLibraryAccess.GroupName = GroupUsers.GroupName" + Environment.NewLine
        S += " WHERE      GroupLibraryAccess.GroupName = '" + GroupName + "'" + Environment.NewLine
        S += " AND        LibraryName = '" + LibraryName + "'" + Environment.NewLine
        S += " order by   GroupLibraryAccess.GroupName, GroupLibraryAccess.LibraryName" + Environment.NewLine

        Dim Userid As String = ""
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
        Try
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Userid = RSData.GetValue(2).ToString
                    Dim SS As String = "delete from GroupLibraryAccess where UseriD = '" + Userid + "' and LibraryName = '" + LibraryName + "' and groupname = '" + GroupName + "'"
                    Dim iCnt As Integer = countGroupsUserBelongsTo(LibraryName, Userid)
                    If iCnt = 0 Then
                        SS = "delete from LibraryUsers where UserID = '" + Userid + "' and LibraryName = '" + LibraryName + "'  and SingleUser != 1"
                        Dim B1 As Boolean = ExecuteSqlNewConn(90179, S)
                        If Not B1 Then
                            Console.WriteLine("Failed to delete oD " + Userid + " from Library " + LibraryName + ".")
                        End If
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddLibraryGroupUser 100 - ", ex)
        Finally
            RSData.Close()
        End Try

        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Deletes the library group user.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <param name="GroupUserID">The group user identifier.</param>
    Public Sub DeleteLibraryGroupUser(ByVal GroupName As String, ByVal LibraryName As String, ByVal GroupUserID As String)

        GroupName = UTIL.RemoveSingleQuotes(GroupName)
        LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

        Dim S As String = ""

        S += " SELECT     GroupLibraryAccess.GroupName, GroupLibraryAccess.LibraryName, GroupUsers.UserID AS Userid" + Environment.NewLine
        S += " FROM         GroupLibraryAccess INNER JOIN" + Environment.NewLine
        S += "                       GroupUsers ON GroupLibraryAccess.GroupName = GroupUsers.GroupName" + Environment.NewLine
        S += " WHERE     (GroupLibraryAccess.GroupName = '" + GroupName + "') " + Environment.NewLine
        S += "     AND (GroupLibraryAccess.LibraryName = '" + LibraryName + "') " + Environment.NewLine
        S += "     AND (GroupUsers.UserID = '" + GroupUserID + "')" + Environment.NewLine

        Clipboard.Clear()
        Clipboard.SetText(S)

        Dim Userid As String = ""
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN)
        Try
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Userid = GroupUserID
                    Dim SS As String = "delete from GroupLibraryAccess where UseriD = '" + Userid + "' and LibraryName = '" + LibraryName + "' and groupname = '" + GroupName + "'"
                    Dim iCnt As Integer = countGroupsUserBelongsTo(LibraryName, Userid)
                    If iCnt = 0 Then
                        SS = "delete from LibraryUsers where UserID = '" + Userid + "' and LibraryName = '" + LibraryName + "'  and SingleUser != 1"
                        Dim B1 As Boolean = ExecuteSqlNewConn(90180, S)
                        If Not B1 Then
                            Console.WriteLine("Failed to delete 0e " + Userid + " from Library " + LibraryName + ".")
                        End If
                    End If
                Loop
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: AddLibraryGroupUser 100 - ", ex)
        Finally
            RSData.Close()
        End Try

        RSData = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Verifies the orphan source data.
    ''' </summary>
    Sub VerifyOrphanSourceData()
        Try
            Dim S As String = "Select sourceguid from DataSource where DATALENGTH(SourceImage) = 0"
            Dim sourceguid As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr()
            'Data Source=DELLT100\ECMLIB;Initial Catalog=ECM.Library;Integrated Security=True; Connect Timeout = 30
            If InStr(CS, "Connect Timeout", CompareMethod.Text) > 0 Then
                Dim II As Integer = InStr(CS, "Connect Timeout", CompareMethod.Text)
                CS = Mid(CS, 1, II - 1)
            End If
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            RSData = command.ExecuteReader()
            If RSData.HasRows Then
                Do While RSData.Read()
                    Application.DoEvents()
                    System.Threading.Thread.Sleep(100)
                    sourceguid = RSData.GetValue(0).ToString
                    DeleteContent(sourceguid, "CONTENT", "Orphan records")
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: VerifyOrphanSourceData - ", ex)
        End Try

        MessageBox.Show("Source Validation Complete.")

    End Sub

    ''' <summary>
    ''' Verifies the orphan email data.
    ''' </summary>
    Sub VerifyOrphanEmailData()

        Try
            Dim S As String = "Select emailguid from Email where DATALENGTH(EmailImage) = 0 "
            Dim EmailGuid As String = ""

            Dim RSData As SqlDataReader = Nothing
            'RSData = SqlQryNo'Session(S)
            Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
            'Data Source=DELLT100\ECMLIB;Initial Catalog=ECM.Library;Integrated Security=True; Connect Timeout = 30
            If InStr(CS, "Connect Timeout", CompareMethod.Text) > 0 Then
                Dim II As Integer = InStr(CS, "Connect Timeout", CompareMethod.Text)
                CS = Mid(CS, 1, II - 1)
            End If

            If RSData.HasRows Then
                Do While RSData.Read()
                    System.Threading.Thread.Sleep(100)
                    Application.DoEvents()
                    EmailGuid = RSData.GetValue(0).ToString
                    DeleteEmailByGuid(EmailGuid)
                Loop
            End If
            RSData.Close()
            RSData = Nothing
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: VerifyOrphanEmailData - ", ex)
        End Try

        MessageBox.Show("Email Validation Complete.")

    End Sub

    ''' <summary>
    ''' Adds the standard triggers.
    ''' </summary>
    ''' <param name="TblName">Name of the table.</param>
    ''' <param name="Keys">The keys.</param>
    Sub AddStdTriggers(ByVal TblName As String, ByVal Keys As List(Of String))
        Dim S As String = ""
        Dim B As Boolean = False

        Dim TriggerName As String = ""

        TriggerName = "trig<XX>_Update"
        TriggerName = TriggerName.Replace("<XX>", TblName.Trim)
        S = ""
        S = S + " IF EXISTS (SELECT * FROM sys.triggers" + Environment.NewLine
        S = S + "     WHERE name = '<XX>')" + Environment.NewLine
        S = S + " DROP TRIGGER <XX>" + Environment.NewLine
        S = S.Replace("<XX>", TriggerName.Trim)
        B = ExecuteSqlNewConn(90181, S)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR: Failed to drop trigger - " + TriggerName)
        End If

        Clipboard.Clear()
        Clipboard.SetText(S)

        S = ""
        S = S + "CREATE TRIGGER trig<XX>_Update" + Environment.NewLine
        S = S + "   ON <XX>" + Environment.NewLine
        S = S + "         AFTER Update " + Environment.NewLine
        S = S + "   AS" + Environment.NewLine
        S = S + "         BEGIN " + Environment.NewLine
        S = S + "         UPDATE <XX> " + Environment.NewLine
        S = S + "   SET RowLastModDate = GETDATE(), [RepoSvrName] = @@SERVERNAME" + Environment.NewLine
        S = S + "         FROM inserted " + Environment.NewLine
        S = S + "   WHERE "
        For i As Integer = 0 To Keys.Count - 1
            If i = 0 Then
                S = S + "     <XX>" + "." + Keys(i) + " = inserted." + Keys(i) + Environment.NewLine
            Else
                S = S + "     and <XX>" + "." + Keys(i) + " = inserted." + Keys(i) + Environment.NewLine
            End If
        Next
        S = S.Replace("<XX>", TblName.Trim)
        S = S + " End" + Environment.NewLine

        Clipboard.Clear()
        Clipboard.SetText(S)

        B = ExecuteSqlNewConn(90182, S)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR: Failed to CREATE trigger - " + TriggerName)
        End If

        TriggerName = "<XX>_INS"
        TriggerName = TriggerName.Replace("<XX>", TblName.Trim)
        S = ""
        S = S + " IF EXISTS (SELECT * FROM sys.triggers" + Environment.NewLine
        S = S + "     WHERE name = '<XX>')" + Environment.NewLine
        S = S + " DROP TRIGGER <XX>" + Environment.NewLine
        S = S.Replace("<XX>", TriggerName.Trim)

        Clipboard.Clear()
        Clipboard.SetText(S)

        B = ExecuteSqlNewConn(90183, S)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR: Failed to drop trigger - " + TriggerName)
        End If

        S = ""
        S = S + " Create TRIGGER <XX>_INS" + Environment.NewLine
        S = S + "   ON dbo.<XX>" + Environment.NewLine
        S = S + "   FOR UPDATE " + Environment.NewLine
        S = S + " AS" + Environment.NewLine
        S = S + "   IF ( @@ROWCOUNT = 0 )" + Environment.NewLine
        S = S + "                 Return" + Environment.NewLine
        S = S + "   IF TRIGGER_NESTLEVEL() > 1" + Environment.NewLine
        S = S + "                 Return" + Environment.NewLine
        S = S + "   UPDATE <XX>" + Environment.NewLine
        S = S + "   SET RowLastModDate = getdate(),  RowCreationDate = getdate(), [RepoSvrName] = @@SERVERNAME" + Environment.NewLine
        S = S + "   FROM <XX> t" + Environment.NewLine
        S = S + "   JOIN inserted i" + Environment.NewLine
        'S = S + "   ON t.ArchiveID = i.ArchiveID" + environment.NewLine
        S = S + "   ON " + Environment.NewLine
        For i As Integer = 0 To Keys.Count - 1
            If i = 0 Then
                S = S + "     t" + "." + Keys(i) + " = i." + Keys(i) + Environment.NewLine
            Else
                S = S + "     and t" + "." + Keys(i) + " = i." + Keys(i) + Environment.NewLine
            End If
        Next
        S = S.Replace("<XX>", TblName.Trim)

        Clipboard.Clear()
        Clipboard.SetText(S)

        B = ExecuteSqlNewConn(90184, S)
        If Not B Then
            LOG.WriteToArchiveLog("ERROR: Failed to CREATE trigger - " + TriggerName)
        End If

        Return
    End Sub

    ''' <summary>
    ''' Verifies the standard triggers.
    ''' </summary>
    Sub VerifyStandardTriggers()

        Dim Keys As New List(Of String)
        Dim S As String = ""
        S = S + " select s.name as TABLE_SCHEMA, t.name as TABLE_NAME"
        S = S + " , k.name as CONSTRAINT_NAME, k.type_desc as CONSTRAINT_TYPE"
        S = S + " , c.name as COLUMN_NAME, ic.key_ordinal AS ORDINAL_POSITION"
        S = S + " from sys.key_constraints as k"
        S = S + " join sys.tables as t"
        S = S + " on t.object_id = k.parent_object_id"
        S = S + " join sys.schemas as s"
        S = S + " on s.schema_id = t.schema_id"
        S = S + " join sys.index_columns as ic"
        S = S + " on ic.object_id = t.object_id"
        S = S + " and ic.index_id = k.unique_index_id"
        S = S + " join sys.columns as c"
        S = S + " on c.object_id = t.object_id"
        S = S + " and c.column_id = ic.column_id"
        S = S + " order by TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME, ORDINAL_POSITION;"

        Dim RSData As SqlDataReader = Nothing

        Dim TABLE_NAME As String = ""
        Dim CONSTRAINT_NAME As String = ""
        Dim COLUMN_NAME As String = ""
        Dim CONSTRAINT_TYPE As String = ""

        Dim prevTABLE_NAME As String = ""
        Dim prevCONSTRAINT_NAME As String = ""
        Dim prevCOLUMN_NAME As String = ""

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        Dim bFirstRow As Boolean = True

        If RSData.HasRows Then
            Do While RSData.Read()
                TABLE_NAME = RSData.GetValue(1).ToString
                CONSTRAINT_NAME = RSData.GetValue(2).ToString
                COLUMN_NAME = RSData.GetValue(4).ToString
                'FrmMDIMain.SB4.Text = "Processing " + TABLE_NAME
                Application.DoEvents()
                If TABLE_NAME.Equals(prevTABLE_NAME) And CONSTRAINT_NAME.Equals(prevCONSTRAINT_NAME) Then
                    If prevTABLE_NAME.Length > 0 Then
                        Keys.Add(COLUMN_NAME)
                    End If
                Else
                    If bFirstRow Then
                        bFirstRow = False
                        Keys.Add(COLUMN_NAME)
                    Else
                        AddStdTriggers(prevTABLE_NAME, Keys)
                        Keys.Clear()
                        Keys.Add(COLUMN_NAME)
                    End If
                End If

                prevTABLE_NAME = TABLE_NAME
                prevCONSTRAINT_NAME = CONSTRAINT_NAME

            Loop
        End If

        RSData.Close()
        RSData = Nothing
        'FrmMDIMain.SB4.Text = ""
        MessageBox.Show("Triggers validated!")

    End Sub

    ''' <summary>
    ''' Counts the groups user belongs to.
    ''' </summary>
    ''' <param name="TcbLibraryName">Name of the TCB library.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Function countGroupsUserBelongsTo(ByVal TcbLibraryName As String, ByVal UserID As String) As Integer
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = ""
        TcbLibraryName = UTIL.RemoveSingleQuotes(TcbLibraryName)
        S = S + " select COUNT(*) from GroupLibraryAccess where UserID = '" + UserID + "'  and LibraryName = '" + TcbLibraryName + "'"
        Dim iCnt As Integer = iCount(S)
        Return iCnt

    End Function

    ''' <summary>
    ''' Gets the group libraries.
    ''' </summary>
    ''' <param name="GroupName">Name of the group.</param>
    ''' <param name="ListOfLibraries">The list of libraries.</param>
    Public Sub GetGroupLibraries(ByVal GroupName As String, ByRef ListOfLibraries As List(Of String))

        ListOfLibraries.Clear()
        Dim S As String = ""
        S = S + " SELECT     LibraryName from GroupLibraryAccess WHERE     GroupName = '" + GroupName + "' "

        Dim b As Boolean = True
        Dim LibraryName As String = ""

        'If UBound(TblCols, 2) > 2 Then
        '    Return
        'End If

        'ReDim TblCols (4, 0)

        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                LibraryName = RSData.GetValue(0).ToString
                ListOfLibraries.Add(LibraryName)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

    End Sub

    ''' <summary>
    ''' Resets the library users count.
    ''' </summary>
    Sub ResetLibraryUsersCount()

        Dim b As Boolean = True
        Dim S As String = "update LibraryUsers set GroupCnt = 0 "

        b = ExecuteSqlNewConn(90185, S)
        If Not b Then
            LOG.WriteToArchiveLog("ERROR: failed to reset the LibraryUsers GroupCnt - aborting.")
            Return
        End If

        S = ""
        S += " SELECT     GroupUsers.UserID, GroupLibraryAccess.LibraryName, GroupLibraryAccess.GroupName"
        S += " FROM         GroupLibraryAccess INNER JOIN"
        S += "                       GroupUsers ON GroupLibraryAccess.GroupName = GroupUsers.GroupName"
        S += " group by GroupUsers.UserID, LibraryName, GroupLibraryAccess.GroupName                      "
        S += " order by GroupUsers.UserID, LibraryName, GroupName"

        Dim UserID As String = ""
        Dim LibraryName As String = ""
        Dim GroupName As String = ""

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        Dim II As Integer = 0
        If RSData.HasRows Then
            Do While RSData.Read()
                II += 1
                If II Mod 5 = 0 Then
                    'FrmMDIMain.SB4.Text = II.ToString
                End If
                UserID = RSData.GetValue(0).ToString
                LibraryName = RSData.GetValue(1).ToString
                GroupName = RSData.GetValue(2).ToString

                LibraryName = UTIL.RemoveSingleQuotes(LibraryName)
                GroupName = UTIL.RemoveSingleQuotes(GroupName)

                S = "update LibraryUsers set GroupCnt = GroupCnt + 1 where LibraryName = '" + LibraryName + "' and UserID = '" + UserID + "'"
                b = ExecuteSqlNewConn(90186, S)
                If Not b Then
                    LOG.WriteToArchiveLog("ERROR: Failed to udpate LibraryUsers GroupCnt for Library 'xx' and user 'xx'.")
                End If
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        S = "select count(*) from LibraryUsers where (SingleUser is null or SingleUser = 0) and GroupCnt = 0 "
        Dim iCnt As Integer = iCount(S)

        If iCnt > 0 Then
            S = "delete from LibraryUsers where (SingleUser is null or SingleUser = 0) and GroupCnt = 0 "
            b = ExecuteSqlNewConn(90187, S)
            If Not b Then
                LOG.WriteToArchiveLog("ERROR XX1: Failed to delete NULL LibraryUsers." + Environment.NewLine + S)
            End If
        End If
        'FrmMDIMain.SB4.Text = "Complete."
    End Sub

    ''' <summary>
    ''' Gets the list of containing libraries.
    ''' </summary>
    ''' <param name="tGuid">The t unique identifier.</param>
    ''' <returns>System.String.</returns>
    Function getListOfContainingLibraries(ByVal tGuid As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim S As String = "select LibraryName from LibraryItems where SourceGuid = '" + tGuid + "' "
        Dim LibName As String = ""
        Dim ListOfLibs As String = ""
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                LibName = RSData.GetValue(0).ToString
                ListOfLibs += LibName + Environment.NewLine
            Loop
        Else
            ListOfLibs += "None"
        End If
        RSData.Close()
        RSData = Nothing
        Return ListOfLibs
    End Function

    ''' <summary>
    ''' Fixes the email fields.
    ''' </summary>
    Sub FixEmailFields()

        Dim S As String = ""
        S = ""
        S = S + " select emailGuid, SenderEmailAddress,SentTO  ,AllRecipients ,SenderName ,ReceivedByName ,OriginalFolder, CC , BCC "
        S = S + " from Email "
        S = S + " where "
        S = S + " SenderEmailAddress like '%''%'"
        S = S + " or SentTO  like '%''%'"
        S = S + " or AllRecipients like '%''%'"
        S = S + " or SenderName like '%''%'"
        S = S + " or ReceivedByName like '%''%'"
        S = S + " or OriginalFolder like '%''%' "
        S = S + " or CC like '%''%'"
        S = S + " or BCC like '%''%'"

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0

        Dim EmailGuid As String = ""
        Dim SenderEmailAddress As String = ""
        Dim SentTO As String = ""
        Dim AllRecipients As String = ""
        Dim SenderName As String = ""
        Dim ReceivedByName As String = ""
        Dim OriginalFolder As String = ""
        Dim CC As String = ""
        Dim BCC As String = ""

        If UBound(TblCols, 2) > 2 Then
            Return
        End If

        Dim iRec As Integer = 0
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Application.DoEvents()
                iRec += 1
                If iRec Mod 5 = 0 Then
                    'FrmMDIMain.SB4.Text = "** " + iRec.ToString
                    Application.DoEvents()
                End If
                EmailGuid = RSData.GetValue(0).ToString()
                SenderEmailAddress = RSData.GetValue(1).ToString()
                SentTO = RSData.GetValue(2).ToString()
                AllRecipients = RSData.GetValue(3).ToString()
                SenderName = RSData.GetValue(4).ToString()
                ReceivedByName = RSData.GetValue(5).ToString()
                OriginalFolder = RSData.GetValue(6).ToString()
                CC = RSData.GetValue(7).ToString()
                BCC = RSData.GetValue(8).ToString()

                UTIL.StripSingleQuotes(SenderEmailAddress)
                UTIL.StripSingleQuotes(SentTO)
                UTIL.StripSingleQuotes(AllRecipients)
                UTIL.StripSingleQuotes(SenderName)
                UTIL.StripSingleQuotes(ReceivedByName)
                UTIL.StripSingleQuotes(OriginalFolder)
                UTIL.StripSingleQuotes(CC)
                UTIL.StripSingleQuotes(BCC)

                Dim UpdateSql As String = ""
                UpdateSql = UpdateSql + " update Email set "
                UpdateSql = UpdateSql + " SenderEmailAddress ='" + SenderEmailAddress + "',"
                UpdateSql = UpdateSql + "  SentTO ='" + SentTO + "',"
                UpdateSql = UpdateSql + "  AllRecipients ='" + AllRecipients + "',"
                UpdateSql = UpdateSql + "  SenderName ='" + SenderName + "',"
                UpdateSql = UpdateSql + "  ReceivedByName ='" + ReceivedByName + "',"
                UpdateSql = UpdateSql + "  OriginalFolder ='" + OriginalFolder + "',"
                UpdateSql = UpdateSql + "  CC ='" + CC + "',"
                UpdateSql = UpdateSql + "  BCC ='" + BCC + "' "
                UpdateSql = UpdateSql + " where EmailGuid = '" + EmailGuid + "'"

                b = ExecuteSqlNewConn(90188, UpdateSql)
                If Not b Then
                    Console.WriteLine("ERROR: " + UpdateSql)
                End If

            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing
        'FrmMDIMain.SB4.Text = ""

        FixEmailRecipients()

    End Sub

    ''' <summary>
    ''' Fixes the email recipients.
    ''' </summary>
    Sub FixEmailRecipients()

        Dim Recipient As String = ""
        Dim S As String = "SELECT distinct [Recipient] FROM [Recipients] where [Recipient] like '%''%'"
        Dim L As New List(Of String)

        Dim b As Boolean = True
        Dim i As Integer = 0
        Dim id As Integer = -1
        Dim II As Integer = 0

        Dim EmailGuid As String = ""

        If UBound(TblCols, 2) > 2 Then
            Return
        End If

        Dim iRec As Integer = 0
        Dim RSData As SqlDataReader = Nothing
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                Application.DoEvents()
                iRec += 1
                If iRec Mod 5 = 0 Then
                    'FrmMDIMain.SB4.Text = "** " + iRec.ToString
                    Application.DoEvents()
                End If
                Recipient = RSData.GetValue(0).ToString()

                If Not L.Contains(Recipient) Then
                    L.Add(Recipient)
                End If
            Loop
        Else
            id = -1
        End If
        RSData.Close()
        RSData = Nothing

        For i = 0 To L.Count - 1
            S = L.Item(i)
            S = UTIL.RemoveSingleQuotes(S)
            Recipient = L.Item(i)
            UTIL.StripSingleQuotes(Recipient)
            Dim UpdateSql As String = ""
            UpdateSql = UpdateSql + " update Recipients set "
            UpdateSql = UpdateSql + " Recipient ='" + Recipient + "' "
            UpdateSql = UpdateSql + " where Recipient = '" + S + "'"

            b = ExecuteSqlNewConn(90189, UpdateSql)
            If Not b Then
                Console.WriteLine("ERROR: " + UpdateSql)
            End If
        Next

        'FrmMDIMain.SB4.Text = ""
    End Sub

    ''' <summary>
    ''' Records the growth.
    ''' </summary>
    Sub RecordGrowth()
        Dim S As String = ""
        S = S + " IF OBJECT_ID('DatabaseFiles') IS NULL"
        S = S + " BEGIN"
        S = S + " SELECT TOP 0 * INTO DatabaseFiles"
        S = S + " FROM sys.database_files    "
        S = S + " "
        S = S + " ALTER TABLE DatabaseFiles"
        S = S + " ADD CreationDate DATETIME DEFAULT(GETDATE())"
        S = S + " End"
        Dim b As Boolean = ExecuteSqlNewConn(90190, S)
        If Not b Then
            Console.WriteLine("ERROR: RecordGrowth = " + S)
        End If

        S = S + " EXECUTE sp_msforeachdb 'INSERT INTO DatabaseFiles SELECT *, GETDATE() FROM [?].sys.database_files'"
        b = ExecuteSqlNewConn(90191, S)
        If Not b Then
            Console.WriteLine("ERROR: RecordGrowth = " + S)
        End If

    End Sub

    ''' <summary>
    ''' Emails the hash rows.
    ''' </summary>
    Sub EmailHashRows()

        Dim S As String = ""
        S = ""
        S = S + " select subject, CreationTime, SenderEmailAddress, nbrAttachments, SourceTypeCode "
        S = S + " from Email where RecHash is NULL"

        Dim EmailGuid As String = ""
        Dim SenderEmailAddress As String = ""
        Dim subject As String = ""
        Dim body As String = ""
        Dim CreationTime As String = ""
        Dim nbrAttachments As String = ""
        Dim SourceTypeCode As String = ""
        Dim FileExt As String = ""
        Dim tHash As String = ""
        Dim tKey As String = ""

        Dim iCnt As Integer = 0

        Dim L As New SortedList(Of String, String)

        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        UTIL.setConnectionStringTimeout(CS, "10000")
        Dim JumpTo As Integer = 0

        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        Dim ProcessData As Boolean = False

        If RSData.HasRows And ProcessData = True Then
            Do While RSData.Read()
                iCnt += 1
                Application.DoEvents()
                If iCnt Mod 50 = 0 Then
                    'FrmMDIMain.SB4.Text = iCnt.ToString
                    Application.DoEvents()
                    'System.Threading.Thread.Sleep(250)
                End If

                If JumpTo > 0 And iCnt < JumpTo Then
                    GoTo NextOne
                End If

                EmailGuid = RSData.GetValue(0).ToString()
                subject = RSData.GetValue(1).ToString()
                CreationTime = RSData.GetValue(2).ToString()
                SenderEmailAddress = RSData.GetValue(3).ToString()
                nbrAttachments = RSData.GetValue(4).ToString()
                SourceTypeCode = RSData.GetValue(5).ToString()

                tKey = subject + Chr(254) + CreationTime + Chr(254) + SenderEmailAddress + Chr(254) + nbrAttachments + Chr(254) + SourceTypeCode
                tHash = KGEN.genEmailHashCode(subject, body, SenderEmailAddress, CreationTime, nbrAttachments, FileExt)

                LOG.WriteToEmailDuplicateLog("E", EmailGuid, tHash)
NextOne:
            Loop
        Else
            RSData.Close()
            RSData = Nothing
            'FrmMDIMain.SB4.Text = ""
            Return
        End If
        RSData.Close()
        RSData = Nothing
        'FrmMDIMain.SB4.Text = ""

        LOG.LoadEmailDupLog(L)
        EmailHashRowsApply(L, CS)

        'FrmMDIMain.SB4.Text = "Done."
        L = Nothing

    End Sub

    ''' <summary>
    ''' Emails the hash rows apply.
    ''' </summary>
    ''' <param name="L">The l.</param>
    ''' <param name="CS">The cs.</param>
    Sub EmailHashRowsApply(ByRef L As SortedList(Of String, String), ByVal CS As String)
        Dim rc As Boolean = False
        Dim CN As New SqlConnection(CS)
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()
        Dim BB As Boolean = True
        Dim EmailGuid As String = ""
        Dim tHash As String = ""
        Dim iCnt As Integer = 0

        Dim SkipTo As Integer = 215035

        Dim UpdateSql As String = ""
        Dim B As Boolean = True
        For I As Integer = SkipTo To L.Count - 1
            Application.DoEvents()
            Try
                EmailGuid = L.Keys(I)
                tHash = L.Values(I)
                UpdateSql = "Update Email set RecHash = '" + tHash + "' where EmailGuid = '" + EmailGuid + "'"

                'B = ExecuteSqlNewConn(90192,UpdateSql)
                Try
                    B = True
                    dbCmd.CommandText = UpdateSql
                    dbCmd.ExecuteNonQuery()
                Catch ex As Exception
                    Console.WriteLine(ex.Message)
                    B = False
                End Try

                'If I Mod 100 = 0 Then
                '    Try
                '        dbCmd.CommandText = "GO"
                '        dbCmd.ExecuteNonQuery()
                '    Catch ex As Exception
                '        Console.WriteLine("ERROR: EmailHashRows 200 - " , ex)
                '    End Try

                'End If

                If Not B Then
                    Console.WriteLine("ERROR: " + UpdateSql)
                End If
                iCnt += 1
                If I Mod 10 = 0 Then
                    'FrmMDIMain.SB4.Text = "** " + I.ToString
                    Application.DoEvents()
                End If
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR 100 - EmailHashRowsApply: " + ex.Message + Environment.NewLine + UpdateSql)
                B = False
            End Try
        Next
        If B = True Then
            L.Clear()
        End If

        CN.Close()
        CN.Dispose()
    End Sub

    ''' <summary>
    ''' Contents the hash rows.
    ''' </summary>
    Sub ContentHashRows()

        Dim S As String = ""
        S = ""
        S = S + " SELECT [SourceGuid],[VersionNbr], CreateDate,[SourceName],[OriginalFileType],[FileLength],[CRC] "
        S = S + " FROM [DataSource] where RecHash is NULL"

        Dim SourceGuid As String = ""
        'Dim VersionNbr As String = ""
        Dim CreateDate As String = ""
        Dim SourceName As String = ""
        Dim OriginalFileType As String = ""
        Dim FileLength As String = ""
        Dim CRC As String = ""

        Dim tHash As String = ""
        Dim tKey As String = ""

        Dim iCnt As Integer = 0

        Dim L As New SortedList(Of String, String)

        Dim RSData As SqlDataReader = Nothing

        Dim CS As String = getRepoConnStr()
        UTIL.setConnectionStringTimeout(CS, "10000")
        Dim JumpTo As Integer = 0

        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()

        Dim ProcessData As Boolean = False

        If RSData.HasRows And ProcessData = True Then
            Do While RSData.Read()
                iCnt += 1
                Application.DoEvents()
                If iCnt Mod 50 = 0 Then
                    'FrmMDIMain.SB4.Text = iCnt.ToString
                    Application.DoEvents()
                    'System.Threading.Thread.Sleep(250)
                End If

                If JumpTo > 0 And iCnt < JumpTo Then
                    GoTo NextOne
                End If

                SourceGuid = RSData.GetValue(0).ToString()
                'VersionNbr = RSData.GetValue(1).ToString()
                CreateDate = RSData.GetValue(2).ToString()
                SourceName = RSData.GetValue(3).ToString()
                OriginalFileType = RSData.GetValue(4).ToString()
                FileLength = RSData.GetValue(5).ToString()
                CRC = RSData.GetValue(6).ToString()

                tKey = CreateDate + Chr(254) + SourceName + Chr(254) + OriginalFileType + Chr(254) + FileLength + Chr(254) + CRC
                tHash = KGEN.genHashContent(CreateDate, SourceName, OriginalFileType, FileLength, CRC)

                LOG.WriteToContentDuplicateLog("C", SourceGuid, tHash)
NextOne:
            Loop
        Else
            RSData.Close()
            RSData = Nothing
            'FrmMDIMain.SB4.Text = ""
            Return
        End If
        RSData.Close()
        RSData = Nothing
        'FrmMDIMain.SB4.Text = ""

        LOG.LoadContentDupLog(L)
        ContentHashRowsApply(L, CS)

        'FrmMDIMain.SB4.Text = "Done: Content Keyed"
        L = Nothing

    End Sub

    ''' <summary>
    ''' Contents the hash rows apply.
    ''' </summary>
    ''' <param name="L">The l.</param>
    ''' <param name="CS">The cs.</param>
    Sub ContentHashRowsApply(ByRef L As SortedList(Of String, String), ByVal CS As String)
        Dim rc As Boolean = False
        Dim CN As New SqlConnection(CS)
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()
        Dim BB As Boolean = True
        Dim SourceGuid As String = ""
        Dim tHash As String = ""
        Dim iCnt As Integer = 0

        Dim SkipTo As Integer = 215035

        Dim UpdateSql As String = ""
        Dim B As Boolean = True
        For I As Integer = SkipTo To L.Count - 1
            Application.DoEvents()
            Try
                SourceGuid = L.Keys(I)
                tHash = L.Values(I)
                UpdateSql = "Update DataSource set RecHash = '" + tHash + "' where SourceGuid = '" + SourceGuid + "'"

                Try
                    B = True
                    dbCmd.CommandText = UpdateSql
                    dbCmd.ExecuteNonQuery()
                Catch ex As Exception
                    Console.WriteLine(ex.Message)
                    B = False
                End Try

                If Not B Then
                    Console.WriteLine("ERROR: " + UpdateSql)
                End If
                iCnt += 1
                If I Mod 10 = 0 Then
                    'FrmMDIMain.SB4.Text = "** " + I.ToString
                    Application.DoEvents()
                End If
            Catch ex As Exception
                LOG.WriteToArchiveLog("ERROR 100 - EmailHashRowsApply: " + ex.Message + Environment.NewLine + UpdateSql)
                B = False
            End Try
        Next
        If B = True Then
            L.Clear()
        End If

        CN.Close()
        CN.Dispose()
    End Sub

    ''' <summary>
    ''' Contents the add hash.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="tHash">The t hash.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    Sub ContentAddHash(ByVal SourceGuid As String, ByVal tHash As String, ByVal MachineID As String)

        Dim CS As String = getRepoConnStr()
        Dim CN As New SqlConnection(CS)
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()
        Dim BB As Boolean = True
        Dim iCnt As Integer = 0
        'where FQN = '" + FQN + "' and DataSourceOwnerUserID = '" + UserID  + "'"
        Dim UpdateSql As String = "Update DataSource set RecHash = '" + tHash + "', MachineID = '" + MachineID + "' where SourceGuid = '" + SourceGuid + "'"

        Dim B As Boolean = True
        Try
            B = True
            dbCmd.CommandText = UpdateSql
            dbCmd.ExecuteNonQuery()
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: ContentHashRowsApply - 100 " + UpdateSql)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: ContentHashRowsApply - 200 " + ex.Message + Environment.NewLine + UpdateSql)
            B = False
        End Try

        CN.Close()
        CN.Dispose()
    End Sub

    ''' <summary>
    ''' Emails the add hash.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="EmailIdentifier">The email identifier.</param>
    Sub EmailAddHash(ByVal EmailGuid As String, ByVal EmailIdentifier As String)

        Dim CS As String = getRepoConnStr()
        Dim CN As New SqlConnection(CS)
        CN.Open()
        Dim dbCmd As SqlCommand = CN.CreateCommand()
        Dim BB As Boolean = True
        Dim iCnt As Integer = 0

        EmailIdentifier = EmailIdentifier.Replace("'", "''")

        Dim UpdateSql As String = "Update Email set EmailIdentifier = '" + EmailIdentifier + "' where EmailGuid = '" + EmailGuid + "'"

        Dim B As Boolean = True
        Try
            B = True
            dbCmd.CommandText = UpdateSql
            dbCmd.ExecuteNonQuery()
            If Not B Then
                LOG.WriteToArchiveLog("ERROR: EmailHashRowsApply - 100 " + UpdateSql)
            End If
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR: EmailHashRowsApply - 200 " + ex.Message + Environment.NewLine + UpdateSql)
            B = False
        End Try

        CN.Close()
        CN.Dispose()
    End Sub

    ''' <summary>
    ''' Gens the email hash code.
    ''' </summary>
    ''' <param name="subject">The subject.</param>
    ''' <param name="body">The body.</param>
    ''' <param name="CreationTime">The creation time.</param>
    ''' <param name="SenderEmailAddress">The sender email address.</param>
    ''' <param name="nbrAttachments">The NBR attachments.</param>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <returns>System.String.</returns>
    Public Function genEmailHashCode(ByVal subject As String,
                             ByVal body As String,
                             ByVal CreationTime As String,
                             ByVal SenderEmailAddress As String,
                             ByVal nbrAttachments As String,
                             ByVal SourceTypeCode As String) As String

        Dim tHash As String = KGEN.genEmailHashCode(subject, body, SenderEmailAddress, CreationTime, nbrAttachments, SourceTypeCode)
        Return tHash

    End Function

    ''' <summary>
    ''' xes the xadd content hash key.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="OriginalFileType">Type of the original file.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    Sub XXaddContentHashKey(ByVal SourceGuid As String,
                        ByVal VersionNbr As String,
                        ByVal CreateDate As String,
                        ByVal SourceName As String,
                        ByVal OriginalFileType As String,
                        ByVal FileLength As String,
                        ByVal CRC As String, ByVal MachineID As String)

        Dim tHash As String = KGEN.genHashContent(CreateDate, SourceName, OriginalFileType, FileLength, CRC)
        ContentAddHash(SourceGuid, tHash, MachineID)

    End Sub

    ''' <summary>
    ''' Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.
    ''' </summary>
    Protected Overrides Sub Finalize()
        KGEN = Nothing
        MyBase.Finalize()
    End Sub

    ''' <summary>
    ''' Cleans up email folders.
    ''' </summary>
    Sub CleanUpEmailFolders()

        Dim S As String = ""
        S = S + "         DELETE"
        S = S + "         FROM EmailFolder "
        S = S + " WHERE nRowID NOT IN"
        S = S + " ("
        S = S + " Select Max(nRowID)"
        S = S + " FROM EmailFolder"
        S = S + " GROUP BY userid, folderid"
        S = S + " )"

        Dim B As Boolean = ExecuteSqlNewConn(90193, S)

        S = ""
        S = S + " delete from EmailArchParms "
        S = S + " where FolderName not in (select FolderName from EmailFolder)"

        B = ExecuteSqlNewConn(90194, S)

    End Sub

    ''' <summary>
    ''' bs the file name exists.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function bFileNameExists(ByVal SourceName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = True
        Dim I As Integer = 0
        Dim S As String = ""
        S = S + " SELECT count(*) from DataSource where SourceName = '" + SourceName + "'"
        I = iCount(S)
        If I > 0 Then
            B = True
        Else
            B = False
        End If
        Return B
    End Function

    ''' <summary>
    ''' bs the identical file.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function bIdenticalFile(ByVal SourceName As String,
                            ByVal CRC As String,
                            ByVal CreateDate As String,
                            ByVal LastAccessDate As String,
                            ByVal FileLength As Integer) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = True

        B = bFileNameExists(SourceName)
        If B = False Then
            '** the file does not exist.
            Return B
        End If

        '** The file does exist, verify wherther it is a duplicate file or not

        Return B
    End Function

    ''' <summary>
    ''' Gets the user unique identifier by login identifier.
    ''' </summary>
    ''' <param name="LoginID">The login identifier.</param>
    ''' <returns>System.String.</returns>
    Function getUserGuidByLoginID(ByVal LoginID As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        If LoginID.Length = 0 Then
            Return ""
        End If

        Dim S As String = "SELECT [UserID] FROM [Users] where [UserLoginID] = '" + LoginID + "'"
        Dim UGuid As String = ""
        Dim cnt As Integer = 0
        Dim rsCnt As SqlDataReader = Nothing

        Try
            rsCnt = SqlQryNewConn(S)
            If rsCnt.HasRows Then
                Do While rsCnt.Read
                    UGuid = rsCnt.GetValue(0).ToString
                Loop
            End If
        Catch ex As Exception
            UGuid = ""
            LOG.WriteToArchiveLog("getUserGuidByLoginID : 5406 : ", ex)
        Finally
            If Not rsCnt Is Nothing Then
                If Not rsCnt.IsClosed Then
                    rsCnt.Close()
                End If
                rsCnt = Nothing
            End If
        End Try

        Return UGuid
    End Function

    ''' <summary>
    ''' Appends the ocr text email.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="OCR_Text">The ocr text.</param>
    Sub AppendOcrTextEmail(ByVal SourceGuid As String, ByVal OCR_Text As String)

        Dim OcrText As String = OCR_Text
        Dim S As String = ""
        Dim b As Boolean = False

        Dim EmailBody As String = GetEmailBody(SourceGuid)

        EmailBody = EmailBody + " " + OCR_Text

        EmailBody = EmailBody.Replace("''", "'")
        EmailBody = EmailBody.Replace("'", "''")

        S = "update EMAIL set Body = '" + EmailBody + "' where EmailGuid = '" + SourceGuid + "'"

        b = ExecuteSqlNewConn(90195, S)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Appends the ocr text email.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub AppendOcrTextEmail(ByVal SourceGuid As String)

        Dim OcrText As String = ""
        Dim S As String = ""
        Dim b As Boolean = False

        'Dim S  = "update DataSource set GraphicContainsText = 'Y' where SourceGuid = '" + SourceGuid + "'"
        'Dim b As Boolean = ExecuteSqlNewConn(90196,S, False)
        'If Not b Then
        '    If ddebug Then Debug.Print("Failed to set OCR Attributes")
        'End If

        Dim EmailBody As String = GetEmailBody(SourceGuid)

        OcrText = GetAllOcrData(SourceGuid)
        OcrText = UTIL.ReplaceSingleQuotesV1(OcrText)

        EmailBody = UTIL.ReplaceSingleQuotesV1(EmailBody)
        EmailBody = EmailBody + OcrText
        'CleanText(EmailBody)

        S = "update EMAIL set BODY = '" + EmailBody + "' where EmailGuid = '" + SourceGuid + "'"
        'System.Windows.Forms.Clipboard.Clear()
        'System.Windows.Forms.Clipboard.SetText(S)

        b = ExecuteSqlNewConn(90197, S)
        If Not b Then
            If ddebug Then Debug.Print("Failed to set OCR Attributes")
        End If
    End Sub

    ''' <summary>
    ''' Gets all ocr data.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <returns>System.String.</returns>
    Private Function GetAllOcrData(ByVal EmailGuid As String) As String
        Dim S As String = "select OcrText from emailattachment where EmailGuid = '" + EmailGuid + "'"
        Dim AllText As String = ""
        Dim ConnStr As String = getRepoConnStr()
        Dim Conn As New SqlConnection(ConnStr)
        If Conn.State = ConnectionState.Closed Then
            Conn.Open()
        End If

        Dim rsData As SqlDataReader = Nothing
        rsData = SqlQryNewConn(S)

        If rsData.HasRows Then
            Do While rsData.Read()
                AllText = AllText + rsData.GetValue(0).ToString + Chr(254)
            Loop
        End If

        Return AllText

    End Function

    ''' <summary>
    ''' Counts the unique entry.
    ''' </summary>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function cnt_UniqueEntry(ByVal LibraryName As String, ByVal SourceGuid As String) As Integer

        LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

        Dim B As Integer = 0
        Dim TBL As String = "LibraryItems"
        Dim WC As String = "Where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "' "

        B = iGetRowCount(TBL, WC)

        Return B
    End Function     '** cnt_UK_LibItems

    ''' <summary>
    ''' Sets the email ocr text.
    ''' </summary>
    ''' <param name="Body">The body.</param>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="OcrText">The ocr text.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    Sub SetEmailOcrText(ByVal Body As String, ByVal EmailGuid As String, ByVal OcrText As String, ByVal AttachmentName As String)

        AttachmentName = AttachmentName.Replace("'", "''")

        OcrText = UTIL.BlankOutSingleQuotes(OcrText)

        Dim S As String = "update EmailAttachment set OcrText = '" + OcrText + "' where EmailGuid = '" + EmailGuid + "' and AttachmentName = '" + AttachmentName + "'"

        Dim b As Boolean = ExecuteSqlNewConn(S, False)
        If Not b Then
            LOG.WriteToArchiveLog("ERROR: 100 Failed to set Email OCR Attributes")
        End If

    End Sub

    ''' <summary>
    ''' Adds the document source error.
    ''' </summary>
    ''' <param name="SourceType">Type of the source.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="Notes">The notes.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function addDocSourceError(ByVal SourceType As String, ByVal SourceGuid As String, ByVal Notes As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Notes = UTIL.RemoveSingleQuotes(Notes)
        Dim mySql As String = ""
        If SourceType.ToUpper.Equals("CONTENT") Then
            mySql = "UPDATE [DataSource] set Notes = '" + Notes + "' where SourceGuid = '" + SourceGuid + "'"
        Else
            mySql = "UPDATE Email set Notes = '" + Notes + "' where EmailGuid = '" + SourceGuid + "'"
        End If
        Dim b As Boolean = ExecuteSqlNewConn(mySql, False)
        Return b
    End Function

    ''' <summary>
    ''' Adds the library item.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="ItemTitle">The item title.</param>
    ''' <param name="FileExt">The file ext.</param>
    ''' <param name="LibraryName">Name of the library.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function AddLibraryItem(ByVal SourceGuid As String, ByVal ItemTitle As String, ByVal FileExt As String, ByVal LibraryName As String) As Boolean

        ItemTitle = UTIL.RemoveSingleQuotes(ItemTitle)
        LibraryName = UTIL.RemoveSingleQuotes(LibraryName)

        Dim LibraryOwnerUserID As String = gCurrUserGuidID
        Dim DataSourceOwnerUserID As String = gCurrUserGuidID
        Dim LibraryItemGuid As String = Guid.NewGuid.ToString
        Dim AddedByUserGuidId As String = gCurrUserGuidID

        Dim SS As String = "Select count(*) from LibraryItems where LibraryName = '" + LibraryName + "' and SourceGuid = '" + SourceGuid + "'"
        Dim iCnt As Integer = iCount(SS)
        If iCnt > 0 Then
            Return True
        End If

        Dim b As Boolean = False
        Dim s As String = ""
        s = s + " INSERT INTO LibraryItems("
        s = s + "SourceGuid,"
        s = s + "ItemTitle,"
        s = s + "ItemType,"
        s = s + "LibraryItemGuid,"
        s = s + "DataSourceOwnerUserID,"
        s = s + "LibraryOwnerUserID,"
        s = s + "LibraryName,"
        s = s + "AddedByUserGuidId) values ("
        s = s + "'" + SourceGuid + "'" + ","
        s = s + "'" + ItemTitle + "'" + ","
        s = s + "'" + FileExt + "'" + ","
        s = s + "'" + LibraryItemGuid + "'" + ","
        s = s + "'" + DataSourceOwnerUserID + "'" + ","
        s = s + "'" + LibraryOwnerUserID + "'" + ","
        s = s + "'" + LibraryName + "'" + ","
        s = s + "'" + AddedByUserGuidId + "'" + ")"

        System.Windows.Forms.Application.DoEvents()

        Dim BB As Boolean = ExecuteSqlNewConn(s, False)

        If BB = False Then
            LOG.WriteToArchiveLog("ERROR: AddLibraryItem 100 - Failed to add '" + ItemTitle + "' to library '" + LibraryName + "'.")
        Else
            If ddebug Then LOG.WriteToArchiveLog("NOTICE : AddLibraryItem :'" + ItemTitle + "' to library '" + LibraryName + "'.")
        End If

        Return BB

    End Function

    ''' <summary>
    ''' Adds the excg key.
    ''' </summary>
    ''' <param name="ExcgKey">The excg key.</param>
    Sub AddExcgKey(ByVal ExcgKey As String)
        Dim S As String = "INSERT INTO [ExcgKey] ([MailKey]) VALUES ('" + ExcgKey.ToString + "')"
        Dim B As Boolean = ExecuteSqlNewConn(90198, S)
    End Sub

    ''' <summary>
    ''' Deletes the directory.
    ''' </summary>
    ''' <param name="dirPath">The dir path.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function DeleteDirectory(ByVal dirPath As String) As Boolean

        Dim objDI As New DirectoryInfo(dirPath)
        Try
            objDI.Delete(True)
            Return True
        Catch ex As Exception
            Console.WriteLine(ex.Message)
            Return False
        End Try
    End Function

    ''' <summary>
    ''' Creates the dir.
    ''' </summary>
    ''' <param name="dirPath">The dir path.</param>
    Sub CreateDir(ByVal dirPath As String)
        Try
            If Directory.Exists(dirPath) Then
            Else
                Directory.CreateDirectory(dirPath)
            End If
        Catch ex As Exception
            Console.WriteLine(ex.Message)
        End Try

    End Sub

    ' Public Sub PDFXTRACT(ByVal SourceGuid , ByVal FQN , ByVal SourceType As String)

    ' Dim currDir As String = DMA.GetFilePath(FQN)

    ' Dim RetentionCode As String = "Retain 10" Dim ispublic As String = "N"

    ' If gPdfExtended = False Then Return End If Dim xDate As Date = #8/31/2010#

    ' Dim PdfImages As New List(Of String) '**WDM Dim PDF As New clsPdfAnalyzer Dim B As Boolean = False

    ' Try Dim FileExt = DMA.getFileExtension(FQN) If FileExt.ToUpper.Equals(".PDF") Then

    ' Dim S = "" If SourceType.ToUpper.Equals("CONTEXT") Then S = "Update DataSource set OcrText = ''
    ' where SourceGuid = '" + SourceGuid + "' " Else S = "Update EmailAttachment set OcrText = ''
    ' where EmailGuid = '" + SourceGuid + "' " End If

    ' B = ExecuteSqlNewConn(90199,S)

    ' Dim iCnt As Integer = PDF.ExtractImages(SourceGuid , FQN , PdfImages)

    ' If iCnt > 0 Then Try frmExchangeMonitor.lblMessageInfo.Text = FQN
    ' frmExchangeMonitor.lblMessageInfo.Refresh() System.Windows.Forms.Application.DoEvents() Dim
    ' tFqn As String = "" For II As Integer = 0 To PdfImages.Count - 1

    ' Dim Sha1Hash As String = ENC.getCountDataSourceFiles(tFqn)

    ' frmExchangeMonitor.lblMessageInfo.Text = II.ToString + " of " + PdfImages.Count.ToString + "
    ' PDF Images." frmExchangeMonitor.lblMessageInfo.Refresh() System.Windows.Forms.Application.DoEvents()

    ' tFqn = PdfImages(II) Dim AttachmentName As String = DMA.getFileName(tFqn ) 'DOES THE FILE EXIST
    ' HERE? If SourceType.Equals("CONTENT") Then Else Dim AttachmentExists As Integer =
    ' iCount("select count(*) from EmailAttachment where EmailGuid = '" + SourceGuid + "' and
    ' AttachmentName = '" + AttachmentName + "' ") If AttachmentExists = 0 Then Dim BB As Boolean =
    ' InsertAttachmentFqn(gCurrUserGuidID, tFqn , SourceGuid , AttachmentName , FileExt ,
    ' gCurrUserGuidID, RetentionCode, Sha1Hash, ispublic, currDir) If BB = False Then GoTo SKIPX01
    ' End If End If End If

    '                            System.Threading.Thread.Sleep(100)
    'SKIPX01:
    '                        Next

    ' Catch ex As Exception LOG.WriteToArchiveLog("ERROR PDFXTRACT 100 - " + FQN + environment.NewLine +
    ' ex.Message) End Try End If

    ' Dim PdfContent As String = PDF.ExtractText(FQN )

    ' If PdfContent.Trim.Length > 0 Then AppendOcrText(SourceGuid , PdfContent) End If

    ' End If Catch ex As Exception LOG.WriteToArchiveLog("ERROR: PDFXTRACT 100 - " + ex.message +
    ' environment.NewLine + FQN) Finally PDF = Nothing PdfImages = Nothing GC.Collect() End Try

    ' System.Windows.Forms.Application.DoEvents()

    ' End Sub

    ''' <summary>
    ''' Loads the exck keys.
    ''' </summary>
    ''' <param name="L">The l.</param>
    Sub LoadExckKeys(ByRef L As SortedList(Of String, String))
        Dim SS As String = "select count(*) from [ExcgKey]"
        Dim iKeyCnt As Integer = iCount(SS)

        If iKeyCnt = 0 Then
            Return
        Else
            frmMain.PB1.Maximum = iKeyCnt + 5
        End If
        frmMain.PB1.Value = 0

        Dim S As String = "select distinct(mailkey) from [ExcgKey]"
        L.Clear()
        Dim mailkey As String = ""

        Dim cnt As Integer = 0
        CloseConn()
        CkConn()
        Dim ConnStr As String = getRepoConnStr()
        Try
            Using gConn
                Dim command As New SqlCommand(S, gConn)
                Dim rsCnt As SqlDataReader = Nothing
                rsCnt = SqlQry(S, gConn)
                If rsCnt.HasRows Then
                    Do While rsCnt.Read
                        cnt += 1
                        frmMain.PB1.Value = cnt
                        mailkey = rsCnt.GetValue(0).ToString
                        If L.IndexOfKey(mailkey) < 0 Then
                            Try
                                L.Add(mailkey, mailkey)
                            Catch ex2 As System.Exception
                                Console.WriteLine(ex2.Message)
                            End Try
                        End If
                    Loop
                End If

                rsCnt.Close()
                rsCnt = Nothing
                command.Connection.Close()
                command = Nothing
            End Using
        Catch ex As System.Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : LoadExckKeys : 100 : ", ex)
        Finally
            frmMain.PB1.Value = 0
        End Try
        CloseConn()
    End Sub

    ' ''' <summary>
    ' ''' This is not HOOKED into the system yet (3/20/11). It's purpose will be to speed up the
    ' ''' search and loading of emails by 100 fold.
    ' ''' </summary>
    ' ''' <param name="L">A sorted list of strings/strings</param>
    ' ''' <param name="CurrUserID">The user ID currently executing the archive.</param>
    ' ''' <remarks></remarks>
    'Function LoadOutlookKeys(ByRef L As SortedList(Of String, String), ByVal CurrUserID As String) As Boolean

    ' Dim Limit As Integer = 1000000 Dim B As Boolean = True Dim SS As String = "select COUNT(*) from
    ' Email where UserID = '" + CurrUserID + "'" Dim iKeyCnt As Integer = iCount(SS)

    ' If iKeyCnt = 0 Or iKeyCnt > Limit Then Return False Else frmReconMain.SB.Text = "Loading " +
    ' iKeyCnt.ToString + "Outlook keys, standby." frmReconMain.PB1.Maximum = iKeyCnt + 5 End If
    ' frmReconMain.PB1.Value = 0

    ' Dim S As String = "select distinct(EntryID) from Email where UserID = '" + CurrUserID + "'"
    ' L.Clear() Dim mailkey As String = ""

    ' Dim cnt As Integer = 0 CloseConn() CkConn() Dim ConnStr As String = getRepoConnStr() Try Using
    ' gConn Dim command As New SqlCommand(S, gConn) Dim rsCnt As SqlDataReader = Nothing rsCnt =
    ' SqlQry(S, gConn) If rsCnt.HasRows Then Do While rsCnt.Read cnt += 1 frmReconMain.PB1.Value =
    ' cnt mailkey = rsCnt.GetValue(0).ToString If L.IndexOfKey(mailkey) < 0 Then Try L.Add(mailkey,
    ' cnt.ToString) Catch ex2 As System.Exception Console.WriteLine(ex2.Message) End Try End If Loop
    ' End If

    '            rsCnt.Close()
    '            rsCnt = Nothing
    '            command.Connection.Close()
    '            command = Nothing
    '        End Using
    '    Catch ex As System.Exception
    '        log.WriteToArchiveLog("clsDatabaseARCH : LoadExckKeys : 100 : " , ex)
    '        B = False
    '    Finally
    '        frmReconMain.PB1.Value = 0
    '    End Try
    '    CloseConn()
    '    Return B
    'End Function

    ''' <summary>
    ''' This is not HOOKED into the system yet (3/20/11). It's purpose will be to speed up the search
    ''' for existing outlook emails but will not be as fast as if the function "LoadOutlookKeys" is
    ''' used, but has unlimited size as one record at a time is searched.
    ''' </summary>
    ''' <param name="EntryID">The entry identifier.</param>
    ''' <param name="CurrUserID">The curr user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckEntryIdExists(ByVal EntryID As String, ByVal CurrUserID As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim SS As String = "select COUNT(*) from Email where UserID = '" + CurrUserID + "'"
        Dim iKeyCnt As Integer = iCount(SS)
        If iKeyCnt > 0 Then
            Return True
        Else
            Return False
        End If
    End Function

    ''' <summary>
    ''' Adds the source type code.
    ''' </summary>
    ''' <param name="SourceTypeCode">The source type code.</param>
    ''' <param name="bStoreExternal">The b store external.</param>
    ''' <param name="SourceTypeDesc">The source type desc.</param>
    ''' <param name="bIndexable">The b indexable.</param>
    Public Sub AddSourceTypeCode(ByVal SourceTypeCode As String, ByVal bStoreExternal As Integer, ByVal SourceTypeDesc As String, ByVal bIndexable As Integer)

        If InStr(SourceTypeCode, ".") = 0 Then
            SourceTypeCode = "." + SourceTypeCode
        End If
        SourceTypeDesc = SourceTypeDesc.Replace("'", "`")

        Dim b As Boolean = False
        Dim s As String = ""

        s = s + " IF not Exists (Select SourceTypeCode from SourceType where SourceTypeCode = '" + SourceTypeCode + "') " + Environment.NewLine
        s = s + " INSERT INTO SourceType(" + Environment.NewLine
        s = s + "SourceTypeCode," + Environment.NewLine
        s = s + "StoreExternal," + Environment.NewLine
        s = s + "SourceTypeDesc," + Environment.NewLine
        s = s + "Indexable) values (" + Environment.NewLine
        s = s + "'" + SourceTypeCode + "'" + "," + Environment.NewLine
        s = s & bStoreExternal & "," + Environment.NewLine
        s = s + "'" + SourceTypeDesc + "'" + "," + Environment.NewLine
        s = s & bIndexable & ")" + Environment.NewLine

        b = ExecuteSqlNewConn(s, False)
        If Not b Then
            LOG.WriteToArchiveLog("clsSOURCETYPE : Insert : 01 : " + "ERROR: An unknown file type was NOT inserted. The SQL is: " + s)
            LOG.WriteToArchiveLog("clsSOURCETYPE : Insert : 01 : " + "ERROR: An unknown file type was NOT inserted. The SQL is: " + s)
        End If
    End Sub

    ''' <summary>
    ''' Loads the profiles.
    ''' </summary>
    Sub LoadProfiles()
        Dim S As String = ""
        Dim B As Boolean = False
        '*********************************************************************************
        S = " INSERT [dbo].[LoadProfile] ([ProfileName], [ProfileDesc], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'Known graphic file types.', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB752 AS DateTime), CAST(0x00009D8B00CBB752 AS DateTime))"
        B = ExecuteSqlNewConn(90200, S)
        S = " INSERT [dbo].[LoadProfile] ([ProfileName], [ProfileDesc], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'All MS Office content.', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB752 AS DateTime), CAST(0x00009D8B00CBB752 AS DateTime))"
        B = ExecuteSqlNewConn(90201, S)
        S = " INSERT [dbo].[LoadProfile] ([ProfileName], [ProfileDesc], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - C#', N'Source Code - C#', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB752 AS DateTime), CAST(0x00009D8B00CBB752 AS DateTime))"
        B = ExecuteSqlNewConn(90202, S)
        S = " INSERT [dbo].[LoadProfile] ([ProfileName], [ProfileDesc], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'Source Code - VB', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB752 AS DateTime), CAST(0x00009D8B00CBB752 AS DateTime))"
        B = ExecuteSqlNewConn(90203, S)
        '*********************************************************************************
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xlsx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90204, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xls', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90205, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.pdf', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90206, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.html', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90207, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.htm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90208, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.docx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90209, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.doc', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90210, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.Tiff', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90211, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.tif', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90212, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.gif', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90213, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.docm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90214, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.dotx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90215, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.dotm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90216, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xlsm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90217, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xltx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90218, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xltm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90219, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xlsb', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90220, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.xlam', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90221, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.pptx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90222, S)

        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.PDF', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90223, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.TXT', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90224, S)

        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.pptm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90225, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.potx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90226, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.potm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90227, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.ppam', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90228, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.ppsx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90229, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Office Documents', N'.ppsm', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90230, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.bmp', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90231, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.png', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90232, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.vb', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90233, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.xsd', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90234, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.xss', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90235, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.xsc', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90236, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.ico', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90237, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.rpt', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90238, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.rdlc', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90239, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.resx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90240, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.sql', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90241, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.xml', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90242, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.sln', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90243, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Source Code - VB', N'.vbx', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90244, S)
        S = " INSERT [dbo].[LoadProfileItem] ([ProfileName], [SourceTypeCode], [HiveConnectionName], [HiveActive], [RepoSvrName], [RowCreationDate], [RowLastModDate]) VALUES (N'Graphics Files', N'.jpg', NULL, 0, N'DELLT100\ECMLIB', CAST(0x00009D8B00CBB786 AS DateTime), CAST(0x00009D8B00CBB786 AS DateTime))"
        B = ExecuteSqlNewConn(90245, S)

    End Sub

    ''' <summary>
    ''' Loads the file type dictionary.
    ''' </summary>
    ''' <param name="DICT">The dictionary.</param>
    Sub LoadFileTypeDictionary(ByRef DICT As Dictionary(Of String, Integer))
        DICT.Clear()
        Dim S As String = "Select distinct SourceTypeCode from SourceType"
        Dim TgtVal As String
        Dim RSData As SqlDataReader = Nothing
        Dim iKey As Integer = 0
        'RSData = SqlQryNo'Session(S)
        Dim CS As String = getRepoConnStr() : Dim CONN As New SqlConnection(CS) : CONN.Open() : Dim command As New SqlCommand(S, CONN) : RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                iKey += 1
                TgtVal = RSData.GetValue(0).ToString
                TgtVal = TgtVal.ToLower
                DICT.Add(TgtVal, iKey)
            Loop
        End If
        RSData.Close()
        RSData = Nothing
        CONN.Dispose()
        GC.Collect()
    End Sub

    ''' <summary>
    ''' Updates the source image compressed.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="UploadFQN">The upload FQN.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="LastAccessDate">The last access date.</param>
    ''' <param name="CreateDate">The create date.</param>
    ''' <param name="LastWriteTime">The last write time.</param>
    ''' <param name="VersionNbr">The version NBR.</param>
    ''' <param name="CompressedImageBinary">The compressed image binary.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="RetStr">The ret string.</param>
    ''' <param name="OriginalSize">Size of the original.</param>
    ''' <param name="CompressedSize">Size of the compressed.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <param name="rMsg">The r MSG.</param>
    ''' <param name="TransmissionStartTime">The transmission start time.</param>
    ''' <param name="txEndTime">The tx end time.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function UpdateSourceImageCompressed(ByVal ID As Integer,
                                                ByVal UID As String,
                                                ByVal UploadFQN As String,
                                                ByVal SourceGuid As String,
                                                ByVal LastAccessDate As String,
                                                ByVal CreateDate As String,
                                                ByVal LastWriteTime As String,
                                                ByVal VersionNbr As Integer,
                                                ByVal CompressedImageBinary() As Byte,
                                                ByVal MachineID As String,
                                                ByVal RetStr As String,
                                                ByRef OriginalSize As Integer,
                                                ByRef CompressedSize As Integer,
                                                ByRef RC As Boolean,
                                                ByRef rMsg As String,
                                                ByRef TransmissionStartTime As Date,
                                                ByRef txEndTime As Date) As Boolean

        Dim TxStartTime As Date = Now
        Dim B As Boolean = False

        'WDM CHECK THIS
        B = UpdateSourceImageCompressed(ID,
                                                 UID,
                                                 UploadFQN,
                                                 SourceGuid,
                                                 LastAccessDate,
                                                 CreateDate,
                                                 LastWriteTime,
                                                 VersionNbr,
                                                 CompressedImageBinary,
                                                 MachineID,
                                                 RetStr,
                                                 OriginalSize,
                                                 CompressedSize,
                                                 RC,
                                                 rMsg,
                                                 TransmissionStartTime,
                                                 txEndTime)
        'ProxyArchive = Nothing
        GC.Collect()
        GC.WaitForPendingFinalizers()

        Console.WriteLine("TX Time: " & TC.ElapsedTimeInMS(TxStartTime, txEndTime))
        Return B

    End Function

    ''' <summary>
    ''' Gets the zip password.
    ''' </summary>
    ''' <returns>System.String.</returns>
    Function getZipPassword() As String
        Dim S As String = ""
        S += "X"
        S += "@"
        S += "v"
        S += "1"
        S += "3"
        S += "r"
        Return S
    End Function

    ''' <summary>
    ''' Inserts the source image.
    ''' </summary>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="MachineID">The machine identifier.</param>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="FileGuid">The file unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="SourceHash">The source hash.</param>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <param name="bUseZipFles">if set to <c>true</c> [b use zip fles].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function InsertSourceImage(UserID As String, ByVal MachineID As String,
                ByVal OriginalFileName As String,
                ByVal FileGuid As String,
                ByVal FQN As String,
                ByVal RepositoryTable As String,
                ByVal RetentionCode As String,
                ByVal isPublic As String,
                SourceHash As String,
                DirName As String,
                bUseZipFles As Boolean) As Boolean

        Dim bSuccess As Boolean = True

        Dim bApplied As Boolean = Exec_spUpdateLongNameHash(FileGuid, FQN)
        If Not bApplied Then
            LOG.WriteToArchiveLog("ERROR HA12X: (Exec_spUpdateLongNameHash) : Failed to update the long file names cross references: ")
            LOG.WriteToArchiveLog("HOW TO TEST in Sql Server: " + Environment.NewLine + "    exec spUpdateLongNameHash '" + FQN + "', '" + FileGuid + "' ")
        End If

        Dim BX As Boolean = InsertBinaryData(RepositoryTable, FQN, SourceHash, FileGuid)
        If BX Then
            LOG.WriteToArchiveLog(">> ADDED to Repo: " + FQN)
        Else
            LOG.WriteToArchiveLog(">> ERROR failed ADD to Repo: " + FQN)
            Return False
        End If

        If Not bUseZipFles Then
            Return True
        End If
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        '** Check for a SingleSource upload here. If there exists a file with the same name and the same CRC, then just add it to the ContentUser table.
        Dim LL As Integer = 0
        If TrackUploads Then
            LL = 1
            LOG.WriteToUploadLog("InsertSourceImage: File - start " + Now.ToString + FQN)
        End If
        LL = 2
        Dim OriginalSize As Long = 0
        Dim CompressedSize As Long = 0
        Dim StartTime As Date = Now
        Dim CompressStartTime As Date = Now
        Dim CompressEndTime As Date = Now
        Dim TransmissionType As String = ""
        LL = 3
        Dim totalCompressSecs As Long = 0
        Dim totalTransmitSecs As Long = 0

        Dim ElapsedTime As TimeSpan
        Dim ElapsedZipTime As TimeSpan

        Dim RC As Boolean = True
        If Not File.Exists(FQN) Then
            Return False
        End If

        Dim FIOriginal As New FileInfo(FQN)
        OriginalSize = FIOriginal.Length
        Dim oFileName As String = FIOriginal.Name
        FIOriginal = Nothing

        Dim tPath As String = LOG.getTempEnvironDir
        Dim TransferFileName As String = FileGuid + ".NotReady"
        LL = 4
        TransferFileName = tPath + "\" + TransferFileName

        '******************************************
        CompressStartTime = Now
        LL = 5
        Using myZip As ZipFile = New ZipFile
            myZip.AddFile(FQN)
            myZip.Save(TransferFileName)
        End Using
        LL = 6
        Dim ZipFileLength As Long = 0
        Dim FITemp As New FileInfo(TransferFileName)
        ZipFileLength = FITemp.Length
        FITemp = Nothing

        GC.Collect()
        GC.WaitForPendingFinalizers()

        CompressEndTime = Now
        '******************************************
        Try
            Dim FileBuffer() As Byte = Nothing

            Dim oFile As System.IO.FileInfo
            oFile = New System.IO.FileInfo(TransferFileName)

            Dim oFileStream As System.IO.FileStream = oFile.OpenRead()
            Dim lBytes As Long = oFileStream.Length
            LL = 10
            If (lBytes > 0) Then
                ReDim FileBuffer(CInt(lBytes - 1))
                oFileStream.Read(FileBuffer, 0, CInt(lBytes))
                oFileStream.Close()
            End If

            Dim FI As New FileInfo(TransferFileName)
            Dim FLength As Long = FI.Length
            CompressedSize = FLength
            FI = Nothing
            LL = 20
            GC.Collect()
            GC.WaitForPendingFinalizers()

            Dim MaxMeg As Long = 25000000
            Dim MaxGig As Long = 2000000000

            FI = Nothing
            LL = 30
            Try
                'WDMXX This Is where the File Buffer Is uploaded to the repository
                If RepositoryTable.ToUpper.Equals("EMAILATTACHMENT") Then
                    TransmissionType = "Buffered" : LL = 31
                    InsertBufferedSource(1, FileBuffer, OriginalFileName, FileGuid, TransferFileName, RepositoryTable, RetentionCode, isPublic, SourceHash, DirName)
                ElseIf RepositoryTable.ToUpper.Equals("EMAIL") Then
                    TransmissionType = "Buffered" : LL = 34
                    InsertBufferedSource(2, FileBuffer, OriginalFileName, FileGuid, TransferFileName, RepositoryTable, RetentionCode, isPublic, SourceHash, DirName)
                ElseIf FLength > 0 And FLength <= MaxMeg Then
                    '** This is a small file and can be loaded quite well with a BUFFERED load
                    TransmissionType = "Buffered" : LL = 36
                    InsertBufferedSource(3, FileBuffer, OriginalFileName, FileGuid, TransferFileName, RepositoryTable, RetentionCode, isPublic, SourceHash, DirName)
                ElseIf FLength > MaxMeg And FLength < MaxGig Then
                    '** This is a Large file and can be loaded much better with a Streamed load
                    TransmissionType = "File Stream" : LL = 38
                    'WDMXX - UploadFileStream might be able to do this, but not presently
                    'UploadFileStream(OriginalFileName, FileGuid, TransferFileName, RepositoryTable, SourceHash) : LL = 39
                    InsertBufferedSource(4, FileBuffer, OriginalFileName, FileGuid, TransferFileName, RepositoryTable, RetentionCode, isPublic, SourceHash, DirName)
                Else
                    '** This is a Stupidly largr file to upload - better with a chunk load.
                    TransmissionType = "Chunked" : LL = 40
                    ChunkFileUpload(OriginalFileName, FileGuid, TransferFileName, RepositoryTable, SourceHash) : LL = 41
                End If
                LL = 42
            Catch ex As Exception
                ' xTrace(772341, "00 - InsertSourceImage LL=" + LL.ToString, ex.Message.ToString)
                LOG.WriteToArchiveLog("ERROR: UploadFileStrem - ", ex)
                LOG.WriteToArchiveLog("ERROR: UploadFileStrem -LL = " + LL.ToString)
                RC = False
                bSuccess = False
            Finally
                'ISO.saveIsoFile(" FilesToDelete.dat", TransferFileName + "|")
                'File.Delete(TransferFileName)
            End Try
            LL = 43
            ElapsedTime = Now().Subtract(StartTime)
            totalTransmitSecs = CLng(ElapsedTime.TotalMilliseconds)
            LL = 44
            ElapsedZipTime = CompressEndTime.Subtract(CompressStartTime)
            totalCompressSecs = ElapsedZipTime.Milliseconds
            LL = 45
            Dim Msg As String = ""
            If RC Then
                LL = 46
                Msg = "Successful Upload: " + TransmissionType + Environment.NewLine
                Msg += "   Original Size: " + OriginalSize.ToString + Environment.NewLine
                Msg += "   Compressed Size: " + CompressedSize.ToString + Environment.NewLine
                Msg += "   Compress Time: " + (totalCompressSecs / 1000).ToString + " sec" + Environment.NewLine
                Msg += "   Transmit Time: " + (totalTransmitSecs / 1000).ToString + " sec" + Environment.NewLine
                Msg += "   BPS: " + (CompressedSize / (totalTransmitSecs / 100)).ToString + Environment.NewLine
                Msg += "   File: " + FQN + Environment.NewLine
                LOG.WriteToArchiveLog(Msg)
                ' xTrace(663341, "SUCCESS: SaveUploadStats", Msg)
                LL = 47
            Else
                LL = 48
                Msg = "Failed Upload: " + TransmissionType + Environment.NewLine
                Msg += "   Original Size: " + OriginalSize.ToString + Environment.NewLine
                Msg += "   Compressed Size: " + CompressedSize.ToString + Environment.NewLine
                Msg += "   Compress Time: " + (totalCompressSecs / 1000).ToString + " sec" + Environment.NewLine
                Msg += "   Transmit Time: " + (totalTransmitSecs / 1000).ToString + " sec" + Environment.NewLine
                Msg += "   BPS: " + (CompressedSize / (totalTransmitSecs / 1000)).ToString + Environment.NewLine
                Msg += "   File: " + FQN + Environment.NewLine
                LOG.WriteToArchiveLog(Msg)
                ' xTrace(663342, "FAILED: SaveUploadStats", Msg)
                LL = 49
            End If
            LL = 50
            Dim BPS As Decimal = CDec(CompressedSize / (totalTransmitSecs / 1000)) : LL = 51
            Dim TxTotalTime As Decimal = CDec((totalCompressSecs / 1000) + (totalTransmitSecs / 1000)) : LL = 52

            '** Mark the file as successfully uploaded here and capture the stats
            Dim AttachmentName As String = oFileName : LL = 53

            'WDM CHECK THIS
            SaveUploadStats(gGateWayID, RepositoryTable, FileGuid, CInt(OriginalSize), CInt(CompressedSize), StartTime, Now, TxTotalTime, BPS, AttachmentName) : LL = 54
            LL = 54
            If TrackUploads Then
                LOG.WriteToUploadLog("InsertSourceImage: File - END " + Now.ToString + " : " + FQN + " : Size - " + CompressedSize.ToString)
            End If

            Dim ThisFileExt As String = Path.GetExtension(FQN)
            Dim bUploadedc As Boolean = ApplySourceTypeCode(MachineID, UserID, FQN, ThisFileExt, FileGuid)
            If Not bUploadedc Then
                LOG.WriteToArchiveLog("ERROR - InsertSourceImage: Failed to Apply Source attributes.")
            End If
        Catch ex As Exception
            bSuccess = False
            LOG.WriteToArchiveLog("ERROR - InsertSourceImage: LL = " + LL.ToString + Environment.NewLine + ex.Message.ToString)
        End Try
        Return bSuccess
    End Function

    ''' <summary>
    ''' Inserts the buffered source.
    ''' </summary>
    ''' <param name="LocID">The loc identifier.</param>
    ''' <param name="CompressedBuffer">The compressed buffer.</param>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="FileGuid">The file unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="isPublic">The is public.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <param name="DirName">Name of the dir.</param>
    Sub InsertBufferedSource(ByVal LocID As Integer, ByVal CompressedBuffer As Byte(),
                       ByVal OriginalFileName As String,
                       ByVal FileGuid As String,
                       ByVal FQN As String,
                       ByVal RepositoryTable As String,
                       ByVal RetentionCode As String,
                       ByVal isPublic As String,
                       FileHash As String,
                       ByVal DirName As String)

        If TrackUploads Then
            LOG.WriteToUploadLog("InsertBufferedSource: File - start " + Now.ToString + FQN)
        End If
        Dim LL As Integer = 0
        Dim FI As New FileInfo(FQN)
        Dim SourceName As String = FI.Name
        Dim SourceTypeCode As String = FI.Extension
        Dim sLastAccessDate As String = FI.LastAccessTime.ToString
        Dim sCreateDate As String = FI.CreationTime.ToString
        Dim sLastWriteTime As String = FI.LastAccessTime.ToString
        Dim OriginalSize As Integer = CInt(FI.Length)
        Dim CompressedSize As Integer = CInt(FI.Length)
        Dim RC As Boolean = True
        Dim RMsg As String = ""
        Dim TxStartDate As Date = Now
        Dim TxEndDate As Date = Now
        Dim VersionNbr As Integer = 1
        'Dim CompressedBuffer As Byte() = Nothing
        FI = Nothing

        '** Used only in testing WDMXX
        Dim bTesting As Boolean = False
        If bTesting Then
            Try
                Dim ReturnedSourceGuid As String = AddSourceToRepo(gCurrUserGuidID, gMachineID, "LOCAL", FileGuid, FQN, SourceName, SourceTypeCode, sLastAccessDate, sCreateDate, sLastWriteTime, gCurrUserGuidID,
                                       VersionNbr, RetentionCode, isPublic, FileHash, DirName)
            Catch ex As Exception
                MessageBox.Show(ex.Message)
                Return
            End Try
        End If

        'Dim FileHash As String = ""
        Dim Ticks As Long = 0
        Dim TotalTicks As Long = 0
        Dim EndTime As Date = Now

        If Not File.Exists(FQN) Then
            Return
        End If

        Ticks = Now.Ticks
        'FileHash = ENC.getCountDataSourceFiles(FQN)
        TotalTicks = Now.Ticks - Ticks

        Dim Filength As Long = 0
        Dim FIName As String = ""

        Dim FI2 As New FileInfo(FQN)

        Filength = FI2.Length
        FIName = FI2.Name

        FI2 = Nothing

        ' Open a file that is to be loaded into a byte array
        Dim oFile As System.IO.FileInfo : LL = 1
        oFile = New System.IO.FileInfo(FQN)

        Dim oFileStream As System.IO.FileStream = oFile.OpenRead()
        Dim lBytes As Long = oFileStream.Length
        Dim SourceImage(CInt(lBytes - 1)) As Byte : LL = 10

        If (lBytes > 0) Then
            LL = 11
            ' Read the file into a byte array
            oFileStream.Read(SourceImage, 0, CInt(lBytes)) : LL = 12
            oFileStream.Close() : LL = 13
        End If

        oFileStream.Close() : LL = 14
        oFileStream.Dispose() : LL = 15
        oFile = Nothing : LL = 16

        Dim StartTime As Date = Now : LL = 20
        System.Net.ServicePointManager.DefaultConnectionLimit = 200
        'Dim fStream As New System.IO.FileStream(FQN, FileMode.Open)

        Try
            LL = 30
            Dim iFlen As Integer = SourceImage.Length
            Dim sErrmsg As String = ""
            Dim BB As Boolean = True : LL = 38

            sErrmsg = InsertImageToRepoTable(63221, gCurrUserGuidID, FileGuid, iFlen, FileHash, Filength, FIName, RepositoryTable, BB, OriginalFileName, SourceImage) : LL = 40
            LL = 39

            If sErrmsg.Length > 0 Then
                MessageBox.Show("ERROR: " + sErrmsg)
            End If
            LL = 40
            GC.Collect()
            GC.WaitForPendingFinalizers()
            LL = 41
        Catch ex As Exception

            frmNotifyMessage.Show()
            gNotifyMsg = "ERROR 167: - UploadBuffer: " + ex.ToString
            LOG.WriteToArchiveLog("ERROR 167: - InsertBufferedSource: ", ex)
            ' xTrace(990134, "UploadBuffer LL:" + LL.ToString, ex.Message)
            ' xTrace(990135, "UploadBuffer LL:" + LL.ToString, ex.InnerException.ToString)
        Finally
            'ProxyArchive.Close()
            'ProxyArchive = Nothing
            'oFileStream.Close()
            'oFileStream.Dispose()
            'oFile = Nothing
            GC.Collect()
            GC.WaitForPendingFinalizers()
            LL = 41
        End Try

        Dim ElapsedSecs As Integer = ElapsedTimeSec(StartTime, Now)
        Dim BytesPerSec As Double = Filength / ElapsedSecs
        If TrackUploads Then
            LOG.WriteToUploadLog("InsertBufferedSource: File - start " + Now.ToString + " + / " + FQN + " : " + Filength.ToString + " / " + Now.ToString)
        End If

    End Sub

    ''' <summary>
    ''' Chunks the file upload.
    ''' </summary>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="FileGuid">The file unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="CrcHASH">The CRC hash.</param>
    Sub ChunkFileUpload(ByVal OriginalFileName As String, ByVal FileGuid As String, ByVal FQN As String, ByVal RepositoryTable As String, CrcHASH As String)

        Dim Ticks As Long = 0
        Dim TotalTicks As Long = 0
        Dim StartTime As Date = Now
        Dim EndTime As Date = Now
        Dim CurrByte As Long = 0
        Dim RetMsg As String = ""
        Dim LastSegment As Boolean = False

        'Dim ProxyFS As New SvcFS.Service1Client

        If Not File.Exists(FQN) Then
            Return
        End If

        Ticks = Now.Ticks
        TotalTicks = Now.Ticks - Ticks

        Dim Filength As Long = 0
        Dim FIName As String = ""

        Dim FI As New FileInfo(FQN)

        Filength = FI.Length
        FIName = FI.Name

        FI = Nothing

        System.Net.ServicePointManager.DefaultConnectionLimit = 200
        Dim fStream As New System.IO.FileStream(FQN, FileMode.Open)
        Dim ErrMsg As String = ""
        StartTime = Now

        Dim Buffer(65536) As Byte
        Dim iBuffer As Integer = 65536
        Dim I As Integer = 0
        Dim P As Integer = 0
        Dim iLoop As Integer = 0

        Try
            I = fStream.Read(Buffer, 0, iBuffer)
            Do While I > 0
                If iLoop = 0 Then
                    iLoop += 1
                    If I < Buffer.Length Then
                        LastSegment = True
                    End If
                    ErrMsg = InsertImageToRepoTable(63222, gCurrUserGuidID, FileGuid, I, CrcHASH, Filength, FIName, RepositoryTable, LastSegment, OriginalFileName, Buffer)
                    If ErrMsg.Length > 0 Then
                        MessageBox.Show("ERROR: " + ErrMsg)
                        LOG.WriteToArchiveLog("ERROR: " + ErrMsg)
                    End If
                Else
                    iLoop += 1
                    If I < Buffer.Length Then
                        LastSegment = True
                    End If
                    ErrMsg = UploadBufferedAppend(gCurrUserGuidID, FileGuid, I, CrcHASH, Filength, FIName, RepositoryTable, RetMsg, LastSegment, OriginalFileName, Buffer)
                    If ErrMsg.Length > 0 Then
                        MessageBox.Show("ERROR: " + ErrMsg)
                        LOG.WriteToArchiveLog("ERROR: " + ErrMsg)
                    End If
                End If
                P += iBuffer - 1
                I = fStream.Read(Buffer, 0, iBuffer)
                If I = 0 And Not LastSegment Then
                    LastSegment = True
                    ErrMsg = UploadBufferedAppend(gCurrUserGuidID, FileGuid, I, CrcHASH, Filength, FIName, RepositoryTable, RetMsg, LastSegment, OriginalFileName, Buffer)
                End If
            Loop
            Console.WriteLine("Loops to process = " + iLoop.ToString)
        Catch ex As Exception
            MessageBox.Show(ex.Message)
        End Try
        EndTime = Now

        Dim ElapsedSecs As Integer = ElapsedTimeSec(StartTime, EndTime)
        Dim BytesPerSec As Double = Filength / ElapsedSecs

        Console.WriteLine("Chunk Upload: Size= " + Filength.ToString + " / Seconds: " + ElapsedSecs.ToString + " / Bytes per sec: " + BytesPerSec.ToString)

        'ProxyFS.Close()
        Console.WriteLine("Loops to process = " + iLoop.ToString)
        fStream.Close()
        fStream.Dispose()
        GC.Collect()
        GC.WaitForPendingFinalizers()

    End Sub

    ''' <summary>
    ''' Uploads the file stream x.
    ''' </summary>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="FileGuid">The file unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="Sha1HASH">The sha1 hash.</param>
    Sub UploadFileStreamX(ByVal OriginalFileName As String, ByVal FileGuid As String, ByVal FQN As String, ByVal RepositoryTable As String, Sha1HASH As String)

        'WDMXX()

        Dim isCompressed As Boolean = True
        'Dim Sha1HASH As String = ""
        Dim Ticks As Long = 0
        Dim TotalTicks As Long = 0
        Dim StartTime As Date = Now
        Dim EndTime As Date = Now

        If Not File.Exists(FQN) Then
            LOG.WriteToArchiveLog("NOTICE: File not found - " + FQN)
            Return
        End If

        If TrackUploads Then
            LOG.WriteToUploadLog("FileStream: File - start " + Now.ToString + FQN)
        End If

        Ticks = Now.Ticks
        'Sha1HASH = ENC.getCountDataSourceFiles(FQN)
        TotalTicks = Now.Ticks - Ticks

        Dim Filength As Long = 0
        Dim FIName As String = ""

        Dim FI As New FileInfo(FQN)

        Filength = FI.Length
        FIName = FI.Name

        FI = Nothing

        System.Net.ServicePointManager.DefaultConnectionLimit = 200
        Dim fStream As New System.IO.FileStream(FQN, FileMode.Open)

        Dim ErrMsg As String = ""
        StartTime = Now
        Try
            'WDMXX uncomment if needed
            'RemoteFileUpload(Sha1HASH, FileGuid, Filength, FIName, RepositoryTable, gCurrUserGuidID, isCompressed, fStream)
        Catch ex As Exception
            MessageBox.Show(ex.Message)
            If TrackUploads Then
                LOG.WriteToArchiveLog("ERROR FileStream: File - start " + Now.ToString + FQN + " : ", ex)
            End If
        End Try
        EndTime = Now

        Dim ElapsedSecs As Integer = ElapsedTimeSec(StartTime, EndTime)
        Dim BytesPerSec As Double = Filength / ElapsedSecs

        If TrackUploads Then
            LOG.WriteToArchiveLog("ERROR FileStream: File - END " + Now.ToString + FQN + " : Bytes = " + Filength.ToString)
        End If

        fStream.Close()
        fStream.Dispose()
        GC.Collect()
        GC.WaitForPendingFinalizers()
    End Sub

    ''' <summary>
    ''' Verifies the retention dates.
    ''' </summary>
    Sub VerifyRetentionDates()
        Dim MySql As String = ""
        Dim B As Boolean = False

        MySql = ""
        MySql += " update DataSource set RetentionCode = 'Retain 50',"
        MySql += " RetentionExpirationDate = getdate() + (select RetentionUnits from Retention where RetentionCode = DataSource.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSqlNewConn(90246, MySql)

        MySql = ""
        MySql += " update email set"
        MySql += " RetentionExpirationDate = getdate() + (select RetentionUnits from Retention where RetentionCode = email.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSqlNewConn(90247, MySql)

        MySql = ""
        MySql += " update EmailAttachment set "
        MySql += " RetentionExpirationDate = getdate() + (select RetentionUnits from Retention where RetentionCode = EmailAttachment.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSqlNewConn(90248, MySql)

    End Sub

    ''' <summary>
    ''' xes the xsave content user record.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    ''' <param name="NetworkName">Name of the network.</param>
    ''' <param name="ContentTypeCode">The content type code.</param>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function XXsaveContentUserRecord(MachineName As String,
                                      NetworkName As String,
                                      ContentTypeCode As String,
                                        ContentGuid As String,
                                        UserID As String) As Boolean

        Dim iCnt As Integer = ckContentUserRecordExists(ContentTypeCode, ContentGuid, UserID)
        If iCnt = 0 Then
            Dim I As Integer = 1

            Dim MachineGuid As String = MachineRegister(MachineName, NetworkName)

            InsertContentUserRecord(ContentTypeCode, ContentGuid, UserID, I)

            Dim MySql As String = ""
            MySql += " if NOT exists (Select userID from Machine " + Environment.NewLine
            MySql += " where MachineGuid = '" + MachineGuid + "' " + Environment.NewLine
            MySql += " and ContentGuid = '" + ContentGuid + "')" + Environment.NewLine
            MySql += " Begin " + Environment.NewLine
            MySql += " INSERT INTO [Machine] ([UserID],[ContentGuid],[ContentTypeCode],[MachineGuid]) VALUES ('" + UserID + "','" + ContentGuid + "','" + ContentTypeCode + "','" + MachineGuid + "')" + Environment.NewLine
            MySql += " End" + Environment.NewLine

            Dim BB As Boolean = ExecuteSqlNewConn(90249, MySql)

        End If

    End Function

    ''' <summary>
    ''' Cks the content user record exists.
    ''' </summary>
    ''' <param name="ContentTypeCode">The content type code.</param>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns>System.Int32.</returns>
    Public Function ckContentUserRecordExists(ContentTypeCode As String,
                                            ContentGuid As String,
                                            UserID As String) As Integer

        Dim s As String = ""
        s = s + " Select count(*) from [ContentUser]" + Environment.NewLine
        s = s + " where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "' "

        Dim i As Integer = iCount(s)

        Return i
    End Function

    ''' <summary>
    ''' Inserts the content user record.
    ''' </summary>
    ''' <param name="ContentTypeCode">The content type code.</param>
    ''' <param name="ContentGuid">The content GUID.</param>
    ''' <param name="UserID">The user ID.</param>
    ''' <param name="NbrOccurances">The NBR occurances.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function InsertContentUserRecord(ContentTypeCode As String,
                                            ContentGuid As String,
                                            UserID As String,
                                            NbrOccurances As Integer) As Boolean
        Dim b As Boolean = False
        Dim NewID As String = Guid.NewGuid.ToString
        Dim s As String = ""

        s = s + " INSERT INTO [ContentUser]" + Environment.NewLine
        s = s + " ([ContentTypeCode]" + Environment.NewLine
        s = s + " ,[ContentGuid]" + Environment.NewLine
        s = s + " ,[UserID]" + Environment.NewLine
        s = s + " ,[NbrOccurances])" + Environment.NewLine
        s = s + " VALUES " + Environment.NewLine
        s = s + " ('" + ContentTypeCode + "'" + Environment.NewLine
        s = s + " ,'" + ContentGuid + "'" + Environment.NewLine
        s = s + " ,'" + UserID + "'" + Environment.NewLine
        s = s + " ," + NbrOccurances.ToString + " )"

        Dim BB As Boolean = ExecuteSqlNewConn(90250, s)

        Return BB
    End Function

    '**************************************************************
    ''' <summary>
    ''' Saves the RSS pull.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="RssName">Name of the RSS.</param>
    ''' <param name="RssUrl">The RSS URL.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function Save_RssPull(SecureID As Integer, ByVal RssName As String, ByVal RssUrl As String, ByVal UserID As String, RetentionCode As String, ByRef RC As Boolean) As Boolean

        RC = True

        Dim sRssName = RssName.Replace("'", "''")
        Dim sUserID = UserID.Replace("'", "''")
        Dim sRssUrl = RssUrl.Replace("'", "''")

        Dim WhereClause As String = " where RssUrl  = '" + sRssUrl + "' and UserID = '" + sUserID + "' "

        Dim S As String = "Select count(*) from RssPull" + WhereClause
        Dim B As Boolean = False
        Dim iCnt As Integer = iCount(S)
        Dim MySql As String = ""
        Dim NewCS As String = getRepoConnStr()
        Dim connection As New SqlConnection(NewCS)

        If connection.State = ConnectionState.Closed Then
            connection.Open()
        End If

        If iCnt = 0 Then
            Try

                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@RssName", RssName))
                command.Parameters.Add(New SqlParameter("@RssUrl", RssUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))

                MySql = MySql + "INSERT INTO [dbo].[RssPull]"
                MySql = MySql + "("
                MySql = MySql + "           [RssName]"
                MySql = MySql + "           ,[RssUrl]"
                MySql = MySql + "           ,[UserID]"
                MySql = MySql + "           ,[RetentionCode]"
                MySql = MySql + ")"
                MySql = MySql + "VALUES"
                MySql = MySql + "("
                MySql = MySql + "@RssName"
                MySql = MySql + ",@RssUrl"
                MySql = MySql + ",@UserID"
                MySql = MySql + ",@RetentionCode"
                MySql = MySql + ")"

                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: ", ex)
                B = False
            End Try
        Else
            Try
                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@RssName", RssName))
                command.Parameters.Add(New SqlParameter("@RssUrl", RssUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))

                MySql = MySql + "UPDATE [dbo].[RssPull]"
                MySql = MySql + " SET [RssName] = @RssName "
                MySql = MySql + " ,[RssUrl] = @RssUrl "
                MySql = MySql + " ,[UserID] = @UserID "
                MySql = MySql + " ,[RetentionCode] = @RetentionCode "

                MySql = MySql + WhereClause

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: 157848 " + ex.Message + Environment.NewLine + MySql)
                B = False
            End Try
        End If

        Return B

    End Function

    ''' <summary>
    ''' Gets the RSS pull.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>BindingSource.</returns>
    Public Function GET_RssPull(SecureID As Integer, WhereClause As String, RC As Boolean) As BindingSource

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[RssName], "
        MySql += "[RssUrl], "
        MySql += "[UserID], "
        MySql += "[RetentionCode] "
        MySql += " From [RssPull] "

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If

        MySql += " Order by RssName "

        Dim CSstr As String = getRepoConnStr()
        Dim ConnStr As String = CSstr
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim BSource As New BindingSource
        Dim command As New SqlCommand(MySql, CONN)
        Dim rsDataQry As SqlDataReader = Nothing

        Try
            Dim dataAdapter = New SqlDataAdapter(MySql, ConnStr)
            Dim commandBuilder As New SqlCommandBuilder(dataAdapter)
            Dim table As New DataTable()
            table.Locale = System.Globalization.CultureInfo.InvariantCulture
            dataAdapter.Fill(table)
            BSource.DataSource = table
        Catch e As Exception
            ' xTrace(13321, "clsDataBase:getRssPull", e.Message.ToString())
        Finally
            If rsDataQry IsNot Nothing Then
                If Not rsDataQry.IsClosed Then
                    rsDataQry.Close()
                End If
                rsDataQry = Nothing
            End If
            command.Dispose()
            command = Nothing
        End Try

        Return BSource

    End Function

    ''' <summary>
    ''' Gets the RSS pull data.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function GET_RssPullData(SecureID As Integer, WhereClause As String, RC As Boolean) As List(Of String)

        Dim ListOfUrls As New List(Of String)
        Dim RssName As String = ""
        Dim RssUrl As String = ""
        Dim UserID As String = ""
        Dim RetentionCode As String = ""
        Dim RowGuid As String = ""

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[RssName], "
        MySql += "[RssUrl], "
        MySql += "[UserID], RetentionCode, RowGuid "
        MySql += " From [RssPull] "

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If

        Dim CSstr As String = getRepoConnStr()
        Dim ConnStr As String = CSstr
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim RSData As SqlDataReader = Nothing
        Dim command As New SqlCommand(MySql, CONN)

        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                RssName = RSData.GetValue(0).ToString
                RssUrl = RSData.GetValue(1).ToString
                UserID = RSData.GetValue(2).ToString
                RetentionCode = RSData.GetValue(3).ToString
                RowGuid = RSData.GetValue(4).ToString
                Dim strItems = RssName + "|" + RssUrl + "|" + UserID + "|" + RetentionCode + "|" + RowGuid
                ListOfUrls.Add(strItems)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        Return ListOfUrls

    End Function

    ''' <summary>
    ''' Gets the web site data.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function GET_WebSiteData(SecureID As Integer, WhereClause As String, RC As Boolean) As List(Of String)

        Dim ListOfUrls As New List(Of String)
        Dim WebSite As String = ""
        Dim WebUrl As String = ""
        Dim UserID As String = ""
        Dim Depth As String = ""
        Dim Width As String = ""
        Dim RetentionCode As String = ""
        Dim RowGuid As String = ""

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[WebSite], "
        MySql += "[WebUrl], "
        MySql += "Depth, "
        MySql += "Width, "
        MySql += "[UserID], "
        MySql += "RetentionCode, "
        MySql += "RowGuid "
        MySql += " From [WebSite] "

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If

        Dim CSstr As String = getRepoConnStr()
        Dim ConnStr As String = CSstr
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim RSData As SqlDataReader = Nothing
        Dim command As New SqlCommand(MySql, CONN)

        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                WebSite = RSData.GetValue(0).ToString
                WebUrl = RSData.GetValue(1).ToString
                Depth = RSData.GetValue(2).ToString
                Width = RSData.GetValue(3).ToString
                UserID = RSData.GetValue(4).ToString
                RetentionCode = RSData.GetValue(5).ToString
                RowGuid = RSData.GetValue(6).ToString
                Dim strItems = WebSite + "|" + WebUrl + "|" + UserID + "|" + Depth + "|" + Width + "|" + RetentionCode + "|" + RowGuid
                ListOfUrls.Add(strItems)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        Return ListOfUrls

    End Function

    ''' <summary>
    ''' Gets the web page data.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>List(Of System.String).</returns>
    Public Function GET_WebPageData(SecureID As Integer, WhereClause As String, RC As Boolean) As List(Of String)

        Dim ListOfUrls As New List(Of String)
        Dim WebSite As String = ""
        Dim WebUrl As String = ""
        Dim UserID As String = ""
        Dim Depth As String = "1"
        Dim Width As String = "0"
        Dim RetentionCode As String = ""
        Dim RowGuid As String = ""

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[WebScreen], "
        MySql += "[WebUrl], "
        MySql += "'1' as Depth, "
        MySql += "'0' as Width, "
        MySql += "[UserID], "
        MySql += "RetentionCode, "
        MySql += "RowGuid "
        MySql += " From [WebScreen] "

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If

        Dim CSstr As String = getRepoConnStr()
        Dim ConnStr As String = CSstr
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim RSData As SqlDataReader = Nothing
        Dim command As New SqlCommand(MySql, CONN)

        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                WebSite = RSData.GetValue(0).ToString
                WebUrl = RSData.GetValue(1).ToString
                Depth = RSData.GetValue(2).ToString
                Width = RSData.GetValue(3).ToString
                UserID = RSData.GetValue(4).ToString
                RetentionCode = RSData.GetValue(5).ToString
                RowGuid = RSData.GetValue(6).ToString
                Dim strItems = WebSite + "|" + WebUrl + "|" + UserID + "|" + Depth + "|" + Width + "|" + RetentionCode + "|" + RowGuid
                ListOfUrls.Add(strItems)
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        Return ListOfUrls

    End Function

    ''' <summary>
    ''' Gets the web screen for grid.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>BindingSource.</returns>
    Public Function GET_WebScreenForGRID(SecureID As Integer, WhereClause As String, RC As Boolean) As BindingSource

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[WebScreen], "
        MySql += "[WebUrl], "
        MySql += "[UserID], "
        MySql += "[RetentionCode] "
        MySql += " From [WebScreen]" & Environment.NewLine

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If
        MySql += " order by [WebScreen]" & Environment.NewLine

        Dim ConnStr As String = getRepoConnStr()
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim BSource As New BindingSource
        Dim command As New SqlCommand(MySql, CONN)
        Dim rsDataQry As SqlDataReader = Nothing

        Try
            Dim dataAdapter = New SqlDataAdapter(MySql, ConnStr)
            Dim commandBuilder As New SqlCommandBuilder(dataAdapter)
            Dim table As New DataTable()
            table.Locale = System.Globalization.CultureInfo.InvariantCulture
            dataAdapter.Fill(table)
            BSource.DataSource = table
        Catch e As Exception
            ' xTrace(13322, "clsDataBase:GET_WebScreen", e.Message.ToString())
        Finally
            If rsDataQry IsNot Nothing Then
                If Not rsDataQry.IsClosed Then
                    rsDataQry.Close()
                End If
                rsDataQry = Nothing
            End If
            command.Dispose()
            command = Nothing
        End Try

        Return BSource

    End Function

    ''' <summary>
    ''' Saves the web screen URL.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WebScreen">The web screen.</param>
    ''' <param name="WebUrl">The web URL.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function Save_WebScreenURL(SecureID As Integer, ByVal WebScreen As String, ByVal WebUrl As String, RetentionCode As String, ByVal UserID As String, ByRef RC As Boolean) As Boolean

        Dim sWebScreen = WebScreen.Replace("'", "''")
        Dim sWebUrl = WebUrl.Replace("'", "''")
        Dim sUserID = UserID.Replace("'", "''")

        RC = True
        Dim WhereClause As String = " where WebUrl  = '" + sWebUrl + "' and UserID = '" + UserID + "' "

        Dim S As String = "Select count(*) from WebScreen" + WhereClause
        Dim B As Boolean = False
        Dim iCnt As Integer = iCount(S)
        Dim MySql As String = ""
        Dim connection As New SqlConnection(getRepoConnStr())

        If connection.State = ConnectionState.Closed Then
            connection.Open()
        End If

        If iCnt = 0 Then
            Try

                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@WebScreen", WebScreen))
                command.Parameters.Add(New SqlParameter("@WebUrl", WebUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))

                MySql = MySql + "INSERT INTO [dbo].[WebScreen]"
                MySql = MySql + "("
                MySql = MySql + "           [WebScreen]"
                MySql = MySql + "           ,[WebUrl]"
                MySql = MySql + "           ,[UserID]"
                MySql = MySql + "           ,[RetentionCode]"
                MySql = MySql + ")"
                MySql = MySql + "VALUES"
                MySql = MySql + "("
                MySql = MySql + "@WebScreen"
                MySql = MySql + ",@WebUrl"
                MySql = MySql + ",@UserID"
                MySql = MySql + ",@RetentionCode"
                MySql = MySql + ")"

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: ", ex)
                B = False
            End Try
        Else
            Try
                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@WebScreen", WebScreen))
                command.Parameters.Add(New SqlParameter("@WebUrl", WebUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))

                MySql = MySql + "UPDATE [dbo].[WebScreen] "
                MySql = MySql + " SET [WebScreen] = @WebScreen "
                MySql = MySql + " ,[WebUrl] = @WebUrl "
                MySql = MySql + " ,[UserID] = @UserID "
                MySql = MySql + " ,[RetentionCode] = @RetentionCode "

                MySql = MySql + WhereClause

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: 157848 " + ex.Message + Environment.NewLine + MySql)
                B = False
            End Try
        End If

        Return B

    End Function

    ''' <summary>
    ''' Gets the web site.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WhereClause">The where clause.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>BindingSource.</returns>
    Public Function GET_WebSite(SecureID As Integer, WhereClause As String, RC As Boolean) As BindingSource

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[WebSite], "
        MySql += "[WebUrl], "
        MySql += "[UserID], "
        MySql += "[Depth], "
        MySql += "[Width], "
        MySql += "[RetentionCode] "
        MySql += " From [WebSite]" & Environment.NewLine

        If WhereClause IsNot Nothing Then
            MySql += WhereClause
        End If
        MySql += "Order by WebSite"
        Dim ListOfRows As New System.Collections.Generic.List(Of DS_WebSite)

        Dim ConnStr As String = getRepoConnStr()
        Dim CONN As New SqlConnection(ConnStr)

        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim BSource As New BindingSource
        Dim command As New SqlCommand(MySql, CONN)
        Dim rsDataQry As SqlDataReader = Nothing

        Try
            Dim dataAdapter = New SqlDataAdapter(MySql, ConnStr)
            Dim commandBuilder As New SqlCommandBuilder(dataAdapter)
            Dim table As New DataTable()
            table.Locale = System.Globalization.CultureInfo.InvariantCulture
            dataAdapter.Fill(table)
            BSource.DataSource = table
        Catch e As Exception
            ' xTrace(13322, "clsDataBase:GET_WebSite", e.Message.ToString())
        Finally
            If rsDataQry IsNot Nothing Then
                If Not rsDataQry.IsClosed Then
                    rsDataQry.Close()
                End If
                rsDataQry = Nothing
            End If
            command.Dispose()
            command = Nothing
        End Try

        Return BSource

    End Function

    ''' <summary>
    ''' Saves the web site URL.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="WebSite">The web site.</param>
    ''' <param name="WebUrl">The web URL.</param>
    ''' <param name="depth">The depth.</param>
    ''' <param name="width">The width.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function Save_WebSiteURL(SecureID As Integer, ByVal WebSite As String, ByVal WebUrl As String, depth As Integer, width As Integer, RetentionCode As String, ByVal UserID As String, ByRef RC As Boolean) As Boolean

        Dim sWebSite = WebSite.Replace("'", "''")
        Dim sUserID = UserID.Replace("'", "''")

        RC = True
        Dim WhereClause As String = " where WebSite  = '" + sWebSite + "' and UserID = '" + sUserID + "' "

        Dim S As String = "Select count(*) from WebSite" + WhereClause
        Dim B As Boolean = False
        Dim iCnt As Integer = iCount(S)
        Dim MySql As String = ""
        Dim connection As New SqlConnection(getRepoConnStr())

        If connection.State = ConnectionState.Closed Then
            connection.Open()
        End If

        If iCnt = 0 Then
            Try

                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@WebSite", WebSite))
                command.Parameters.Add(New SqlParameter("@WebUrl", WebUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@depth", depth))
                command.Parameters.Add(New SqlParameter("@width", width))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))
                MySql = ""
                MySql = MySql + "INSERT INTO [dbo].[WebSite]"
                MySql = MySql + "("
                MySql = MySql + "           [WebSite]"
                MySql = MySql + "           ,[WebUrl]"
                MySql = MySql + "           ,[UserID]"
                MySql = MySql + "           ,[depth]"
                MySql = MySql + "           ,[Width]"
                MySql = MySql + "           ,[RetentionCode]"
                MySql = MySql + ")"
                MySql = MySql + "VALUES"
                MySql = MySql + "("
                MySql = MySql + "@WebSite"
                MySql = MySql + ",@WebUrl"
                MySql = MySql + ",@UserID"
                MySql = MySql + ",@depth"
                MySql = MySql + ",@width"
                MySql = MySql + ",@RetentionCode"
                MySql = MySql + ")"

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: ", ex)
                B = False
            End Try
        Else
            Try
                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@WebSite", WebSite))
                command.Parameters.Add(New SqlParameter("@WebUrl", WebUrl))
                command.Parameters.Add(New SqlParameter("@UserID", UserID))
                command.Parameters.Add(New SqlParameter("@depth", depth))
                command.Parameters.Add(New SqlParameter("@width", width))
                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))

                MySql = MySql + "UPDATE [dbo].[WebSite]"
                MySql = MySql + " SET [WebSite] = @WebSite "
                MySql = MySql + " ,[WebUrl] = @WebUrl "
                MySql = MySql + " ,[UserID] = @UserID "
                MySql = MySql + " ,[depth] = @depth "
                MySql = MySql + " ,[width] = @width "
                MySql = MySql + " ,[RetentionCode] = @RetentionCode "

                MySql = MySql + WhereClause

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: 157848 " + ex.Message + Environment.NewLine + MySql)
                B = False
            End Try
        End If

        Return B

    End Function

    ''' <summary>
    ''' Saves the retention code.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="RetentionCode">The retention code.</param>
    ''' <param name="RetentionDesc">The retention desc.</param>
    ''' <param name="RetentionUnits">The retention units.</param>
    ''' <param name="RetentionAction">The retention action.</param>
    ''' <param name="ManagerID">The manager identifier.</param>
    ''' <param name="DaysWarning">The days warning.</param>
    ''' <param name="ResponseRequired">The response required.</param>
    ''' <param name="RetentionPeriod">The retention period.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function Save_RetentionCode(SecureID As Integer,
                                       RetentionCode As String,
                                       RetentionDesc As String,
                                       RetentionUnits As Integer,
                                       RetentionAction As String,
                                       ManagerID As String,
                                       DaysWarning As Integer,
                                       ResponseRequired As String,
                                       RetentionPeriod As String,
                                       ByRef RC As Boolean) As Boolean

        Dim sRetentionCode = RetentionCode.Replace("'", "''")

        RC = True
        Dim WhereClause As String = " where RetentionCode  = '" + sRetentionCode + "' "

        Dim S As String = "Select count(*) from Retention" + WhereClause
        Dim B As Boolean = False
        Dim iCnt As Integer = iCount(S)
        Dim MySql As String = ""
        Dim connection As New SqlConnection(getRepoConnStr())

        If connection.State = ConnectionState.Closed Then
            connection.Open()
        End If

        If iCnt = 0 Then
            Try

                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))
                command.Parameters.Add(New SqlParameter("@RetentionDesc", RetentionDesc))
                command.Parameters.Add(New SqlParameter("@RetentionUnits", RetentionUnits))
                command.Parameters.Add(New SqlParameter("@RetentionAction", RetentionAction.ToUpper))
                command.Parameters.Add(New SqlParameter("@ManagerID", ManagerID))
                command.Parameters.Add(New SqlParameter("@DaysWarning", DaysWarning))
                command.Parameters.Add(New SqlParameter("@ResponseRequired", ResponseRequired))
                command.Parameters.Add(New SqlParameter("@RetentionPeriod", RetentionPeriod))

                MySql = "INSERT INTO [dbo].[Retention]"
                MySql = MySql + "("
                MySql = MySql + "           [RetentionCode]"
                MySql = MySql + "           ,[RetentionDesc]"
                MySql = MySql + "           ,[RetentionUnits]"
                MySql = MySql + "           ,[RetentionAction]"
                MySql = MySql + "           ,[ManagerID]"
                MySql = MySql + "           ,[DaysWarning]"
                MySql = MySql + "           ,[ResponseRequired]"
                MySql = MySql + "           ,[RetentionPeriod]"
                MySql = MySql + ")"
                MySql = MySql + "VALUES"
                MySql = MySql + "("
                MySql = MySql + "@RetentionCode"
                MySql = MySql + ",@RetentionDesc"
                MySql = MySql + ",@RetentionUnits"
                MySql = MySql + ",@RetentionAction"
                MySql = MySql + ",@ManagerID"
                MySql = MySql + ",@DaysWarning"
                MySql = MySql + ",@ResponseRequired"
                MySql = MySql + ",@RetentionPeriod"
                MySql = MySql + ")"

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: ", ex)
                B = False
            End Try
        Else
            Try
                Dim command As New SqlCommand(MySql, connection)
                command.CommandType = CommandType.Text

                command.Parameters.Add(New SqlParameter("@RetentionCode", RetentionCode))
                command.Parameters.Add(New SqlParameter("@RetentionDesc", RetentionDesc))
                command.Parameters.Add(New SqlParameter("@RetentionUnits", RetentionUnits))
                command.Parameters.Add(New SqlParameter("@RetentionAction", RetentionAction.ToUpper))
                command.Parameters.Add(New SqlParameter("@ManagerID", ManagerID))
                command.Parameters.Add(New SqlParameter("@DaysWarning", DaysWarning))
                command.Parameters.Add(New SqlParameter("@ResponseRequired", ResponseRequired))
                command.Parameters.Add(New SqlParameter("@RetentionPeriod", RetentionPeriod))

                MySql = MySql + "UPDATE [dbo].[Retention] "
                MySql = MySql + " SET [RetentionCode] = @RetentionCode "
                MySql = MySql + " ,[RetentionDesc] = @RetentionDesc "
                MySql = MySql + " ,[RetentionUnits] = @RetentionUnits "
                MySql = MySql + " ,[RetentionAction] = @RetentionAction "
                MySql = MySql + " ,[ManagerID] = @ManagerID "
                MySql = MySql + " ,[DaysWarning] = @DaysWarning "
                MySql = MySql + " ,[ResponseRequired] = @ResponseRequired "
                MySql = MySql + " ,[RetentionPeriod] = @RetentionPeriod "

                MySql = MySql + WhereClause

                'connection.Open()
                command.CommandText = MySql
                command.ExecuteNonQuery()
                connection.Close()
                command.Dispose()
                B = True
            Catch ex As Exception
                Console.WriteLine("ERROR: 157848 " + ex.Message + Environment.NewLine + MySql)
                B = False
            End Try
        End If

        Return B

    End Function

    ''' <summary>
    ''' Gets the retention codes.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="RC">if set to <c>true</c> [rc].</param>
    ''' <returns>BindingSource.</returns>
    Public Function GET_RetentionCodes(SecureID As Integer, RC As Boolean) As BindingSource

        Dim MySql As String = Nothing
        MySql += "Select "
        MySql += "[RetentionCode], "
        MySql += "[RetentionDesc], "
        MySql += "[RetentionUnits], "
        MySql += "[RetentionAction], "
        MySql += "[ManagerID], "
        MySql += "[DaysWarning], "
        MySql += "[ResponseRequired], "
        MySql += "[RetentionPeriod] "
        MySql += " From [Retention] "
        MySql += " Order by [RetentionCode] "

        Dim CSstr As String = getRepoConnStr()
        Dim ConnStr As String = CSstr
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim BSource As New BindingSource
        Dim command As New SqlCommand(MySql, CONN)
        Dim rsDataQry As SqlDataReader = Nothing

        Try
            Dim dataAdapter = New SqlDataAdapter(MySql, ConnStr)
            Dim commandBuilder As New SqlCommandBuilder(dataAdapter)
            Dim table As New DataTable()
            table.Locale = System.Globalization.CultureInfo.InvariantCulture
            dataAdapter.Fill(table)
            BSource.DataSource = table
        Catch e As Exception
            ' xTrace(13321, "clsDataBase:getRssPull", e.Message.ToString())
        Finally
            If rsDataQry IsNot Nothing Then
                If Not rsDataQry.IsClosed Then
                    rsDataQry.Close()
                End If
                rsDataQry = Nothing
            End If
            command.Dispose()
            command = Nothing
        End Try

        Return BSource

    End Function

    ''' <summary>
    ''' Inserts the source child.
    ''' </summary>
    ''' <param name="ParentSourceGuid">The parent source unique identifier.</param>
    ''' <param name="ChildSourceGuid">The child source unique identifier.</param>
    Sub insertSourceChild(ParentSourceGuid As String, ChildSourceGuid As String)
        'SELECT FQN, SourceGuid FROM DataSource
        Dim S = "Select count(*) from [DataSourceChildren] where ParentSourceGuid = '" + ParentSourceGuid + "' and ChildSourceGuid = '" + ChildSourceGuid + "' "

        Dim iMax As Integer = iCount(S)

        If iMax > 0 Then
            Return
        End If

        S = "INSERT INTO [dbo].[DataSourceChildren] ([ParentSourceGuid] ,[ChildSourceGuid]) VALUES ('" + ParentSourceGuid + "' ,'" + ChildSourceGuid + "')"
        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("clsDatabaseARCH : insertSourceChild : 100 : Failed to add relationship.")
        End If

    End Sub

    ''' <summary>
    ''' Insertrs the ss child.
    ''' </summary>
    ''' <param name="rssRowGuid">The RSS row unique identifier.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    Sub insertrSSChild(rssRowGuid As String, SourceGuid As String)

        Dim S = "Select count(*) from [RSSChildren] where RssRowGuid = '" + rssRowGuid + "' and SourceGuid = '" + SourceGuid + "' "
        Dim iMax As Integer = iCount(S)

        If iMax > 0 Then
            Return
        End If

        S = "INSERT INTO [dbo].[DataSourceChildren] ([ParentSourceGuid] ,[ChildSourceGuid]) VALUES ('" + rssRowGuid + "' ,'" + SourceGuid + "')"
        Dim B As Boolean = Me.ExecuteSqlNewConn(S, False)

        If Not B Then
            LOG.WriteToArchiveLog("clsDatabaseARCH : AttributeExists : 100 : Failed to add attribute.")
        End If

    End Sub

    ''' <summary>
    ''' Inserts the email attachment record.
    ''' </summary>
    ''' <param name="EmailGuid">The email unique identifier.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <param name="AttachmentCode">The attachment code.</param>
    ''' <param name="AttachmentType">Type of the attachment.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <param name="RetMsg">The ret MSG.</param>
    ''' <param name="CRC">The CRC.</param>
    ''' <returns>System.String.</returns>
    Public Function InsertEmailAttachmentRecord(ByVal EmailGuid As String,
                                       ByVal AttachmentName As String,
                                       ByVal AttachmentCode As String,
                                       ByVal AttachmentType As String,
                                       ByVal UserID As String,
                                       ByRef RetMsg As String,
                                       CRC As String) As String

        Dim sGuid As String = ""
        AttachmentName = AttachmentName.Replace("'", "''")
        UserID = UserID.Replace("'", "''")
        Dim S As String = ""

        sGuid = Guid.NewGuid.ToString()

        S += " INSERT INTO [EmailAttachment]" + Environment.NewLine
        S += " ( " + Environment.NewLine
        S += "  [RowGuid]" + Environment.NewLine
        S += " ,[AttachmentName]" + Environment.NewLine
        S += " ,[EmailGuid]" + Environment.NewLine
        S += " ,[AttachmentCode]" + Environment.NewLine
        S += " ,[AttachmentType]" + Environment.NewLine
        S += " ,[UserID]" + Environment.NewLine
        S += " ,[CRC]" + Environment.NewLine
        S += " )" + Environment.NewLine
        S += " VALUES " + Environment.NewLine
        S += " ('" + sGuid + "'" + Environment.NewLine
        S += " ,'" + AttachmentName + "'" + Environment.NewLine
        S += " ,'" + EmailGuid + "'" + Environment.NewLine
        S += " ,'" + AttachmentCode + "'" + Environment.NewLine
        S += " ,'" + AttachmentType + "'" + Environment.NewLine
        S += " ,'" + UserID + "'" + Environment.NewLine
        S += " , convert(nvarchar(100), " + CRC + ")" + Environment.NewLine

        Dim cs As String = setConnStr()
        Dim B As Boolean = True
        Dim Validate As Boolean = False
        B = ExecuteSql(S, cs, False)
        If B Then
            S = "Update EmailAttachment set isPublic = (Select ispublic from Email where EmailGuid = '" + EmailGuid + "') "
            S += " where EmailGuid = '" + EmailGuid + "'"
            B = ExecuteSql(S, cs, False)
        End If

        Return sGuid

    End Function

    ''' <summary>
    ''' Saves the upload stats.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="OriginalSize">Size of the original.</param>
    ''' <param name="CompressedSize">Size of the compressed.</param>
    ''' <param name="TxStartTime">The tx start time.</param>
    ''' <param name="TxEndTime">The tx end time.</param>
    ''' <param name="TxTotalTime">The tx total time.</param>
    ''' <param name="BPS">The BPS.</param>
    ''' <param name="AttachmentName">Name of the attachment.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function SaveUploadStats(SecureID As Integer, ByVal RepositoryTable As String, ByVal SourceGuid As String,
                             ByVal OriginalSize As Integer,
                             ByVal CompressedSize As Integer,
                             ByVal TxStartTime As Date,
                             ByVal TxEndTime As Date,
                             ByVal TxTotalTime As Decimal,
                             ByVal BPS As Decimal, ByVal AttachmentName As String) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        RepositoryTable = RepositoryTable.ToUpper

        Dim B As Boolean = True

        Dim ConnStr As String = setConnStr()
        Dim CONN As New SqlConnection(ConnStr)
        If CONN.State = ConnectionState.Closed Then
            CONN.Open()
        End If

        Dim CMD As New SqlCommand()
        CMD.CommandType = CommandType.Text
        Dim S As String = ""

        Try

            If RepositoryTable.Equals("DATASOURCE") Then
                S = "Update DataSource set "
                S += "OriginalSize = @OriginalSize"
                S += ", CompressedSize = @CompressedSize"
                S += ", TxStartTime = @TxStartTime"
                S += ", TxEndTime = @TxEndTime"
                S += ", TxTotalTime = @TxTotalTime"
                S += ", BPS = @BPS"
                S += " Where SourceGuid = @SourceGuid"
                CMD.Connection = CONN
                CMD.CommandText = S
                CMD.CommandType = CommandType.Text
                Using CONN
                    Using CMD
                        CMD.Parameters.AddWithValue("@SourceGuid", SourceGuid)
                        CMD.Parameters.AddWithValue("@OriginalSize", OriginalSize)
                        CMD.Parameters.AddWithValue("@CompressedSize", CompressedSize)
                        CMD.Parameters.AddWithValue("@TxStartTime", TxStartTime)
                        CMD.Parameters.AddWithValue("@TxEndTime", TxEndTime)
                        CMD.Parameters.AddWithValue("@TxTotalTime", TxTotalTime)
                        CMD.Parameters.AddWithValue("@BPS", BPS)
                        CMD.ExecuteNonQuery()
                    End Using
                End Using
            End If
            If RepositoryTable.Equals("EMAIL") Then
                S = "Update email set "
                S += "OriginalSize = @OriginalSize"
                S += ", CompressedSize = @CompressedSize"
                S += ", TxStartTime = @TxStartTime"
                S += ", TxEndTime = @TxEndTime"
                S += ", TxTotalTime = @TxTotalTime"
                S += ", BPS = @BPS"
                S += " Where EmailGuid = @EmailGuid"
                CMD.Connection = CONN
                CMD.CommandText = S
                CMD.CommandType = CommandType.Text
                Using CONN
                    Using CMD
                        CMD.Parameters.AddWithValue("@EmailGuid", SourceGuid)
                        CMD.Parameters.AddWithValue("@OriginalSize", OriginalSize)
                        CMD.Parameters.AddWithValue("@CompressedSize", CompressedSize)
                        CMD.Parameters.AddWithValue("@TxStartTime", TxStartTime)
                        CMD.Parameters.AddWithValue("@TxEndTime", TxEndTime)
                        CMD.Parameters.AddWithValue("@TxTotalTime", TxTotalTime)
                        CMD.Parameters.AddWithValue("@BPS", BPS)
                        CMD.ExecuteNonQuery()
                    End Using
                End Using
            End If
            If RepositoryTable.Equals("EMAILATTACHMENT") Then
                S = "Update EmailAttachment set "
                S += "OriginalSize = @OriginalSize"
                S += ", CompressedSize = @CompressedSize"
                S += ", TxStartTime = @TxStartTime"
                S += ", TxEndTime = @TxEndTime"
                S += ", TxTotalTime = @TxTotalTime"
                S += ", BPS = @BPS"
                S += " Where EmailGuid = @EmailGuid"
                S += " AND AttachmentName = @AttachmentName"
                CMD.Connection = CONN
                CMD.CommandText = S
                CMD.CommandType = CommandType.Text
                Using CONN
                    Using CMD
                        CMD.Parameters.AddWithValue("@EmailGuid", SourceGuid)
                        CMD.Parameters.AddWithValue("@AttachmentName", AttachmentName)
                        CMD.Parameters.AddWithValue("@OriginalSize", OriginalSize)
                        CMD.Parameters.AddWithValue("@CompressedSize", CompressedSize)
                        CMD.Parameters.AddWithValue("@TxStartTime", TxStartTime)
                        CMD.Parameters.AddWithValue("@TxEndTime", TxEndTime)
                        CMD.Parameters.AddWithValue("@TxTotalTime", TxTotalTime)
                        CMD.Parameters.AddWithValue("@BPS", BPS)
                        CMD.ExecuteNonQuery()
                    End Using
                End Using
            End If
        Catch ex As Exception
            ' xTrace(66001, "SaveUploadStats" + ex.Message)
        Finally
            CMD.Dispose()
            CONN.Close()
            CONN.Dispose()
            GC.Collect()
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Inserts the image to repo table.
    ''' </summary>
    ''' <param name="ID">The identifier.</param>
    ''' <param name="UID">The uid.</param>
    ''' <param name="tgtGuid">The TGT unique identifier.</param>
    ''' <param name="iRead">The i read.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <param name="FileName">Name of the file.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="LastSegment">if set to <c>true</c> [last segment].</param>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="Buffer">The buffer.</param>
    ''' <returns>System.String.</returns>
    Public Function InsertImageToRepoTable(ByVal ID As Integer,
                                         ByVal UID As String,
                                         ByVal tgtGuid As String,
                                         ByVal iRead As Integer,
                                         ByVal FileHash As String,
                                         ByVal FileLength As Long,
                                         ByVal FileName As String,
                                         ByVal RepositoryTable As String, ByVal LastSegment As Boolean,
                                         ByVal OriginalFileName As String,
                                         ByVal Buffer() As Byte) As String
        Dim LL As Double = 0
        Dim B As Boolean = True
        Dim S As String = ""

        RepositoryTable = RepositoryTable.ToUpper

        Select Case (RepositoryTable)
            Case "EMAIL"
                S = "Update EMAIL set FileAttached = 0, CRC = '" + FileHash + "' where EmailGuid = '" + tgtGuid + "'"
            Case "EMAILATTACHMENT"
                S = "Update EmailAttachment set FileAttached = 0, CRC = '" + FileHash + "'  where RowGuid = '" + tgtGuid + "'"
            Case "DATASOURCE"
                S = "Update DataSource set FileAttached = 0, CRC = '" + FileHash + "' where SourceGuid = '" + tgtGuid + "'"
            Case Else
                S = "ERROR: 10029 - RepositoryTable not correctly set."
        End Select

        Dim RetMsg As String = ""
        Dim oFileStream As System.IO.FileStream = Nothing
        Dim lByte As Long = FileLength : LL = 2.2
        Dim lLoop As Long = 0 : LL = 2.3
        Dim bLoadFileToDB As Boolean = False
        Dim bUploaded As Boolean = False : LL = 5
        Dim ErrMsg As String = "" : LL = 6

        '' xTrace(8200, UID, "InsertImageToRepoTable", "LL = " + LL.ToString)

        Dim UploadPath As String = System.Configuration.ConfigurationManager.AppSettings("UploadPath") : LL = 7
        Dim EmailUploadPath As String = UploadPath + "\Email" : LL = 8
        EmailUploadPath = EmailUploadPath.Replace("\\", "\") : LL = 9

        Dim EmailAttachmentUploadPath As String = UploadPath + "\OCR\Extract\StagedOcrFiles\" : LL = 10
        EmailAttachmentUploadPath = EmailAttachmentUploadPath.Replace("\\", "\") : LL = 11

        Dim ContentUploadPath As String = UploadPath + "\DataSource" : LL = 12
        ContentUploadPath = ContentUploadPath.Replace("\\", "\") : LL = 13

        Dim FQN2Upload As String = UploadPath + "\" + FileName : LL = 14
        FQN2Upload = FQN2Upload.Replace("\\", "\")

        Dim FQN2Remove As String = UploadPath + "\" + FileName
        FQN2Remove = FQN2Remove.Replace("\\", "\") : LL = 15

        LL = 3
        Try
            Dim CS As String = setConnStr()
            B = ExecuteSql(S, CS, False) : LL = 4
            ' Create a file and write the byte data to a file.
            oFileStream = New System.IO.FileStream(FQN2Upload, System.IO.FileMode.Create) : LL = 16
            oFileStream.Write(Buffer, 0, iRead) : LL = 17
            If iRead < Buffer.Length Or iRead = FileLength Or LastSegment Then
                LL = 18
                bLoadFileToDB = True
            End If
            LL = 19
        Catch ex As Exception
            bLoadFileToDB = False
            ErrMsg = "ERROR - InsertImageToRepoTable: " + FileName + Environment.NewLine + ex.Message.ToString
        Finally
            oFileStream.Close()
            oFileStream.Dispose()
            GC.Collect()
            GC.WaitForPendingFinalizers()
        End Try
        LL = 20
        '' xTrace(8200, UID, "InsertImageToRepoTable", "LL = " + LL.ToString)

        If bLoadFileToDB Then
            '** Decompress
            'Dim A As System.Reflection.Assembly = Me.GetType.Assembly
            'Dim fStream As Stream = A.GetManifestResourceStream(FQN2Upload)
            Dim myZip As New C1.C1Zip.C1ZipFile : LL = 21
            Try
                '*********************************************************
                '** Decompress Zip File
                '********************************************************
                If Not Directory.Exists(EmailUploadPath) Then
                    Directory.CreateDirectory(EmailUploadPath)
                End If
                LL = 23
                If Not Directory.Exists(EmailAttachmentUploadPath) Then
                    Directory.CreateDirectory(EmailAttachmentUploadPath)
                End If
                LL = 24
                If Not Directory.Exists(ContentUploadPath) Then
                    Directory.CreateDirectory(ContentUploadPath)
                End If
                LL = 25
                myZip.Open(FQN2Upload) : LL = 26
                For Each zipEntry As C1.C1Zip.C1ZipEntry In myZip.Entries
                    LL = 27
                    Dim bGoodCrc As Boolean = zipEntry.CheckCRC32
                    LL = 28
                    If bGoodCrc Then
                        Dim zFilename As String = zipEntry.FileName
                        If RepositoryTable.Equals("EMAIL") Then
                            FQN2Upload = EmailUploadPath + "\" + tgtGuid + ".RDY"
                            FQN2Upload = FQN2Upload.Replace("\\", "\")
                            zipEntry.Extract(FQN2Upload)
                        ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
                            FQN2Upload = EmailAttachmentUploadPath + "\" + tgtGuid + ".RDY"
                            FQN2Upload = FQN2Upload.Replace("\\", "\")
                            zipEntry.Extract(FQN2Upload)
                        ElseIf RepositoryTable.Equals("DATASOURCE") Then
                            FQN2Upload = ContentUploadPath + "\" + tgtGuid + ".RDY"
                            FQN2Upload = FQN2Upload.Replace("\\", "\")
                            zipEntry.Extract(FQN2Upload)
                        End If
                    End If
                    LL = 29
                Next
                LL = 30
            Catch ex As Exception
                MsgBox(ex.Message)
                ' xTrace(82889, "InsertImageToRepoTable", "ERROR - InsertImageToRepoTable : LL = " + LL.ToString + ":" + FileName)
            Finally
                LL = 31
                '*********************************************************
                '** Delete zip file
                '*********************************************************
                myZip.Close()
                LL = 32
            End Try
            LL = 33
            '' xTrace(8200, UID, "InsertImageToRepoTable", "LL = " + LL.ToString)

            If Not File.Exists(FQN2Upload) Then
                ' xTrace(82900, "ERROR - InsertImageToRepoTable", "LL = " + LL.ToString + ":" + FileName)

            End If

            '**** Load a Byte Array with the just loaded file ************
            Dim oFile As System.IO.FileInfo
            oFile = New System.IO.FileInfo(FQN2Upload)
            Dim xFileStream As System.IO.FileStream = oFile.OpenRead()
            Dim lBytes As Long = xFileStream.Length
            Dim iBytes As Integer = Convert.ToInt32(lBytes - 1)
            Dim fileData(iBytes - 1) As Byte
            LL = 34
            If (lBytes > 0) Then
                ' Read the file into a byte array
                xFileStream.Read(fileData, 0, iBytes)
                xFileStream.Close()
                xFileStream.Dispose()
            End If

            Dim SuccessfulUpload As Boolean = True
            Dim ConnStr As String = setConnStr()
            Dim CONN As New SqlConnection(ConnStr)
            If CONN.State = ConnectionState.Closed Then
                CONN.Open()
            End If
            LL = 35
            Dim CMD As New SqlCommand()
            CMD.CommandType = CommandType.StoredProcedure
            Try
                LL = 36
                '' xTrace(8200, UID, "InsertImageToRepoTable", "LL = " + LL.ToString)

                Dim MySql As String = "Update [DataSource] 
                                        set SourceImage = @SourceImage 
                                        Where SourceGuid = @SourceGuid"

                If RepositoryTable.Equals("DATASOURCE") Then
                    CMD.Connection = CONN
                    'CMD.CommandText = "[UpdateDataSourceImage]"
                    'CMD.CommandType = CommandType.StoredProcedure
                    CMD.CommandText = MySql
                    CMD.CommandType = CommandType.Text
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@SourceGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@SourceImage", fileData))
                            Try
                                CMD.ExecuteNonQuery()
                            Catch ex As Exception
                                LOG.WriteToArchiveLog("FATAL ERROR InsertImageToRepoTable 01: " + ex.Message)
                            End Try
                        End Using
                    End Using
                End If
                LL = 37
                If RepositoryTable.Equals("EMAIL") Then
                    LL = 38
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailFilestream"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@EmailGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@EmailImage", fileData))
                            Try
                                CMD.ExecuteNonQuery()
                            Catch ex As Exception
                                LOG.WriteToArchiveLog("FATAL ERROR InsertImageToRepoTable 02: " + ex.Message)
                            End Try
                        End Using
                    End Using
                End If
                LL = 39
                If RepositoryTable.Equals("EMAILATTACHMENT") Then
                    LL = 40
                    'Dim TSql As String = "Update [EmailAttachment] set Attachment = @Attachment Where RowGuid = @RowGuid"
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailAttachmentFilestreamV2"
                    'CMD.CommandText = TSql
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@RowGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@Attachment", fileData))
                            CMD.Parameters.Add(New SqlParameter("@LastAccessDate", Now))
                            Try
                                CMD.ExecuteNonQuery()
                            Catch ex As Exception
                                LOG.WriteToArchiveLog("FATAL ERROR InsertImageToRepoTable 03: " + ex.Message)
                            End Try
                        End Using
                    End Using
                End If
                LL = 41
            Catch ex As Exception
                SuccessfulUpload = False
                ' xTrace(8285, "ERROR - InsertImageToRepoTable", "LL = " + LL.ToString + ":" + FileName + ":" + ex.ToString)
            Finally
                LL = 42
                oFile = Nothing
                fileData = Nothing
                CMD.Dispose()
                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
                CONN.Dispose()
                Try
                    File.Delete(FQN2Upload)
                Catch ex As Exception
                    ' xTrace(82888, "InsertImageToRepoTable", "ERROR - InsertImageToRepoTable  @ LL = " + LL.ToString + ":" + FileName + ":" + ex.ToString)
                End Try

                If RepositoryTable.Equals("EMAIL") Then
                    S = "Update EMAIL set FileAttached = 1 where EmailGuid = '" + tgtGuid + "'"
                ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
                    S = "Update EmailAttachment set FileAttached = 1 where EmailGuid = '" + tgtGuid + "'"
                ElseIf RepositoryTable.Equals("DATASOURCE") Then
                    S = "Update DataSource set FileAttached = 1 where SourceGuid = '" + tgtGuid + "'"
                End If
                LL = 43
                Dim CS As String = setConnStr()
                B = ExecuteSql(S, CS, False)
                LL = 44
            End Try
        End If
        GC.Collect()

        Return ErrMsg

    End Function

    ''' <summary>
    ''' Uploads the buffered append.
    ''' </summary>
    ''' <param name="UID">The uid.</param>
    ''' <param name="tgtGuid">The TGT unique identifier.</param>
    ''' <param name="iRead">The i read.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <param name="FileLength">Length of the file.</param>
    ''' <param name="FileName">Name of the file.</param>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="RetMsg">The ret MSG.</param>
    ''' <param name="LastSegment">if set to <c>true</c> [last segment].</param>
    ''' <param name="OriginalFileName">Name of the original file.</param>
    ''' <param name="Buffer">The buffer.</param>
    ''' <returns>System.String.</returns>
    Public Function UploadBufferedAppend(ByVal UID As String, ByVal tgtGuid As String, ByVal iRead As Integer, ByVal FileHash As String,
                                         ByVal FileLength As Long,
                                         ByVal FileName As String,
                                         ByVal RepositoryTable As String, ByRef RetMsg As String, ByVal LastSegment As Boolean,
                                         ByVal OriginalFileName As String,
                                         ByVal Buffer() As Byte) As String

        '** Check to see if this file requires OCR or PDF processing here
        '** If so, copy it to the Processing directory and let the command line utiltiy process it

        RepositoryTable = RepositoryTable.ToUpper
        Dim bUploaded As Boolean = False
        Dim ErrMsg As String = ""
        Dim UploadPath As String = System.Configuration.ConfigurationManager.AppSettings("UploadPath")
        Dim EmailUploadPath As String = UploadPath + "\Email"
        Dim EmailAttachmentUploadPath As String = UploadPath + "\OCR\Extract\StagedOcrFiles\"
        Dim ContentUploadPath As String = UploadPath + "\DataSource"
        Dim FQN2Upload As String = UploadPath + "\" + FileName
        Dim FQN2Remove As String = UploadPath + "\" + FileName

        Dim oFileStream As System.IO.FileStream = Nothing
        Dim lByte As Long = FileLength
        Dim lLoop As Long = 0
        Dim bLoadFileToDB As Boolean = False
        Dim FQN As String = UploadPath + "\" + FileName

        Dim S As String = ""
        If RepositoryTable.Equals("EMAIL") Then
            S = "Update EMAIL set FileAttached = 0 where EmailGuid = '" + tgtGuid + "'"
        ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
            S = "Update EmailAttachment set FileAttached = 0 where EmailGuid = '" + tgtGuid + "'"
        ElseIf RepositoryTable.Equals("DATASOURCE") Then
            S = "Update DataSource set FileAttached = 0 where SourceGuid = '" + tgtGuid + "'"
        End If

        Dim CS As String = setConnStr()
        Dim B As Boolean = ExecuteSqlNewConn(S, CS, False)

        Try
            ' Create a file and write the byte data to a file.
            oFileStream = New System.IO.FileStream(FQN, System.IO.FileMode.Append)
            oFileStream.Write(Buffer, 0, iRead - 1)
            If iRead < Buffer.Length Or LastSegment Then
                '** Add and EOF marker
                Dim bufx(0) As Byte
                bufx(0) = &H0
                oFileStream.Write(bufx, 0, bufx.Length)
                bLoadFileToDB = True
            End If
        Catch ex As Exception
            ErrMsg = "ERROR - UploadBufferedAppend: " + FileName + Environment.NewLine + ex.Message.ToString
        Finally
            oFileStream.Close()
            oFileStream.Dispose()
            GC.Collect()
            GC.WaitForPendingFinalizers()
        End Try

        If bLoadFileToDB Then
            '** Decompress
            'Dim A As System.Reflection.Assembly = Me.GetType.Assembly
            'Dim fStream As Stream = A.GetManifestResourceStream(FQN2Upload)
            Dim myZip As New C1.C1Zip.C1ZipFile
            Try
                '*********************************************************
                '** Decompress Zip File
                '********************************************************
                If Not Directory.Exists(EmailUploadPath) Then
                    Directory.CreateDirectory(EmailUploadPath)
                End If
                If Not Directory.Exists(EmailAttachmentUploadPath) Then
                    Directory.CreateDirectory(EmailAttachmentUploadPath)
                End If
                If Not Directory.Exists(ContentUploadPath) Then
                    Directory.CreateDirectory(ContentUploadPath)
                End If
                myZip.Open(FQN2Upload)
                For Each zipEntry As C1.C1Zip.C1ZipEntry In myZip.Entries
                    Dim bGoodCrc As Boolean = zipEntry.CheckCRC32
                    If bGoodCrc Then
                        Dim zFilename As String = zipEntry.FileName
                        If RepositoryTable.Equals("EMAIL") Then
                            FQN2Upload = EmailUploadPath + "\" + tgtGuid + ".RDY"
                            zipEntry.Extract(FQN2Upload)
                        ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
                            FQN2Upload = EmailAttachmentUploadPath + "\" + tgtGuid + ".RDY"
                            zipEntry.Extract(FQN2Upload)
                        ElseIf RepositoryTable.Equals("DATASOURCE") Then
                            FQN2Upload = ContentUploadPath + "\" + tgtGuid + ".RDY"
                            zipEntry.Extract(FQN2Upload)
                        End If
                    End If
                Next
            Catch ex As Exception
                MsgBox(ex.Message)
                Console.Write(ex.Message)
            Finally
                '*********************************************************
                '** Delete zip file
                '*********************************************************
                myZip.Close()
                File.Delete(FQN2Remove)
            End Try

            '**** Load a Byte Array with the just loaded file ************
            Dim oFile As System.IO.FileInfo
            oFile = New System.IO.FileInfo(FQN2Upload)
            Dim xFileStream As System.IO.FileStream = oFile.OpenRead()
            Dim lBytes As Long = xFileStream.Length
            Dim fileData(Convert.ToInt32(lBytes - 1)) As Byte
            If (lBytes > 0) Then
                ' Read the file into a byte array
                xFileStream.Read(fileData, 0, Convert.ToInt32(lBytes))
                xFileStream.Close()
                xFileStream.Dispose()
            End If

            Dim SuccessfulUpload As Boolean = True
            Dim ConnStr As String = setConnStr()
            Dim CONN As New SqlConnection(ConnStr)
            If CONN.State = ConnectionState.Closed Then
                CONN.Open()
            End If
            Dim CMD As New SqlCommand()
            CMD.CommandType = CommandType.StoredProcedure
            Try
                If RepositoryTable.Equals("DATASOURCE") Then
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateSourceFilestream"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@SourceGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@SourceImage", fileData))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
                If RepositoryTable.Equals("EMAIL") Then
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailFilestream"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@EmailGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@EmailImage", fileData))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
                If RepositoryTable.Equals("EMAILATTACHMENT") Then
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailAttachmentFilestream"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@EmailGuid", tgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@Attachment", fileData))
                            CMD.Parameters.Add(New SqlParameter("@AttachmentName", OriginalFileName))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
            Catch ex As Exception
                SuccessfulUpload = False
                MsgBox("ERROR InsertImageToRepoTable 100: " + ex.Message)
            Finally
                oFile = Nothing
                fileData = Nothing
                CMD.Dispose()
                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
                CONN.Dispose()
                File.Delete(FQN2Upload)

                If RepositoryTable.Equals("EMAIL") Then
                    S = "Update EMAIL set FileAttached = 1 where EmailGuid = '" + tgtGuid + "'"
                ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
                    S = "Update EmailAttachment set FileAttached = 1 where EmailGuid = '" + tgtGuid + "'"
                ElseIf RepositoryTable.Equals("DATASOURCE") Then
                    S = "Update DataSource set FileAttached = 1 where SourceGuid = '" + tgtGuid + "'"
                End If

                CS = setConnStr()
                B = ExecuteSqlNewConn(S, CS, False)

            End Try
        End If
        GC.Collect()

        Return ErrMsg

    End Function

    ''' <summary>
    ''' Verifies the retention dates.
    ''' </summary>
    ''' <param name="SecureID">The secure identifier.</param>
    Sub VerifyRetentionDates(SecureID As Integer)

        Dim MySql As String = ""
        Dim B As Boolean = False
        Dim RetMsg As String = " "
        Dim CS As String = setConnStr()

        MySql = ""
        MySql += " update DataSource set "
        MySql += " RetentionExpirationDate = getdate() + (select retentionYears from Retention where RetentionCode = DataSource.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSql(MySql, CS, False)
        If RetMsg.Trim.Length > 0 Then
            ' xTrace(66110, "VerifyRetentionDates", MySql)
        End If

        MySql = ""
        MySql += " update email set"
        MySql += " RetentionExpirationDate = getdate() + (select retentionYears from Retention where RetentionCode = email.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSql(MySql, CS, False)
        If RetMsg.Trim.Length > 0 Then
            ' xTrace(66111, "VerifyRetentionDates", MySql)
        End If

        MySql = ""
        MySql += " update EmailAttachment set "
        MySql += " RetentionExpirationDate = getdate() + (select retentionYears from Retention where RetentionCode = EmailAttachment.RetentionCode) * 365.255"
        MySql += " where RetentionExpirationDate < GETDATE() - 25 * 365.55"
        B = ExecuteSql(MySql, CS, False)
        If RetMsg.Trim.Length > 0 Then
            ' xTrace(66112, "VerifyRetentionDates", MySql)
        End If

    End Sub

    ''' <summary>
    ''' Cks the content exists.
    ''' </summary>
    ''' <param name="SourceName">Name of the source.</param>
    ''' <param name="HexHash">The hexadecimal hash.</param>
    ''' <returns>RID - the record rowid if exists, null if not</returns>
    Function ckContentExists(SourceName As String, HexHash As String) As String
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim RID As String = ""
        If Not HexHash.Contains("0x") Then
            HexHash = "0x" + HexHash
        End If
        Dim S As String = "Select RowID from datasource 
            where SourceName = '" + SourceName + "'
            And ImageHash = " + HexHash + " "

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Dim command As New SqlCommand(S, CONN)
        RSData = command.ExecuteReader()
        If RSData.HasRows Then
            Do While RSData.Read()
                RID = RSData.GetValue(0).ToString
            Loop
        End If
        RSData.Close()
        RSData = Nothing

        CONN.Close()
        CONN.Dispose()

        Return RID
    End Function

    ''' <summary>
    ''' Cks the content owner exists.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="UserID">The user identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckContentOwnerExists(ByVal ContentGuid As String,
                              ByVal UserID As String
                              ) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If
        Dim iCnt As Integer = 0
        Dim S As String = ""

        Dim MachineGuid As String = """"

        S = "Select count(*) from ContentUser where ContentGuid = '" + ContentGuid + "' and UserID = '" + UserID + "'"
        iCnt = iCount(S)

        If iCnt = 0 Then
            Return False
        End If

        Return True

    End Function

    ''' <summary>
    ''' Cks the content owner exists.
    ''' </summary>
    ''' <param name="ContentGuid">The content unique identifier.</param>
    ''' <param name="RID">The rid.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function ckContentOwnerExists(ByVal ContentGuid As String,
                              ByVal RID As Integer
                              ) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If
        Dim iCnt As Integer = 0
        Dim S As String = ""

        Dim MachineGuid As String = """"

        S = "Select count(*) from ContentUser where ContentGuid = '" + ContentGuid + "' and RID = " + RID.ToString
        iCnt = iCount(S)

        If iCnt = 0 Then
            Return False
        End If

        Return True

    End Function

    ''' <summary>
    ''' Inserts the selected single file.
    ''' </summary>
    ''' <param name="FQN">The FQN of the selected single file.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function insertSingleFILE(FQN As String) As String

        Dim SourceGuid As String = Guid.NewGuid.ToString

        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim B As Boolean = True

        Try
            Dim versionNumber As String = Application.ProductVersion.ToString

            Dim bSuccess As Boolean = True

            Dim BPS As Double = 0
            Dim CompressedSize As Integer = 0
            Dim ContainedWithin As String = ""
            Dim CRC As String = ""
            Dim CreateDate As DateTime = Now
            Dim CreationDate As DateTime = Now
            Dim DataSourceOwnerUserID As String = ""
            Dim DataVerified As Boolean = True
            Dim Description As String = FQN + " loaded as a single file upload"
            Dim FileAttached As Boolean = True
            Dim FileDirectory As String = ""
            Dim FileDirectoryName As String = ""
            Dim FileLength As Integer = 0
            Dim FqnHASH As String = ENC.SHA512SqlServerHash(FQN)
            Dim GraphicContainsText As Char = ""
            Dim HashFile As String = ""
            Dim HashName As String = ""
            Dim HiveActive As Boolean = True
            Dim HiveConnectionName As String = ""
            Dim Imagehash As String = ""
            Dim ImageHiddenText As String = ""
            Dim ImageLen As Integer = 0
            Dim isAvailable As Char = ""
            Dim isContainedWithinZipFile As Char = ""
            Dim isGraphic As Char = ""
            Dim isMaster As Char = ""
            Dim isPerm As Char = ""
            Dim isPublic As Char = ""
            Dim IsPublicPreviousState As Char = ""
            Dim isWebPage As Char = ""
            Dim IsZipFile As String = "N"
            Dim KeyWords As String = ""
            Dim LastAccessDate As DateTime = Now
            Dim LastWriteTime As DateTime = Now
            Dim MachineID As String = ""
            Dim Notes As String = ""
            Dim OcrPending As Char = ""
            Dim OcrPerformed As Char = ""
            Dim OcrSuccessful As Char = ""
            Dim OcrText As String = ""
            Dim OriginalFileType As String = ""
            Dim OriginalSize As Integer = 0
            Dim PageURL As String = ""
            Dim ParentGuid As String = ""
            Dim PdfImages As Integer = 0
            Dim PdfIsSearchable As Char = ""
            Dim PdfOcrRequired As Char = ""
            Dim PdfOcrSuccess As Char = ""
            Dim PdfOcrTextExtracted As Char = ""
            Dim PdfPages As Integer = 0
            Dim RecHash As String = ""
            Dim RecLen As Decimal = 0
            Dim RecTimeStamp As DateTime = Now
            Dim RepoName As String = ""
            Dim RepoSvrName As String = ""
            Dim RequireOcr As Boolean = True
            Dim RetentionCode As String = ""
            Dim RetentionDate As DateTime = Now
            'Dim RetentionExpirationDate As DateTime = Now
            Dim RowCreationDate As DateTime = Now
            Dim RowGuid As String = Guid.NewGuid.ToString
            'Dim RowGuid2 As String = Guid.NewGuid.ToString
            'Dim RowID As Integer = 0
            Dim RowLastModDate As DateTime = Now
            Dim RssLinkFlg As Boolean = True
            Dim RssLinkGuid As String = ""
            Dim SapData As Boolean = True
            Dim SharePoint As Boolean = True
            Dim SharePointDoc As Boolean = True
            Dim SharePointList As Boolean = True
            Dim SharePointListItem As Boolean = True

            Dim SourceImageOrigin As String = ""
            Dim SourceName As String = ""
            Dim SourceTypeCode As String = ""
            Dim StructuredData As Boolean = True
            Dim TransmitTime As Decimal = 0
            Dim txEndTime As DateTime = Now
            Dim txStartTime As DateTime = Now
            Dim txTotalTime As Decimal = 0
            Dim URLHash As String = ""
            Dim UserID As String = ""
            Dim VersionNbr As Integer = 0
            Dim WebPagePublishDate As String = ""
            Dim ZipFileFQN As String = ""
            Dim ZipFileGuid As String = Guid.NewGuid.ToString

            Dim FI As New FileInfo(FQN)
            Dim Successful As Boolean = True

            If FI.Extension.ToLower.Equals(".zip") Then
                ZipFileGuid = Guid.NewGuid.ToString
                ZipFileFQN = FI.FullName
                IsZipFile = "Y"
            Else
                ZipFileGuid = ""
                ZipFileFQN = ""
                IsZipFile = "N"
            End If

            Dim crchash As String = ENC.GenerateSHA512HashFromFile(FI.FullName)
            CRC = crchash
            Imagehash = crchash

            HashName = "SHA512"

            RetentionCode = getRetentionCode(gCurrLoginID, FI.DirectoryName)
            Dim RetentionYears As Integer = getRetentionPeriod(RetentionCode)

            Dim rightNow As Date = Now
            If RetentionYears = 0 Then
                RetentionYears = Val(getSystemParm("RETENTION YEARS"))
            End If
            rightNow = rightNow.AddYears(RetentionYears)
            Dim RetentionExpirationDate As String = rightNow.ToString

            If Convert.ToDateTime(RetentionDate) <= Now Then
                Dim NewDate As DateTime = DateAdd("yyyy", 10, Now)
                RetentionDate = NewDate.ToString
            End If

            Dim SourceImage As Byte() = IO.File.ReadAllBytes(FI.FullName)

            Dim GraphicTypes As List(Of String) = getListOf("select lower(GraphicFileTypeExt) from GraphicFileType")
            If GraphicTypes.Contains(FI.Extension.ToLower) Then
                OcrPending = "Y"
                OcrPerformed = "N"
                RequireOcr = True
            Else
                OcrPending = "N"
                OcrPerformed = "N"
                RequireOcr = False
            End If

            If SourceImage.Length.Equals(0) Then
                LOG.WriteToArchiveLog("clsDatabaseARCH : InsertNewContent : 90 : " + FQN + " appears to have ZERO content.")
                LOG.WriteToFailedLoadLog("clsDatabaseARCH : InsertNewContent : 90 " + FQN + " appears to have ZERO content.")
                Return False
            End If

            Dim CheckLen As Boolean = False
            If CheckLen Then
                If SourceGuid.Length > 50 Then Console.WriteLine("ERROR: SourceGuid")
                If SourceName.Length > 1000 Then Console.WriteLine("ERROR: SourceName")
                If SourceTypeCode.Length > 50 Then Console.WriteLine("ERROR: SourceTypeCode")
                If FQN.Length > 2000 Then Console.WriteLine("ERROR: FQN")
                If UserID.Length > 50 Then Console.WriteLine("ERROR: UserID")
                If DataSourceOwnerUserID.Length > 50 Then Console.WriteLine("ERROR: DataSourceOwnerUserID")
                'If isPublic.length > 1 Then CONSOLE.WRITELINE("ERROR: isPublic")
                If FileDirectory.Length > 1000 Then Console.WriteLine("ERROR: FileDirectory")
                If OriginalFileType.Length > 50 Then Console.WriteLine("ERROR: OriginalFileType")
                'If IsPublicPreviousState.length > 1 Then CONSOLE.WRITELINE("ERROR: IsPublicPreviousState")
                'If isAvailable.length > 1 Then CONSOLE.WRITELINE("ERROR: isAvailable")
                'If isContainedWithinZipFile.length > 1 Then CONSOLE.WRITELINE("ERROR: isContainedWithinZipFile")
                If IsZipFile.Length > 1 Then Console.WriteLine("ERROR: IsZipFile")
                If ZipFileGuid.Length > 50 Then Console.WriteLine("ERROR: ZipFileGuid")
                If ZipFileFQN.Length > 712 Then Console.WriteLine("ERROR: ZipFileFQN")
                If Description.Length > -1 Then Console.WriteLine("ERROR: Description")
                If KeyWords.Length > 2000 Then Console.WriteLine("ERROR: KeyWords")
                If Notes.Length > 2000 Then Console.WriteLine("ERROR: Notes")
                'If isPerm.length > 1 Then CONSOLE.WRITELINE("ERROR: isPerm")
                'If isMaster.length > 1 Then CONSOLE.WRITELINE("ERROR: isMaster")
                'If OcrPerformed.length > 1 Then CONSOLE.WRITELINE("ERROR: OcrPerformed")
                'If isGraphic.length > 1 Then CONSOLE.WRITELINE("ERROR: isGraphic")
                'If GraphicContainsText.length > 1 Then CONSOLE.WRITELINE("ERROR: GraphicContainsText")
                'If OcrText.Length > -1 Then Console.WriteLine("ERROR: OcrText")
                'If ImageHiddenText.Length > -1 Then Console.WriteLine("ERROR: ImageHiddenText")
                'If isWebPage > 1 Then CONSOLE.WRITELINE("ERROR: isWebPage")
                If ParentGuid.Length > 50 Then Console.WriteLine("ERROR: ParentGuid")
                If RetentionCode.Length > 50 Then Console.WriteLine("ERROR: RetentionCode")
                If MachineID.Length > 80 Then Console.WriteLine("ERROR: MachineID")
                If CRC.Length > 250 Then Console.WriteLine("ERROR: CRC")
                If HiveConnectionName.Length > 50 Then Console.WriteLine("ERROR: HiveConnectionName")
                If RepoSvrName.Length > 254 Then Console.WriteLine("ERROR: RepoSvrName")
                If ContainedWithin.Length > 50 Then Console.WriteLine("ERROR: ContainedWithin")
                If RecHash.Length > 250 Then Console.WriteLine("ERROR: RecHash")
                If RepoName.Length > 50 Then Console.WriteLine("ERROR: RepoName")
                If HashFile.Length > 150 Then Console.WriteLine("ERROR: HashFile")
                If HashName.Length > 50 Then Console.WriteLine("ERROR: HashName")
                'If OcrSuccessful.length > 1 Then CONSOLE.WRITELINE("ERROR: OcrSuccessful")
                'If OcrPending.length > 1 Then CONSOLE.WRITELINE("ERROR: OcrPending")
                'If PdfIsSearchable.length > 1 Then CONSOLE.WRITELINE("ERROR: PdfIsSearchable")
                'If PdfOcrRequired.length > 1 Then CONSOLE.WRITELINE("ERROR: PdfOcrRequired")
                'If PdfOcrSuccess.length > 1 Then CONSOLE.WRITELINE("ERROR: PdfOcrSuccess")
                'If PdfOcrTextExtracted.length > 1 Then CONSOLE.WRITELINE("ERROR: PdfOcrTextExtracted")
                If RssLinkGuid.Length > 50 Then Console.WriteLine("ERROR: RssLinkGuid")
                If PageURL.Length > 4000 Then Console.WriteLine("ERROR: PageURL")
                If URLHash.Length > 50 Then Console.WriteLine("ERROR: URLHash")
                If WebPagePublishDate.Length > 50 Then Console.WriteLine("ERROR: WebPagePublishDate")
                If Imagehash.Length > 250 Then Console.WriteLine("ERROR: Imagehash")
                If FileDirectoryName.Length > 1000 Then Console.WriteLine("ERROR: FileDirectoryName")
                If FqnHASH.Length > 150 Then Console.WriteLine("ERROR: FqnHASH")
                If SourceImageOrigin.Length > 10 Then Console.WriteLine("ERROR: SourceImageOrigin")
                Console.WriteLine(FQN)
            End If


            '*****  WDM Changed ZIP Ext and corrected the below 12/15/2020
            Dim fExt As String = DMA.getFileExtension(FQN)
            If IsZipFile.Equals("Y") Then
                Dim ZF As New clsZipFiles
                isPublic = "Y"
                Dim StackLevel As Integer = 0
                Dim ListOfFiles As New Dictionary(Of String, Integer)
                Dim BX As Boolean = ZF.UploadZipFile(gCurrUserGuidID, gMachineID, FQN, SourceGuid, True, False, RetentionCode, isPublic, StackLevel, ListOfFiles)
                ListOfFiles = Nothing
                ZF = Nothing
                GC.Collect()
                If BX Then
                    Return True
                Else
                    Return False
                End If
            End If

            Dim TSQL As String = "INSERT INTO DataSource ( 
                        BPS,
                        CompressedSize,
                        ContainedWithin,
                        CRC,
                        CreateDate,
                        CreationDate,
                        DataSourceOwnerUserID,
                        DataVerified,
                        Description,
                        FileAttached,
                        FileDirectory,
                        FileDirectoryName,
                        FileLength,
                        FQN,
                        FqnHASH,
                        GraphicContainsText,
                        HashFile,
                        HashName,
                        HiveActive,
                        HiveConnectionName,
                        Imagehash,
                        ImageHiddenText,
                        ImageLen,
                        isAvailable,
                        isContainedWithinZipFile,
                        isGraphic,
                        isMaster,
                        isPerm,
                        isPublic,
                        IsPublicPreviousState,
                        isWebPage,
                        IsZipFile,
                        KeyWords,
                        LastAccessDate,
                        LastWriteTime,
                        MachineID,
                        Notes,
                        OcrPending,
                        OcrPerformed,
                        OcrSuccessful,
                        OcrText,
                        OriginalFileType,
                        OriginalSize,
                        PageURL,
                        ParentGuid,
                        PdfImages,
                        PdfIsSearchable,
                        PdfOcrRequired,
                        PdfOcrSuccess,
                        PdfOcrTextExtracted,
                        PdfPages,
                        RecHash,
                        RecLen,
                        RecTimeStamp,
                        RepoName,
                        RepoSvrName,
                        RequireOcr,
                        RetentionCode,
                        RetentionDate,
                        RetentionExpirationDate,
                        RowCreationDate,
                        RowGuid,
                        RowLastModDate,
                        RssLinkFlg,
                        RssLinkGuid,
                        SapData,
                        SharePoint,
                        SharePointDoc,
                        SharePointList,
                        SharePointListItem,
                        SourceGuid,
                        SourceImage,
                        SourceImageOrigin,
                        SourceName,
                        SourceTypeCode,
                        StructuredData,
                        TransmitTime,
                        txEndTime,
                        txStartTime,
                        txTotalTime,
                        URLHash,
                        UserID,
                        VersionNbr,
                        WebPagePublishDate,
                        ZipFileFQN,
                        ZipFileGuid
                        ) 
                        VALUES (
                        @BPS,
                        @CompressedSize,
                        @ContainedWithin,
                        @CRC,
                        @CreateDate,
                        @CreationDate,
                        @DataSourceOwnerUserID,
                        @DataVerified,
                        @Description,
                        @FileAttached,
                        @FileDirectory,
                        @FileDirectoryName,
                        @FileLength,
                        @FQN,
                        @FqnHASH,
                        @GraphicContainsText,
                        @HashFile,
                        @HashName,
                        @HiveActive,
                        @HiveConnectionName,
                        @Imagehash,
                        @ImageHiddenText,
                        @ImageLen,
                        @isAvailable,
                        @isContainedWithinZipFile,
                        @isGraphic,
                        @isMaster,
                        @isPerm,
                        @isPublic,
                        @IsPublicPreviousState,
                        @isWebPage,
                        @IsZipFile,
                        @KeyWords,
                        @LastAccessDate,
                        @LastWriteTime,
                        @MachineID,
                        @Notes,
                        @OcrPending,
                        @OcrPerformed,
                        @OcrSuccessful,
                        @OcrText,
                        @OriginalFileType,
                        @OriginalSize,
                        @PageURL,
                        @ParentGuid,
                        @PdfImages,
                        @PdfIsSearchable,
                        @PdfOcrRequired,
                        @PdfOcrSuccess,
                        @PdfOcrTextExtracted,
                        @PdfPages,
                        @RecHash,
                        @RecLen,
                        @RecTimeStamp,
                        @RepoName,
                        @RepoSvrName,
                        @RequireOcr,
                        @RetentionCode,
                        @RetentionDate,
                        @RetentionExpirationDate,
                        @RowCreationDate,
                        @RowGuid,
                        @RowLastModDate,
                        @RssLinkFlg,
                        @RssLinkGuid,
                        @SapData,
                        @SharePoint,
                        @SharePointDoc,
                        @SharePointList,
                        @SharePointListItem,
                        @SourceGuid,
                        @SourceImage,
                        @SourceImageOrigin,
                        @SourceName,
                        @SourceTypeCode,
                        @StructuredData,
                        @TransmitTime,
                        @txEndTime,
                        @txStartTime,
                        @txTotalTime,
                        @URLHash,
                        @UserID,
                        @VersionNbr,
                        @WebPagePublishDate,
                        @ZipFileFQN,
                        @ZipFileGuid
                        )"

            Try
                txEndTime = Now
                CloseConn()
                CkConn()

                Using connection As New SqlConnection(getRepoConnStr())
                    Using command As New SqlCommand(TSQL, connection)
                        command.CommandType = CommandType.Text
                        '**************************************************************************
                        command.Parameters.AddWithValue("@BPS", BPS)
                        command.Parameters.AddWithValue("@CompressedSize", CompressedSize)
                        command.Parameters.AddWithValue("@ContainedWithin", ContainedWithin)
                        command.Parameters.AddWithValue("@CRC", CRC)
                        command.Parameters.AddWithValue("@CreateDate", CreateDate)
                        command.Parameters.AddWithValue("@CreationDate", CreationDate)
                        command.Parameters.AddWithValue("@DataSourceOwnerUserID", DataSourceOwnerUserID)
                        command.Parameters.AddWithValue("@DataVerified", DataVerified)
                        command.Parameters.AddWithValue("@Description", Description)
                        command.Parameters.AddWithValue("@FileAttached", FileAttached)
                        command.Parameters.AddWithValue("@FileDirectory", FileDirectory)
                        command.Parameters.AddWithValue("@FileDirectoryName", FileDirectoryName)
                        command.Parameters.AddWithValue("@FileLength", FI.Length)
                        command.Parameters.AddWithValue("@FQN", FQN)
                        command.Parameters.AddWithValue("@FqnHASH", FqnHASH)
                        command.Parameters.AddWithValue("@GraphicContainsText", GraphicContainsText)
                        command.Parameters.AddWithValue("@HashFile", HashFile)
                        command.Parameters.AddWithValue("@HashName", HashName)
                        command.Parameters.AddWithValue("@HiveActive", HiveActive)
                        command.Parameters.AddWithValue("@HiveConnectionName", HiveConnectionName)
                        command.Parameters.AddWithValue("@Imagehash", Imagehash)
                        command.Parameters.AddWithValue("@ImageHiddenText", ImageHiddenText)
                        command.Parameters.AddWithValue("@ImageLen", FI.Length)
                        command.Parameters.AddWithValue("@isAvailable", isAvailable)
                        command.Parameters.AddWithValue("@isContainedWithinZipFile", isContainedWithinZipFile)
                        command.Parameters.AddWithValue("@isGraphic", isGraphic)
                        command.Parameters.AddWithValue("@isMaster", isMaster)
                        command.Parameters.AddWithValue("@isPerm", isPerm)
                        command.Parameters.AddWithValue("@isPublic", isPublic)
                        command.Parameters.AddWithValue("@IsPublicPreviousState", IsPublicPreviousState)
                        command.Parameters.AddWithValue("@isWebPage", isWebPage)
                        command.Parameters.AddWithValue("@IsZipFile", IsZipFile)
                        command.Parameters.AddWithValue("@KeyWords", KeyWords)
                        command.Parameters.AddWithValue("@LastAccessDate", LastAccessDate)
                        command.Parameters.AddWithValue("@LastWriteTime", LastWriteTime)
                        command.Parameters.AddWithValue("@MachineID", MachineID)
                        command.Parameters.AddWithValue("@Notes", Notes)
                        command.Parameters.AddWithValue("@OcrPending", OcrPending)
                        command.Parameters.AddWithValue("@OcrPerformed", OcrPerformed)
                        command.Parameters.AddWithValue("@OcrSuccessful", OcrSuccessful)
                        command.Parameters.AddWithValue("@OcrText", OcrText)
                        command.Parameters.AddWithValue("@OriginalFileType", OriginalFileType)
                        command.Parameters.AddWithValue("@OriginalSize", FI.Length)
                        command.Parameters.AddWithValue("@PageURL", PageURL)
                        command.Parameters.AddWithValue("@ParentGuid", ParentGuid)
                        command.Parameters.AddWithValue("@PdfImages", PdfImages)
                        command.Parameters.AddWithValue("@PdfIsSearchable", PdfIsSearchable)
                        command.Parameters.AddWithValue("@PdfOcrRequired", PdfOcrRequired)
                        command.Parameters.AddWithValue("@PdfOcrSuccess", PdfOcrSuccess)
                        command.Parameters.AddWithValue("@PdfOcrTextExtracted", PdfOcrTextExtracted)
                        command.Parameters.AddWithValue("@PdfPages", PdfPages)
                        command.Parameters.AddWithValue("@RecHash", RecHash)
                        command.Parameters.AddWithValue("@RecLen", RecLen)
                        command.Parameters.AddWithValue("@RecTimeStamp", RecTimeStamp)
                        command.Parameters.AddWithValue("@RepoName", RepoName)
                        command.Parameters.AddWithValue("@RepoSvrName", RepoSvrName)
                        command.Parameters.AddWithValue("@RequireOcr", RequireOcr)
                        command.Parameters.AddWithValue("@RetentionCode", RetentionCode)
                        command.Parameters.AddWithValue("@RetentionDate", RetentionDate)
                        command.Parameters.AddWithValue("@RetentionExpirationDate", RetentionExpirationDate)
                        command.Parameters.AddWithValue("@RowCreationDate", RowCreationDate)
                        command.Parameters.AddWithValue("@RowGuid", RowGuid)
                        'command.Parameters.AddWithValue("@RowGuid2", Guid.NewGuid.ToString)
                        'command.Parameters.AddWithValue("@RowID", RowID)
                        command.Parameters.AddWithValue("@RowLastModDate", RowLastModDate)
                        command.Parameters.AddWithValue("@RssLinkFlg", RssLinkFlg)
                        command.Parameters.AddWithValue("@RssLinkGuid", RssLinkGuid)
                        command.Parameters.AddWithValue("@SapData", SapData)
                        command.Parameters.AddWithValue("@SharePoint", SharePoint)
                        command.Parameters.AddWithValue("@SharePointDoc", SharePointDoc)
                        command.Parameters.AddWithValue("@SharePointList", SharePointList)
                        command.Parameters.AddWithValue("@SharePointListItem", SharePointListItem)
                        command.Parameters.AddWithValue("@SourceGuid", SourceGuid)
                        command.Parameters.AddWithValue("@SourceImage", SourceImage)
                        command.Parameters.AddWithValue("@SourceImageOrigin", SourceImageOrigin)
                        command.Parameters.AddWithValue("@SourceName", SourceName)
                        command.Parameters.AddWithValue("@SourceTypeCode", SourceTypeCode)
                        command.Parameters.AddWithValue("@StructuredData", StructuredData)
                        command.Parameters.AddWithValue("@TransmitTime", TransmitTime)
                        command.Parameters.AddWithValue("@txEndTime", txEndTime)
                        command.Parameters.AddWithValue("@txStartTime", txStartTime)
                        command.Parameters.AddWithValue("@txTotalTime", txTotalTime)
                        command.Parameters.AddWithValue("@URLHash", URLHash)
                        command.Parameters.AddWithValue("@UserID", gCurrLoginID)
                        command.Parameters.AddWithValue("@VersionNbr", VersionNbr)
                        command.Parameters.AddWithValue("@WebPagePublishDate", WebPagePublishDate)
                        command.Parameters.AddWithValue("@ZipFileFQN", ZipFileFQN)
                        command.Parameters.AddWithValue("@ZipFileGuid", ZipFileGuid)
                        '**************************************************************************
                        connection.Open()
                        command.ExecuteNonQuery()
                    End Using
                End Using
                Try
                    Dim B1 As Boolean = ApplySourceTypeCode(Environment.MachineName, UserID, FI.Name, FI.Extension, SourceGuid)
                Catch ex As Exception
                    LOG.WriteToArchiveLog("clsDatabaseARCH : InsertNewContent failed to insert ProcessAS : 300 : " + ex.Message)
                    LOG.WriteToFailedLoadLog("clsDatabaseARCH : InsertNewContent : 300 Failed To insert ProcessAS : " + Environment.NewLine + FQN + Environment.NewLine + ex.Message)
                    SourceGuid = ""
                End Try

            Catch ex As Exception
                SourceGuid = ""
                B = False
                LOG.WriteToArchiveLog("clsDatabaseARCH : InsertNewContent : 100 : ", ex)
                LOG.WriteToFailedLoadLog("clsDatabaseARCH : InsertNewContent : 100 Failed To Load : " + Environment.NewLine + FQN + Environment.NewLine + ex.Message)
            End Try
        Catch ex As Exception
            SourceGuid = ""
            LOG.WriteToArchiveLog("clsDatabaseARCH : InsertNewContent : 00 : ", ex)
            LOG.WriteToFailedLoadLog("clsDatabaseARCH : InsertNewContent : 00 Failed To Load : " + Environment.NewLine + FQN + Environment.NewLine + ex.Message)
        End Try



        Return SourceGuid
    End Function

    ''' <summary>
    ''' Updates the single file.
    ''' </summary>
    ''' <param name="SourceGuid">The source unique identifier.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function updateSingleFILE(SourceGuid As String, FQN As String) As Boolean

        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim FI As New FileInfo(FQN)

        If FI.Length.Equals(0) Then
            LOG.WriteToArchiveLog("clsDatabaseARCH : updateSingelFile : 90 : " + FQN + " appears to have ZERO content.")
            LOG.WriteToFailedLoadLog("clsDatabaseARCH : updateSingelFile : 90 " + FQN + " appears to have ZERO content.")
            Return False
        End If

        Dim versionNumber As String = Application.ProductVersion.ToString
        Dim B As Boolean = True

        Dim bSuccess As Boolean = True

        Dim FileLength As Integer = 0
        Dim LastAccessDate As DateTime = FI.LastAccessTime
        Dim LastWriteTime As DateTime = FI.LastWriteTime
        Dim MachineID As String = Environment.MachineName
        Dim OcrPending As Char = ""
        Dim RecTimeStamp As DateTime = Now
        Dim RetentionDate As DateTime = Now
        Dim RowLastModDate As DateTime = Now
        Dim txEndTime As DateTime = Now
        Dim txStartTime As DateTime = Now
        Dim Successful As Boolean = True

        If FI.Extension.ToLower.Equals(".zip") Then
            ZipFileGuid = Guid.NewGuid.ToString
            ZipFileFQN = FI.FullName
            IsZipFile = "Y"
        Else
            ZipFileGuid = ""
            ZipFileFQN = ""
            IsZipFile = "N"
        End If

        Dim crchash As String = ENC.GenerateSHA512HashFromFile(FI.FullName)
        CRC = crchash
        Imagehash = crchash

        HashName = "SHA512"

        RetentionCode = getRetentionCode(gCurrLoginID, FI.DirectoryName)
        Dim RetentionYears As Integer = getRetentionPeriod(RetentionCode)
        Dim RequireOcr As String = ""
        Dim rightNow As Date = Now
        If RetentionYears = 0 Then
            RetentionYears = Val(getSystemParm("RETENTION YEARS"))
        End If
        rightNow = rightNow.AddYears(RetentionYears)
        Dim RetentionExpirationDate As String = rightNow.ToString

        If Convert.ToDateTime(RetentionDate) <= Now Then
            Dim NewDate As DateTime = DateAdd("yyyy", 10, Now)
            RetentionDate = NewDate.ToString
        End If

        Dim SourceImage As Byte() = IO.File.ReadAllBytes(FI.FullName)

        Dim GraphicTypes As List(Of String) = getListOf("select lower(GraphicFileTypeExt) from GraphicFileType")
        If GraphicTypes.Contains(FI.Extension.ToLower) Then
            OcrPending = "Y"
            OcrPerformed = "N"
            RequireOcr = "Y"
        Else
            OcrPending = "N"
            OcrPerformed = "N"
            RequireOcr = "N"
        End If


        Dim TSQL As String = "UPDATE DataSource set 
                        CRC = @CRC,
                        FileLength = @FileLength,
                        Imagehash = @Imagehash,
                        ImageLen = @ImageLen,
                        LastAccessDate = @LastAccessDate,
                        LastWriteTime = @LastWriteTime,
                        OcrPending = @OcrPending,
                        OcrPerformed = @OcrPerformed,
                        RecHash = @RecHash,
                        RecLen = @RecLen,
                        RecTimeStamp = @RecTimeStamp,
                        RequireOcr = @RequireOcr,
                        RetentionCode = @RetentionCode,
                        RetentionDate = @RetentionDate,
                        RetentionExpirationDate = @RetentionExpirationDate,
                        RowLastModDate = @RowLastModDate,
                        SourceImage = @SourceImage,
                        SourceTypeCode = @SourceTypeCode,
                        txEndTime = @txEndTime,
                        txStartTime = @txStartTime,
                        UserID = @UserID
                        Where SourceGuid = @SourceGuid"

        Try
            txEndTime = Now
            CloseConn()
            CkConn()

            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand(TSQL, connection)
                    command.CommandType = CommandType.Text
                    '**************************************************************************
                    command.Parameters.AddWithValue("@CRC", CRC)
                    command.Parameters.AddWithValue("@FileLength", FI.Length)
                    command.Parameters.AddWithValue("@Imagehash", Imagehash)
                    command.Parameters.AddWithValue("@ImageLen", FI.Length)
                    command.Parameters.AddWithValue("@LastAccessDate", LastAccessDate)
                    command.Parameters.AddWithValue("@LastWriteTime", LastWriteTime)
                    command.Parameters.AddWithValue("@OcrPending", OcrPending)
                    command.Parameters.AddWithValue("@OcrPerformed", OcrPerformed)
                    command.Parameters.AddWithValue("@RecHash", CRC)
                    command.Parameters.AddWithValue("@RecLen", FI.Length)
                    command.Parameters.AddWithValue("@RecTimeStamp", RecTimeStamp)
                    command.Parameters.AddWithValue("@RequireOcr", RequireOcr)
                    command.Parameters.AddWithValue("@RetentionCode", RetentionCode)
                    command.Parameters.AddWithValue("@RetentionDate", RetentionDate)
                    command.Parameters.AddWithValue("@RetentionExpirationDate", RetentionExpirationDate)
                    command.Parameters.AddWithValue("@RowLastModDate", RowLastModDate)
                    command.Parameters.AddWithValue("@SourceImage", SourceImage)
                    command.Parameters.AddWithValue("@txEndTime", txEndTime)
                    command.Parameters.AddWithValue("@txStartTime", txStartTime)
                    command.Parameters.AddWithValue("@UserID", gCurrLoginID)
                    '**************************************************************************
                    connection.Open()
                    command.ExecuteNonQuery()
                End Using
            End Using
            Try
                Dim B1 As Boolean = ApplySourceTypeCode(Environment.MachineName, gCurrLoginID, FI.Name, FI.Extension, SourceGuid)
            Catch ex As Exception
                LOG.WriteToArchiveLog("clsDatabaseARCH : updateSingelFile failed to insert ProcessAS : 300 : " + ex.Message)
                LOG.WriteToFailedLoadLog("clsDatabaseARCH : updateSingelFile : 300 Failed To insert ProcessAS : " + Environment.NewLine + FQN + Environment.NewLine + ex.Message)
            End Try

        Catch ex As Exception
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : updateSingelFile : 100 : ", ex)
            LOG.WriteToFailedLoadLog("clsDatabaseARCH : updateSingelFile : 100 Failed To Load : " + Environment.NewLine + FQN + Environment.NewLine + ex.Message)
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Updates the content of the existing.
    ''' </summary>
    ''' <param name="tDict">The t dictionary.</param>
    ''' <param name="RowID">The row identifier.</param>
    ''' <param name="SourceImage">The source image.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function updateExistingContent(tDict As Dictionary(Of String, String), RowID As String, SourceImage As Byte()) As Boolean
        If gTraceFunctionCalls.Equals(1) Then
            LOG.WriteToArchiveLog("--> CALL: " + System.Reflection.MethodInfo.GetCurrentMethod().ToString)
        End If

        Dim ImageHash As String = tDict("ImageHash")
        Dim LastAccessDate As String = tDict("LastAccessDate")
        Dim FileLength As String = tDict("FileLength")
        Dim LastWriteTime As String = tDict("LastWriteTime")
        Dim UserID As String = tDict("UserID")
        Dim OcrPerformed As String = tDict("OcrPerformed")
        Dim isGraphic As String = tDict("isGraphic")
        Dim MachineID As String = tDict("MachineID")
        Dim CRC As String = tDict("CRC")
        Dim RowLastModDate As String = tDict("RowLastModDate")
        Dim HashFile As String = tDict("HashFile")
        Dim OcrPending As String = tDict("OcrPending")
        Dim HashName As String = tDict("HashName")

        Dim B As Boolean = True
        Dim TSQL As String = "UPDATE DataSource SET  
                        SourceImage = @SourceImage,
                        LastAccessDate = @LastAccessDate,
                        FileLength = @FileLength,
                        LastWriteTime = @LastWriteTime,
                        UserID = @UserID,
                        OcrPerformed = @OcrPerformed,
                        isGraphic = @isGraphic,
                        MachineID = @MachineID,
                        CRC = @CRC,
                        ImageHash = @ImageHash,
                        RowLastModDate = @RowLastModDate,
                        HashFile = @HashFile,
                        HashName = @HashName,
                        OcrPending = @OcrPending
                    Where RowID = " + RowID

        Try
            CloseConn()
            CkConn()

            Using connection As New SqlConnection(getRepoConnStr())
                Using command As New SqlCommand(TSQL, connection)
                    command.CommandType = CommandType.Text
                    '**************************************************************************
                    command.Parameters.AddWithValue("@SourceImage", SourceImage)
                    command.Parameters.AddWithValue("@LastAccessDate", LastAccessDate)
                    command.Parameters.AddWithValue("@FileLength", FileLength)
                    command.Parameters.AddWithValue("@LastWriteTime", LastWriteTime)
                    command.Parameters.AddWithValue("@UserID", UserID)
                    command.Parameters.AddWithValue("@OcrPerformed", OcrPerformed)
                    command.Parameters.AddWithValue("@isGraphic", isGraphic)
                    command.Parameters.AddWithValue("@MachineID", MachineID)
                    command.Parameters.AddWithValue("@CRC", CRC)
                    command.Parameters.AddWithValue("@ImageHash", ImageHash)
                    command.Parameters.AddWithValue("@RowLastModDate", RowLastModDate)
                    command.Parameters.AddWithValue("@HashFile", HashFile)
                    command.Parameters.AddWithValue("@HashName", HashName)
                    command.Parameters.AddWithValue("@OcrPending", OcrPending)
                    'command.Parameters.AddWithValue("@RowID", RowID)
                    '**************************************************************************
                    connection.Open()
                    command.ExecuteNonQuery()
                    connection.Close()
                    connection.Dispose()
                    command.Dispose()
                    B = True
                End Using
            End Using
            B = True
        Catch ex As Exception
            'Session("ErrorLocation") tbl= 'Session("ErrorLocation") + " : " , ex
            Console.WriteLine(ex.Message)
            ' xTrace(3084, "insertSingleFILE", "Failed: " + ex.ToString)
            B = False
            LOG.WriteToArchiveLog("clsDatabaseARCH : SP_ApplyUpdate : 100 : ", ex)
        End Try

        Return B
    End Function


    ''' <summary>
    ''' Gets the count.
    ''' </summary>
    ''' <param name="MySql">My SQL.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getCount(MySql As String) As Integer
        Dim CNT As Integer = 0
        Try

            CloseConn()
            CkConn()
            Dim rsData As SqlDataReader = Nothing
            Dim b As Boolean = False
            Dim CS As String = getRepoConnStr()
            Dim CONN As New SqlConnection(CS)
            CONN.Open()
            Dim command As New SqlCommand(MySql, CONN)

            rsData = command.ExecuteReader()
            rsData.Read()
            CNT = rsData.GetInt32(0)
            rsData.Close()
        Catch ex As Exception
            LOG.WriteToArchiveLog("clsDatabaseARCH : getCount : 1299A : ", ex)
        End Try

        Return CNT
    End Function

    ''' <summary>
    ''' Cleanups the name of the source.
    ''' </summary>
    ''' <param name="MachineName">Name of the machine.</param>
    Sub CleanupSourceName(MachineName As String)

        Dim UserID As String = ""
        Dim SourceName As String = ""
        Dim FileExt As String = ""
        Dim SourceGuid As String = ""
        Dim FQN As String = ""
        Dim OriginalFileType As String = ""
        Dim B As Boolean = True
        Dim I As Integer = 0

        frmNotify.Show()
        frmNotify.Text = "Validate SourceName"

        Dim S As String = "delete From DataSource Where LTrim(RTrim(FQN)) = '' "

        S = "Select count(*) from DataSource " + Environment.NewLine
        S += "where(LTrim(RTrim(UserID)) = '' "
        S += " Or LTRIM(RTRIM(SOurceName)) = '' or LTRIM(RTRIM(OriginalFileType)) = ''  "
        S += " Or LTRIM(RTRIM(SourceTypeCode)) = '' or LTRIM(RTRIM(MachineID)) = '' or MachineID is null ) " + Environment.NewLine
        S += "And LTrim(RTrim(FQN)) <> ''   " + Environment.NewLine

        Dim iCnt As Integer = getCount(S)

        If iCnt.Equals(0) Then
            MessageBox.Show("DONE - No files found to process")
            Return
        End If

        S = "Select FQN, UserID, SourceName, OriginalFileType, SourceGuid from DataSource " + Environment.NewLine
        S += "where(LTrim(RTrim(UserID)) = '' "
        S += " Or LTRIM(RTRIM(SOurceName)) = '' or LTRIM(RTRIM(OriginalFileType)) = ''  "
        S += " Or LTRIM(RTRIM(SourceTypeCode)) = '' or LTRIM(RTRIM(MachineID)) = '' or MachineID is null ) " + Environment.NewLine
        S += "And LTrim(RTrim(FQN)) <> '' order by FQN  " + Environment.NewLine

        Dim RSData As SqlDataReader = Nothing
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()

        Using CONN
            CONN.Open()
            Dim command As New SqlCommand(S, CONN)
            Using command
                RSData = command.ExecuteReader()
                Using RSData
                    If RSData.HasRows Then
                        Do While RSData.Read()
                            Application.DoEvents()
                            I += 1
                            FQN = RSData.GetValue(0).ToString.Trim
                            UserID = RSData.GetValue(1).ToString.Trim
                            SourceName = RSData.GetValue(2).ToString.Trim
                            OriginalFileType = RSData.GetValue(3).ToString.ToUpper.Trim
                            SourceGuid = RSData.GetValue(4).ToString.ToUpper.Trim
                            FileExt = Path.GetExtension(FQN).ToUpper

                            frmNotify.lblFileSpec.Text = FQN
                            frmNotify.lblPdgPages.Text = "# " + I.ToString

                            If UserID.Length.Equals(0) Then
                                UserID = gCurrLoginID
                            End If
                            If SourceName.Length.Equals(0) Then
                                SourceName = Path.GetFileName(FQN)
                            End If
                            If Not OriginalFileType.Length.Equals(0) Then
                                OriginalFileType = FileExt
                            ElseIf Not OriginalFileType.Equals(FileExt) Then
                                FileExt = FileExt
                            End If

                            Application.DoEvents()
                            B = ApplySourceTypeCode(MachineName, UserID, SourceName, FileExt, SourceGuid)

                        Loop
                    Else
                        id = -1
                    End If
                End Using
            End Using
        End Using

        RSData.Close()
        RSData = Nothing

        frmNotify.Close()
        MessageBox.Show("Validation Complete...")

    End Sub

    ''' <summary>
    ''' Inserts the binary data.
    ''' </summary>
    ''' <param name="RepositoryTable">The repository table.</param>
    ''' <param name="FQN">The FQN.</param>
    ''' <param name="FileHash">The file hash.</param>
    ''' <param name="TgtGuid">The TGT unique identifier.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function InsertBinaryData(RepositoryTable As String, FQN As String, FileHash As String, TgtGuid As String) As Boolean

        If FileHash.Length < 10 Then
            LOG.WriteToArchiveLog("ERROR InsertBinaryData File hash missing: " + FQN)
            Return False
        End If

        Dim B As Boolean = True
        Dim LL As Integer = 0

        Try
            RepositoryTable = RepositoryTable.ToUpper
            LL = 10

            Select Case (RepositoryTable.ToUpper)
                Case "EMAIL"
                    S = "Update EMAIL set FileAttached = 0, CRC = '" + FileHash + "' where EmailGuid = '" + TgtGuid + "'"
                Case "EMAILATTACHMENT"
                    S = "Update EmailAttachment set FileAttached = 0, CRC = '" + FileHash + "'  where RowGuid = '" + TgtGuid + "'"
                Case "DATASOURCE"
                    S = "Update DataSource set FileAttached = 0, CRC = '" + FileHash + "' where SourceGuid = '" + TgtGuid + "'"
                Case Else
                    S = "ERROR: 10029 - RepositoryTable not correctly set."
            End Select

            LL = 20
            Dim CS As String = setConnStr()
            LL = 30
            B = ExecuteSql(S, CS, False) : LL = 4
            LL = 40

            Dim FileBinaryData As Byte() = File.ReadAllBytes(FQN)
            Dim FileLength As Integer = FileBinaryData.Length
            Dim SuccessfulUpload As Boolean = True
            Dim ConnStr As String = setConnStr()
            Dim CONN As New SqlConnection(ConnStr)

            If CONN.State = ConnectionState.Closed Then
                CONN.Open()
            End If
            LL = 50

            Dim CMD As New SqlCommand()
            Try
                If RepositoryTable.Equals("DATASOURCE") Then
                    LL = 55
                    Dim FI As New FileInfo(FQN)
                    Dim LastAccessDate As Date = FI.LastAccessTime
                    Dim LastWriteTime As Date = FI.LastWriteTime
                    FI = Nothing
                    CMD.Connection = CONN
                    CMD.CommandText = "[UpdateDataSourceImage]"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@SourceGuid", TgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@SourceImage", FileBinaryData))
                            CMD.Parameters.Add(New SqlParameter("@LastAccessDate", LastAccessDate))
                            CMD.Parameters.Add(New SqlParameter("@LastWriteTime", LastWriteTime))
                            CMD.Parameters.Add(New SqlParameter("@VersionNbr", 1))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
                LL = 60
                If RepositoryTable.Equals("EMAIL") Then
                    LL = 70
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailFilestream"
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@EmailGuid", TgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@EmailImage", FileBinaryData))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
                LL = 80
                If RepositoryTable.Equals("EMAILATTACHMENT") Then
                    LL = 90
                    'Dim TSql As String = "Update [EmailAttachment] set Attachment = @Attachment Where RowGuid = @RowGuid"
                    CMD.Connection = CONN
                    CMD.CommandText = "UpdateEmailAttachmentFilestreamV2"
                    'CMD.CommandText = TSql
                    CMD.CommandType = CommandType.StoredProcedure
                    Using CONN
                        Using CMD
                            CMD.Parameters.Add(New SqlParameter("@RowGuid", TgtGuid))
                            CMD.Parameters.Add(New SqlParameter("@Attachment", FileBinaryData))
                            CMD.Parameters.Add(New SqlParameter("@LastAccessDate", Now))
                            'CMD.Parameters.Add(New SqlParameter("@AttachmentName", OriginalFileName))
                            CMD.ExecuteNonQuery()
                        End Using
                    End Using
                End If
                LL = 100
            Catch ex As Exception
                SuccessfulUpload = False
                LOG.WriteToArchiveLog("ERROR: X01 InsertBinaryData: " + ex.Message)
                LOG.WriteToArchiveLog("ERROR: LL=" + LL.ToString)
                LOG.WriteToArchiveLog("ERROR: Binary Data Length: " + FileBinaryData.LongLength.ToString)
                LOG.WriteToArchiveLog("ERROR: TgtGuid Length: " + TgtGuid.ToString)
            Finally
                oFile = Nothing
                FileBinaryData = Nothing
                CMD.Dispose()
                If CONN.State = ConnectionState.Open Then
                    CONN.Close()
                End If
                CONN.Dispose()

                If RepositoryTable.Equals("EMAIL") Then
                    S = "Update EMAIL set FileAttached = 1 where EmailGuid = '" + TgtGuid + "'"
                ElseIf RepositoryTable.Equals("EMAILATTACHMENT") Then
                    S = "Update EmailAttachment set FileAttached = 1 where EmailGuid = '" + TgtGuid + "'"
                ElseIf RepositoryTable.Equals("DATASOURCE") Then
                    S = "Update DataSource set FileAttached = 1 where SourceGuid = '" + TgtGuid + "'"
                End If

                LL = 120
                Try
                    B = ExecuteSql(S, CS, False)

                    LL = 130
                    B = UpdateDataSourceFileInfo(FQN, TgtGuid, FileLength, FileHash)
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR 22 InsertBinaryData: LL=" + LL.ToString + Environment.NewLine + ex.Message)
                End Try


            End Try
        Catch ex As Exception
            B = False
            LOG.WriteToArchiveLog("ERROR 00 InsertBinaryData: LL=" + LL.ToString + Environment.NewLine + ex.Message)
        End Try


        Return B

    End Function

    ''' <summary>
    ''' Sps the update retention.
    ''' </summary>
    Public Sub spUpdateRetention()

        Dim s As String = "UPDATE DataSource 
                SET RetentionExpirationDate = DATEADD(year, R.RetentionUnits, DS.LastWriteTime) 
                From dbo.DataSource AS DS
                INNER JOIN dbo.Directory AS DIR
                On DS.FileDirectory Like '%' + DIR.FQN + '%'
                inner join [Retention] R
                On R.RetentionCode = DIR.RetentionCode
        WHERE DS.RetentionExpirationDate < '01-01-1971' or DS.RetentionExpirationDate is null"

        Dim CS As String = setConnStr()

        ExecuteSql(s, CS, False)

    End Sub

    ''' <summary>
    ''' Inserts the database update.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Function insertDBUpdate(FQN As String) As Boolean

        FQN = FQN.Replace("'", "''")
        Dim B As Boolean = True

        Dim iExists As Integer = getDBUpdateExists(FQN)

        If iExists > 0 Then
            Return True
        End If
        Dim MySql = "insert into [DBUpdate] (FileName) values ('" + FQN + "')"

        Dim CMD As New SqlCommand
        Dim connString As String = getRepoConnStr()
        Dim conn As New SqlConnection(connString)

        If conn Is Nothing Then
            conn = New SqlConnection(getRepoConnStr())
        End If
        If conn.State = ConnectionState.Closed Then
            conn.ConnectionString = getRepoConnStr()
            conn.Open()
        End If

        CMD.Connection = conn
        CMD.CommandText = MySql
        CMD.CommandType = CommandType.Text
        Using conn
            Using CMD
                Try
                    CMD.ExecuteNonQuery()
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR 22x1: insertDBUpdate: " + ex.Message + Environment.NewLine + MySql)
                    B = False
                End Try
            End Using
        End Using
        Return B
    End Function

    ''' <summary>
    ''' Updates the database update lastwrite.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function updateDBUpdateLastwrite(FQN As String) As Boolean

        FQN = FQN.Replace("'", "''")
        Dim B As Boolean = True

        Dim iExists As Integer = getDBUpdateExists(FQN)

        If iExists.Equals(0) Then
            Return False
        End If

        Dim FI As New FileInfo(FQN)
        Dim DateApplied As String = FI.LastWriteTime.ToString
        FI = Nothing

        Dim MySql = "update [DBUpdate] set DateApplied = '" + DateApplied + "' where FileName = '" + FQN + "';"

        Dim CMD As New SqlCommand
        Dim connString As String = getRepoConnStr()
        Dim conn As New SqlConnection(connString)

        If conn Is Nothing Then
            conn = New SqlConnection(getRepoConnStr())
        End If
        If conn.State = ConnectionState.Closed Then
            conn.ConnectionString = getRepoConnStr()
            conn.Open()
        End If

        CMD.Connection = conn
        CMD.CommandText = MySql
        CMD.CommandType = CommandType.Text
        Using conn
            Using CMD
                Try
                    CMD.ExecuteNonQuery()
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR 22x: updateDBUpdateLastwrite: " + ex.Message + Environment.NewLine + MySql)
                    B = False
                End Try
            End Using
        End Using
        Return B
    End Function

    ''' <summary>
    ''' Zeroizes the database update.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ZeroizeDBUpdate() As Boolean

        Dim B As Boolean = True
        Dim MySql = "delete from [DBUpdate]"
        Dim CMD As New SqlCommand
        Dim connString As String = getRepoConnStr()
        Dim conn As New SqlConnection(connString)

        If conn Is Nothing Then
            conn = New SqlConnection(getRepoConnStr())
        End If
        If conn.State = ConnectionState.Closed Then
            conn.ConnectionString = getRepoConnStr()
            conn.Open()
        End If

        CMD.Connection = conn
        CMD.CommandText = MySql
        CMD.CommandType = CommandType.Text
        Using conn
            Using CMD
                Try
                    CMD.ExecuteNonQuery()
                Catch ex As Exception
                    LOG.WriteToArchiveLog("ERROR 22x: ReapplyDBUpdate: " + ex.Message + Environment.NewLine + MySql)
                    B = False
                End Try
            End Using
        End Using
        Return B
    End Function

    ''' <summary>
    ''' Synchronizes the selected directories.
    ''' </summary>
    ''' <param name="ListOfDirToKeep">The list of dir to keep.</param>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function SyncSelectedDirectories(ListOfDirToKeep As String) As Boolean

        Dim B As Boolean = True
        Dim LL As Integer = 0
        Dim AffectedRecs As Integer = 0
        Dim connString As String = getRepoConnStr()
        Try
            LL = 10
            Dim MySql = "Delete from IncludedFiles where FQN not in " + ListOfDirToKeep + " and UserID = '" + gCurrLoginID + "'"

            LL = 20
            Dim CMD As New SqlCommand

            Using CMD
                Dim conn As New SqlConnection(connString)
                CMD.Connection = conn
                CMD.CommandText = MySql
                CMD.CommandType = CommandType.Text : LL = 30
                If conn.State = ConnectionState.Closed Then
                    conn.ConnectionString = getRepoConnStr() : LL = 40
                    conn.Open() : LL = 50
                End If
                Using conn
                    LL = 50
                    AffectedRecs = CMD.ExecuteNonQuery()
                    If AffectedRecs > 0 Then
                        LOG.WriteToArchiveLog("NOTICE SyncSelectedDirectories 001: Removed " + AffectedRecs.ToString + " unreferenced directories from the repository.")
                    End If
                End Using
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 01A ckUpdateTbl: LL=" + LL.ToString + Environment.NewLine + connString + Environment.NewLine + ex.Message)
            B = False
        End Try

        Return B

    End Function

    ''' <summary>
    ''' Cks the update table.
    ''' </summary>
    ''' <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
    Public Function ckUpdateTbl() As Boolean

        Dim B As Boolean = True
        Dim LL As Integer = 0
        Dim connString As String = getRepoConnStr()
        Try
            LL = 10
            Dim MySql = "IF NOT EXISTS
                        (
                            SELECT 1
                            FROM sys.tables
                            WHERE name = 'DBUpdate'
                        )
                            BEGIN
                                CREATE TABLE [dbo].[DBUpdate]
                                    ([FileName]      [NVARCHAR](100) NOT NULL, 
                                     [DateApplied]   [DATETIME] NOT NULL, 
                                     [RowCreateDate] [DATETIME] NOT NULL, 
                                     [UpdateApplied] [INT] NULL
                                    );
                                ALTER TABLE [dbo].[DBUpdate]
                                ADD DEFAULT(GETDATE()) FOR [DateApplied];
                                ALTER TABLE [dbo].[DBUpdate]
                                ADD DEFAULT(GETDATE()) FOR [RowCreateDate];
                                ALTER TABLE [dbo].[DBUpdate]
                                ADD DEFAULT((0)) FOR [UpdateApplied];
                                CREATE UNIQUE CLUSTERED INDEX [PC_DBUpdate] ON [dbo].[DBUpdate]([FileName] ASC);
                        END;"
            LL = 20
            Dim CMD As New SqlCommand

            LL = 30
            Dim conn As New SqlConnection(connString)
            LL = 40
            If conn Is Nothing Then
                LL = 50
                conn = New SqlConnection(getRepoConnStr())
            End If
            LL = 60
            If conn.State = ConnectionState.Closed Then
                LL = 70
                conn.ConnectionString = getRepoConnStr()
                LL = 80
                conn.Open()
            End If
            LL = 90
            CMD.Connection = conn
            LL = 100
            CMD.CommandText = MySql
            LL = 110
            CMD.CommandType = CommandType.Text
            LL = 130
            Using conn
                LL = 140
                Using CMD
                    LL = 150
                    Try
                        LL = 160
                        CMD.ExecuteNonQuery()
                        LL = 170
                    Catch ex As Exception
                        LOG.WriteToArchiveLog("ERROR 22x: updateDBUpdateLastwrite: " + ex.Message + Environment.NewLine + MySql)
                        B = False
                    End Try
                    LL = 180
                End Using
                LL = 190
            End Using
            LL = 200
        Catch ex As Exception
            LOG.WriteToArchiveLog("ERROR 01A ckUpdateTbl: LL=" + LL.ToString + Environment.NewLine + connString + Environment.NewLine + ex.Message)
            B = False
        End Try

        Return B
    End Function

    ''' <summary>
    ''' Gets the used extension.
    ''' </summary>
    ''' <returns>List(Of System.String).</returns>
    Public Function getUsedExtension() As List(Of String)

        Dim exts As New List(Of String)
        Dim ext As String = ""
        Dim s As String = "SELECT distinct [ExtCode] FROM [IncludedFiles]"

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Using CONN
            Dim command As New SqlCommand(s, CONN)
            Using command
                Using RSD As SqlDataReader = command.ExecuteReader()
                    If RSD.HasRows Then
                        Do While RSD.Read()
                            ext = RSD.GetValue(0).ToString
                            If Not exts.Contains(ext) Then
                                exts.Add(ext)
                            End If
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return exts

    End Function

    ''' <summary>
    ''' Gets the database update exists.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>System.Int32.</returns>
    Public Function getDBUpdateExists(FQN As String) As Integer

        Dim iCnt As Integer
        Dim S As String = "select count(*) from DBUpdate where FileName = '" + FQN + "'"

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Using CONN
            Dim command As New SqlCommand(S, CONN)
            Using command
                Using RSD As SqlDataReader = command.ExecuteReader()
                    If RSD.HasRows Then
                        Do While RSD.Read()
                            iCnt = RSD.GetValue(0).ToString.ToLower
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return iCnt

    End Function

    ''' <summary>
    ''' Gets the database update last write date.
    ''' </summary>
    ''' <param name="FQN">The FQN.</param>
    ''' <returns>DateTime.</returns>
    Public Function getDBUpdateLastWriteDate(FQN As String) As DateTime

        Dim AppliedDate As DateTime = Now
        Dim S As String = "select DateApplied from DBUpdate where FileName = '" + FQN + "'"

        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)
        CONN.Open()
        Using CONN
            Dim command As New SqlCommand(S, CONN)
            Using command
                Using RSD As SqlDataReader = command.ExecuteReader()
                    If RSD.HasRows Then
                        Do While RSD.Read()
                            AppliedDate = RSD.GetDateTime(0)
                        Loop
                    End If
                End Using
            End Using
        End Using

        Return AppliedDate

    End Function

    ''' <summary>
    ''' Gets the source dt.
    ''' </summary>
    ''' <returns>DataTable.</returns>
    Function getSrcDT() As DataTable
        Dim strSql As String = "select RowGuid, SourceName, OriginalFileType, SourceTypeCode from DataSource"
        Dim DT As New DataTable
        Dim CS As String = getRepoConnStr()
        Dim CONN As New SqlConnection(CS)

        Try
            Using CONN
                CONN.Open()
                Using dad As New SqlDataAdapter(strSql, CONN)
                    dad.Fill(DT)
                End Using
                CONN.Close()
            End Using
        Catch ex As Exception
            LOG.WriteToArchiveLog("FATAL ERROR getErrDT: " + ex.Message)
        End Try

        Dim count_row As Integer = DT.Rows.Count

        Return DT
    End Function

    ''' <summary>
    ''' Fetches the where in clause.
    ''' </summary>
    ''' <param name="DirName">Name of the dir.</param>
    ''' <returns>System.String.</returns>
    Function fetchWhereInClause(DirName As String) As String
        Dim WhereIn As String = ""
        Dim spName As String = "GenWhereInClause"

        Try
            CloseConn()
            CkConn()

            Dim CMD As SqlCommand = New SqlCommand(spName, gConn)
            CMD.CommandType = Data.CommandType.StoredProcedure

            Dim DIR As IDbDataParameter = CMD.CreateParameter()
            Dim UID As IDbDataParameter = CMD.CreateParameter()
            Dim ReturnParm As IDbDataParameter = CMD.CreateParameter()

            UID.ParameterName = "@UserID"
            UID.Value = gCurrUserGuidID
            ReturnParm.Direction = System.Data.ParameterDirection.Input
            ReturnParm.DbType = System.Data.DbType.String
            CMD.Parameters.Add(UID)

            DIR.ParameterName = "@DIR"
            DIR.Value = DirName
            ReturnParm.Direction = System.Data.ParameterDirection.Input
            ReturnParm.DbType = System.Data.DbType.String
            CMD.Parameters.Add(DIR)

            ReturnParm.ParameterName = "@result"
            ReturnParm.Direction = System.Data.ParameterDirection.Output
            ReturnParm.DbType = System.Data.DbType.String
            ReturnParm.Size = 1000
            CMD.Parameters.Add(ReturnParm)

            CMD.ExecuteNonQuery()

            WhereIn = ReturnParm.Value
        Catch ex As Exception
            WhereIn = ""
            LOG.WriteToArchiveLog("ERROR fetchWhereInClause: " + ex.Message)
        End Try



        Return WhereIn
    End Function

    ''' <summary>
    ''' Gets the where in clauses.
    ''' </summary>
    ''' <returns>Dictionary(Of System.String, System.String).</returns>
    Function getWhereInClauses() As Dictionary(Of String, String)

        Dim DICT_WhereAS As New Dictionary(Of String, String)
        Dim B As Boolean = False
        Dim TimeTrk As Boolean = True
        Dim spName As String = "GenWhereInClause"
        Try

            Dim DIRS As New List(Of String)
            DIRS = GetDirectories(gCurrLoginID)

            For Each DirName As String In DIRS
                Dim WClause As String = fetchWhereInClause(DirName)
                If Not DICT_WhereAS.Keys.Contains(DirName) Then
                    DICT_WhereAS.Add(DirName, WClause)
                End If
            Next

        Catch ex As Exception
            DICT_WhereAS = Nothing
            LOG.WriteToArchiveLog("getWhereInClauses : ExecSP : 1221 : ", ex)
        End Try
        Return DICT_WhereAS
    End Function

#Region "IDisposable Support"
    ''' <summary>
    ''' The disposed value
    ''' </summary>
    Private disposedValue As Boolean ' To detect redundant calls

    ' IDisposable
    ''' <summary>
    ''' Releases unmanaged and - optionally - managed resources.
    ''' </summary>
    ''' <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    Protected Overridable Sub Dispose(disposing As Boolean)
        If Not disposedValue Then
            If disposing Then
                ' TODO: dispose managed state (managed objects).
                RemoveHandler currDomain.UnhandledException, AddressOf MYExnHandler
                RemoveHandler Application.ThreadException, AddressOf MYThreadHandler
            End If

            ' TODO: free unmanaged resources (unmanaged objects) and override Finalize() below.
            ' TODO: set large fields to null.
        End If
        disposedValue = True
    End Sub


    ' This code added by Visual Basic to correctly implement the disposable pattern.
    ''' <summary>
    ''' Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
    ''' </summary>
    Public Sub Dispose() Implements IDisposable.Dispose
        ' Do not change this code.  Put cleanup code in Dispose(disposing As Boolean) above.
        Dispose(True)
        ' TODO: uncomment the following line if Finalize() is overridden above.
        ' GC.SuppressFinalize(Me)
    End Sub
#End Region

End Class